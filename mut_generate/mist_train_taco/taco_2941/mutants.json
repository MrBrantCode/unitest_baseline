{
  "task_id": "taco_2941",
  "entry_point": "count_suitable_colorings",
  "mutant_count": 252,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244354",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244354\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244352",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244352\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 0",
      "code": "def count_suitable_colorings(n, k):\n    mod = 0\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 1\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = -998244353",
      "code": "def count_suitable_colorings(n, k):\n    mod = -998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k != 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[0][0] = 2",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 2\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[0][0] = 0",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 0\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[0][0] = 0",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 0\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[0][0] = -1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = -1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 1\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = -1\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 1\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans * 2 * mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 * mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans * 2 + mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 + mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 2:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 0:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 0:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == -1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 1\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return -1\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 1\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp1 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp1 = [[0] / n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] / n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp1 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp1 = [[0] + n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] + n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp1 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp1 = [[0] ** n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] ** n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp2 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp2 = [[0] / n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] / n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp2 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp2 = [[0] + n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] + n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp2 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp2 = [[0] ** n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] ** n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[0][1] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][1] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[0][-1] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][-1] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[0][1] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][1] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n + 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n * 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(2, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(0, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(0, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(-1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n - 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n * 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "t = (k - 1) // i",
      "mutated_line": "t = (k - 1) / i",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) / i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "t = (k - 1) // i",
      "mutated_line": "t = (k - 1) * i",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) * i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if t == 0:",
      "mutated_line": "if t != 0:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t != 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] / (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] / (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] + (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] + (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] ** (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] ** (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] / (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] / (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] + (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] + (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] ** (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] ** (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dps1[0] = 1",
      "mutated_line": "dps1[0] = 2",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 2\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dps1[0] = 1",
      "mutated_line": "dps1[0] = 0",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 0\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dps1[0] = 1",
      "mutated_line": "dps1[0] = 0",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 0\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dps1[0] = 1",
      "mutated_line": "dps1[0] = -1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = -1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = sum(dp1[i - 1]) % mod",
      "mutated_line": "x = sum(dp1[i - 1]) * mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) * mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = sum(dp1[i - 1]) % mod",
      "mutated_line": "x = sum(dp1[i - 1]) + mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) + mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + x * sum(dps1[:-1])) * mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) * mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = ans + x * sum(dps1[:-1]) + mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = ans + x * sum(dps1[:-1]) + mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans / 2 % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans / 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return (ans + 2) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return (ans + 2) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans ** 2 % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans ** 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[1][0] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[1][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[-1][0] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[-1][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1[0][0] = 1",
      "mutated_line": "dp1[1][0] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[1][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 2):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 0):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 0):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - -1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i - 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i - 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i * 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i * 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "dp2[j][0] += dp1[j][l]",
      "mutated_line": "dp2[j][0] -= dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] -= dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 1 if j == l else j][l + 1] -= dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] -= dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 2):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 0):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 0):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + -1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "t = (k - 1) // i",
      "mutated_line": "t = (k + 1) // i",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k + 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "t = (k - 1) // i",
      "mutated_line": "t = k * 1 // i",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = k * 1 // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if t == 0:",
      "mutated_line": "if t == 1:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 1:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if t == 0:",
      "mutated_line": "if t == -1:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == -1:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if t == 0:",
      "mutated_line": "if t == 1:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 1:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] * (t - 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t - 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] * (t * 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t * 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] * (t - 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t - 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] * (t * 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t * 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dps1[0] = 1",
      "mutated_line": "dps1[1] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[1] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dps1[0] = 1",
      "mutated_line": "dps1[-1] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[-1] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dps1[0] = 1",
      "mutated_line": "dps1[1] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[1] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n + 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n + 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n * 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n * 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "dps2[0] += dps1[l]",
      "mutated_line": "dps2[0] -= dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] -= dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "dps2[l + 1] += dps1[l]",
      "mutated_line": "dps2[l + 1] -= dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] -= dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans - x * sum(dps1[:-1])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans - x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = ans * (x * sum(dps1[:-1])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = ans * (x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans * 3 % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 3 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans * 1 % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 1 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans * 0 % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 0 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans * 1 % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 1 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ans * 2 % mod",
      "mutated_line": "return ans * -2 % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * -2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp1 = [[1] * n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[1] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp1 = [[-1] * n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[-1] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp1 = [[1] * n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[1] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp2 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp2 = [[1] * n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[1] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp2 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp2 = [[-1] * n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[-1] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp2 = [[0] * n for _ in range(n)]",
      "mutated_line": "dp2 = [[1] * n for _ in range(n)]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[1] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 2):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 2):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 0):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 0):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + -1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + -1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for l in range(j + 1):",
      "mutated_line": "for l in range(j - 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j - 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for l in range(j + 1):",
      "mutated_line": "for l in range(j * 1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j * 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dp2[j][0] >= mod:",
      "mutated_line": "if dp2[j][0] > mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] > mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dp2[j][0] >= mod:",
      "mutated_line": "if dp2[j][0] < mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] < mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dp2[j][0] >= mod:",
      "mutated_line": "if dp2[j][0] == mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] == mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "dp2[j][0] -= mod",
      "mutated_line": "dp2[j][0] += mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] += mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l + 1] > mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] > mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l + 1] < mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] < mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l + 1] == mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] == mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 1 if j == l else j][l + 1] += mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] += mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[j][l] = 0",
      "mutated_line": "dp1[j][l] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 1\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[j][l] = 0",
      "mutated_line": "dp1[j][l] = -1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = -1\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[j][l] = 0",
      "mutated_line": "dp1[j][l] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 1\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "t = (k - 1) // i",
      "mutated_line": "t = (k - 2) // i",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 2) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "t = (k - 1) // i",
      "mutated_line": "t = (k - 0) // i",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 0) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "t = (k - 1) // i",
      "mutated_line": "t = (k - 0) // i",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 0) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "t = (k - 1) // i",
      "mutated_line": "t = (k - -1) // i",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - -1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [1] * (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [1] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [-1] * (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [-1] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [1] * (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [1] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] * (t + 2)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 2)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] * (t + 0)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 0)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] * (t + 0)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 0)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dps1 = [0] * (t + 1)",
      "mutated_line": "dps1 = [0] * (t + -1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + -1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [1] * (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [1] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [-1] * (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [-1] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [1] * (t + 1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [1] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] * (t + 2)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 2)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] * (t + 0)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 0)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] * (t + 0)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 0)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dps2 = [0] * (t + 1)",
      "mutated_line": "dps2 = [0] * (t + -1)",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + -1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 2):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 2):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 0):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 0):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - -1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - -1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dps2[0] >= mod:",
      "mutated_line": "if dps2[0] > mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] > mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dps2[0] >= mod:",
      "mutated_line": "if dps2[0] < mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] < mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dps2[0] >= mod:",
      "mutated_line": "if dps2[0] == mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] == mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "dps2[0] -= mod",
      "mutated_line": "dps2[0] += mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] += mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l + 1] > mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] > mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l + 1] < mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] < mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l + 1] == mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] == mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "dps2[l + 1] -= mod",
      "mutated_line": "dps2[l + 1] += mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] += mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dps1[l] = 0",
      "mutated_line": "dps1[l] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 1\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dps1[l] = 0",
      "mutated_line": "dps1[l] = -1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = -1\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dps1[l] = 0",
      "mutated_line": "dps1[l] = 1",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 1\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + x / sum(dps1[:-1])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x / sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + (x + sum(dps1[:-1]))) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + (x + sum(dps1[:-1]))) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + x ** sum(dps1[:-1])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x ** sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for l in range(j + 1):",
      "mutated_line": "for l in range(j + 2):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 2):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for l in range(j + 1):",
      "mutated_line": "for l in range(j + 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 0):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for l in range(j + 1):",
      "mutated_line": "for l in range(j + 0):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 0):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for l in range(j + 1):",
      "mutated_line": "for l in range(j + -1):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + -1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp2[j][0] += dp1[j][l]",
      "mutated_line": "dp2[j][1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][1] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp2[j][0] += dp1[j][l]",
      "mutated_line": "dp2[j][-1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][-1] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp2[j][0] += dp1[j][l]",
      "mutated_line": "dp2[j][1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][1] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 1 if j == l else j][l - 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l - 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 1 if j == l else j][l * 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l * 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for l in range(min(j + 1, t)):",
      "mutated_line": "for l in range(min(j - 1, t)):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j - 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for l in range(min(j + 1, t)):",
      "mutated_line": "for l in range(min(j * 1, t)):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j * 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dps2[0] += dps1[l]",
      "mutated_line": "dps2[1] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[1] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dps2[0] += dps1[l]",
      "mutated_line": "dps2[-1] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[-1] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dps2[0] += dps1[l]",
      "mutated_line": "dps2[1] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[1] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dps2[l + 1] += dps1[l]",
      "mutated_line": "dps2[l - 1] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l - 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dps2[l + 1] += dps1[l]",
      "mutated_line": "dps2[l * 1] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l * 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = sum(dp1[i - 1]) % mod",
      "mutated_line": "x = sum(dp1[i + 1]) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i + 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = sum(dp1[i - 1]) % mod",
      "mutated_line": "x = sum(dp1[i * 1]) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i * 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp2[j][0] >= mod:",
      "mutated_line": "if dp2[j][1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][1] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp2[j][0] >= mod:",
      "mutated_line": "if dp2[j][-1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][-1] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp2[j][0] >= mod:",
      "mutated_line": "if dp2[j][1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][1] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp2[j][0] -= mod",
      "mutated_line": "dp2[j][1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][1] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp2[j][0] -= mod",
      "mutated_line": "dp2[j][-1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][-1] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp2[j][0] -= mod",
      "mutated_line": "dp2[j][1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][1] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 1 if j == l else j][l + 2] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 2] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 1 if j == l else j][l + 0] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 0] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 1 if j == l else j][l + 0] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 0] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 1 if j == l else j][l + -1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + -1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l - 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l - 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l * 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l * 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 1 if j == l else j][l - 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l - 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 1 if j == l else j][l * 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l * 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for l in range(min(j + 1, t)):",
      "mutated_line": "for l in range(min(j + 2, t)):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 2, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for l in range(min(j + 1, t)):",
      "mutated_line": "for l in range(min(j + 0, t)):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 0, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for l in range(min(j + 1, t)):",
      "mutated_line": "for l in range(min(j + 0, t)):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 0, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for l in range(min(j + 1, t)):",
      "mutated_line": "for l in range(min(j + -1, t)):",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + -1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if dps2[0] >= mod:",
      "mutated_line": "if dps2[1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[1] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if dps2[0] >= mod:",
      "mutated_line": "if dps2[-1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[-1] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if dps2[0] >= mod:",
      "mutated_line": "if dps2[1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[1] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dps2[0] -= mod",
      "mutated_line": "dps2[1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[1] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dps2[0] -= mod",
      "mutated_line": "dps2[-1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[-1] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dps2[0] -= mod",
      "mutated_line": "dps2[1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[1] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dps2[l + 1] += dps1[l]",
      "mutated_line": "dps2[l + 2] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 2] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dps2[l + 1] += dps1[l]",
      "mutated_line": "dps2[l + 0] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 0] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dps2[l + 1] += dps1[l]",
      "mutated_line": "dps2[l + 0] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 0] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dps2[l + 1] += dps1[l]",
      "mutated_line": "dps2[l + -1] += dps1[l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + -1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l - 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l - 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l * 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l * 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dps2[l + 1] -= mod",
      "mutated_line": "dps2[l - 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l - 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dps2[l + 1] -= mod",
      "mutated_line": "dps2[l * 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l * 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = sum(dp1[i - 1]) % mod",
      "mutated_line": "x = sum(dp1[i - 2]) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 2]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = sum(dp1[i - 1]) % mod",
      "mutated_line": "x = sum(dp1[i - 0]) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 0]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = sum(dp1[i - 1]) % mod",
      "mutated_line": "x = sum(dp1[i - 0]) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 0]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = sum(dp1[i - 1]) % mod",
      "mutated_line": "x = sum(dp1[i - -1]) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - -1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 1 if j != l else j][l + 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j != l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j - 1 if j == l else j][l + 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j - 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j * 1 if j == l else j][l + 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j * 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l + 2] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 2] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l + 0] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 0] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l + 0] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 0] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j == l else j][l + -1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + -1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 1 if j == l else j][l + 2] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 2] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 1 if j == l else j][l + 0] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 0] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 1 if j == l else j][l + 0] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 0] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 1 if j == l else j][l + -1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + -1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l + 2] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 2] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l + 0] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 0] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l + 0] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 0] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dps2[l + 1] >= mod:",
      "mutated_line": "if dps2[l + -1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + -1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dps2[l + 1] -= mod",
      "mutated_line": "dps2[l + 2] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 2] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dps2[l + 1] -= mod",
      "mutated_line": "dps2[l + 0] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 0] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dps2[l + 1] -= mod",
      "mutated_line": "dps2[l + 0] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 0] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dps2[l + 1] -= mod",
      "mutated_line": "dps2[l + -1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + -1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 2 if j == l else j][l + 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 2 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 0 if j == l else j][l + 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 0 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + 0 if j == l else j][l + 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 0 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]",
      "mutated_line": "dp2[j + -1 if j == l else j][l + 1] += dp1[j][l]",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + -1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 1 if j != l else j][l + 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j != l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j - 1 if j == l else j][l + 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j - 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j * 1 if j == l else j][l + 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j * 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 1 if j != l else j][l + 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j != l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j - 1 if j == l else j][l + 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j - 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j * 1 if j == l else j][l + 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j * 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + x * sum(dps1[:+1])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:+1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 2 if j == l else j][l + 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 2 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 0 if j == l else j][l + 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 0 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + 0 if j == l else j][l + 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 0 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp2[j + 1 if j == l else j][l + 1] >= mod:",
      "mutated_line": "if dp2[j + -1 if j == l else j][l + 1] >= mod:",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + -1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 2 if j == l else j][l + 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 2 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 0 if j == l else j][l + 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 0 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + 0 if j == l else j][l + 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 0 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp2[j + 1 if j == l else j][l + 1] -= mod",
      "mutated_line": "dp2[j + -1 if j == l else j][l + 1] -= mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + -1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-1])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + x * sum(dps1[:-2])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-2])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + x * sum(dps1[:-0])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-0])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + x * sum(dps1[:-0])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:-0])) % mod\n    return ans * 2 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = (ans + x * sum(dps1[:-1])) % mod",
      "mutated_line": "ans = (ans + x * sum(dps1[:--1])) % mod",
      "code": "def count_suitable_colorings(n, k):\n    mod = 998244353\n    if k == 1:\n        return 0\n    dp1 = [[0] * n for _ in range(n)]\n    dp2 = [[0] * n for _ in range(n)]\n    dp1[0][0] = 1\n    for i in range(n - 1):\n        for j in range(i + 1):\n            for l in range(j + 1):\n                dp2[j][0] += dp1[j][l]\n                if dp2[j][0] >= mod:\n                    dp2[j][0] -= mod\n                dp2[j + 1 if j == l else j][l + 1] += dp1[j][l]\n                if dp2[j + 1 if j == l else j][l + 1] >= mod:\n                    dp2[j + 1 if j == l else j][l + 1] -= mod\n                dp1[j][l] = 0\n        (dp1, dp2) = (dp2, dp1)\n    ans = 0\n    for i in range(1, n + 1):\n        t = (k - 1) // i\n        if t == 0:\n            break\n        dps1 = [0] * (t + 1)\n        dps2 = [0] * (t + 1)\n        dps1[0] = 1\n        for j in range(n - 1):\n            for l in range(min(j + 1, t)):\n                dps2[0] += dps1[l]\n                if dps2[0] >= mod:\n                    dps2[0] -= mod\n                dps2[l + 1] += dps1[l]\n                if dps2[l + 1] >= mod:\n                    dps2[l + 1] -= mod\n                dps1[l] = 0\n            (dps1, dps2) = (dps2, dps1)\n        x = sum(dp1[i - 1]) % mod\n        ans = (ans + x * sum(dps1[:--1])) % mod\n    return ans * 2 % mod"
    }
  ]
}