{
  "task_id": "taco_67",
  "entry_point": "find_longest_palindrome_substring",
  "mutant_count": 102,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s = '#' + '#'.join(list((c for c in text))) + '#'",
      "mutated_line": "s = '#' + '#'.join(list((c for c in text))) - '#'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) - '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s = '#' + '#'.join(list((c for c in text))) + '#'",
      "mutated_line": "s = ('#' + '#'.join(list((c for c in text)))) * '#'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = ('#' + '#'.join(list((c for c in text)))) * '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = '$' + s + '^'",
      "mutated_line": "s = '$' + s - '^'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s - '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = '$' + s + '^'",
      "mutated_line": "s = ('$' + s) * '^'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = ('$' + s) * '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] / (n + 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] / (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] + (n + 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] + (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] ** (n + 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] ** (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_len = 0",
      "mutated_line": "max_len = 1",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 1\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_len = 0",
      "mutated_line": "max_len = -1",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = -1\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_len = 0",
      "mutated_line": "max_len = 1",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 1\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "pos = -1",
      "mutated_line": "pos = +1",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = +1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s = '#' + '#'.join(list((c for c in text))) + '#'",
      "mutated_line": "s = '#' - '#'.join(list((c for c in text))) + '#'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' - '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s = '#' + '#'.join(list((c for c in text))) + '#'",
      "mutated_line": "s = '#' * '#'.join(list((c for c in text))) + '#'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' * '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = '#' + '#'.join(list((c for c in text))) + '#'",
      "mutated_line": "s = '#' + '#'.join(list((c for c in text))) + ''",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + ''\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = '$' + s + '^'",
      "mutated_line": "s = '$' - s + '^'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' - s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = '$' + s + '^'",
      "mutated_line": "s = '$' * s + '^'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' * s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = '$' + s + '^'",
      "mutated_line": "s = '$' + s + ''",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + ''\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] * (n - 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n - 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] * (n * 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n * 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (2, 1)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (2, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (0, 1)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (0, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (0, 1)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (0, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (-1, 1)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (-1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (1, 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 2)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (1, 0)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 0)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (1, 0)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 0)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (1, -1)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, -1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = -1",
      "mutated_line": "pos = -2",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -2\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = -1",
      "mutated_line": "pos = -0",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -0\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = -1",
      "mutated_line": "pos = -0",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -0\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = -1",
      "mutated_line": "pos = --1",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = --1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(2, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(0, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(0, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(-1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n - 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n * 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while s[i - p[i]] == s[i + p[i]]:",
      "mutated_line": "while s[i - p[i]] != s[i + p[i]]:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] != s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "p[i] += 1",
      "mutated_line": "p[i] -= 1",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] -= 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if p[i] > max_len:",
      "mutated_line": "if p[i] >= max_len:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] >= max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if p[i] > max_len:",
      "mutated_line": "if p[i] <= max_len:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] <= max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if p[i] > max_len:",
      "mutated_line": "if p[i] != max_len:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] != max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i + p[i] > r:",
      "mutated_line": "if i + p[i] >= r:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] >= r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i + p[i] > r:",
      "mutated_line": "if i + p[i] <= r:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] <= r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i + p[i] > r:",
      "mutated_line": "if i + p[i] != r:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] != r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = '#' + '#'.join(list((c for c in text))) + '#'",
      "mutated_line": "s = '' + '#'.join(list((c for c in text))) + '#'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ''.join(ans.split(sep='#'))",
      "mutated_line": "return 'MUTATED'.join(ans.split(sep='#'))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return 'MUTATED'.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = '$' + s + '^'",
      "mutated_line": "s = '' + s + '^'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [1] * (n + 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [1] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [-1] * (n + 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [-1] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [1] * (n + 2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [1] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] * (n + 3)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 3)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] * (n + 1)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 1)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] * (n + 0)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 0)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] * (n + 1)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 1)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "p = [0] * (n + 2)",
      "mutated_line": "p = [0] * (n + -2)",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + -2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 2):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 0):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 0):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + -1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(1, min(r - i, p[l + r - i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(1, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(-1, min(r - i, p[l + r - i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(-1, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(1, min(r - i, p[l + r - i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(1, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[i] += 1",
      "mutated_line": "p[i] += 2",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 2\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[i] += 1",
      "mutated_line": "p[i] += 0",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 0\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[i] += 1",
      "mutated_line": "p[i] += 0",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 0\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[i] += 1",
      "mutated_line": "p[i] += -1",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += -1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if i + p[i] > r:",
      "mutated_line": "if i - p[i] > r:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i - p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if i + p[i] > r:",
      "mutated_line": "if i * p[i] > r:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i * p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r = i + p[i]",
      "mutated_line": "r = i - p[i]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i - p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r = i + p[i]",
      "mutated_line": "r = i * p[i]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i * p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "l = i - p[i]",
      "mutated_line": "l = i + p[i]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i + p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "l = i - p[i]",
      "mutated_line": "l = i * p[i]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i * p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] - 2:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] - 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[(pos - p[pos]) * 2:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[(pos - p[pos]) * 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 2:pos + p[pos] + 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] + 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 2:(pos + p[pos]) * 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:(pos + p[pos]) * 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ''.join(ans.split(sep='#'))",
      "mutated_line": "return ''.join(ans.split(sep=''))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep=''))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(0, min(r + i, p[l + r - i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r + i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(0, min(r * i, p[l + r - i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r * i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while s[i - p[i]] == s[i + p[i]]:",
      "mutated_line": "while s[i + p[i]] == s[i + p[i]]:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i + p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while s[i - p[i]] == s[i + p[i]]:",
      "mutated_line": "while s[i * p[i]] == s[i + p[i]]:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i * p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while s[i - p[i]] == s[i + p[i]]:",
      "mutated_line": "while s[i - p[i]] == s[i - p[i]]:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i - p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while s[i - p[i]] == s[i + p[i]]:",
      "mutated_line": "while s[i - p[i]] == s[i * p[i]]:",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i * p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos + p[pos] + 2:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos + p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos * p[pos] + 2:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos * p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 3:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 3:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 1:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 1:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 0:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 0:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 1:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 1:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + -2:pos + p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + -2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 2:pos - p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos - p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 2:pos * p[pos] - 1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos * p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 2:pos + p[pos] - 2]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 2]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 2:pos + p[pos] - 0]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 0]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 2:pos + p[pos] - 0]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 0]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return s[pos - p[pos] + 2:pos + p[pos] - 1]",
      "mutated_line": "return s[pos - p[pos] + 2:pos + p[pos] - -1]",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - -1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = '#' + '#'.join(list((c for c in text))) + '#'",
      "mutated_line": "s = '#' + ''.join(list((c for c in text))) + '#'",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + ''.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(0, min(r - i, p[l + r + i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l + r + i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(0, min(r - i, p[(l + r) * i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[(l + r) * i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(0, min(r - i, p[l - r - i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l - r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p[i] = max(0, min(r - i, p[l + r - i]))",
      "mutated_line": "p[i] = max(0, min(r - i, p[l * r - i]))",
      "code": "def find_longest_palindrome_substring(text: str) -> str:\n\n    def manacher_odd(s: str) -> str:\n        n = len(s)\n        s = '$' + s + '^'\n        p = [0] * (n + 2)\n        (l, r) = (1, 1)\n        max_len = 0\n        pos = -1\n        for i in range(1, n + 1):\n            p[i] = max(0, min(r - i, p[l * r - i]))\n            while s[i - p[i]] == s[i + p[i]]:\n                p[i] += 1\n            if p[i] > max_len:\n                max_len = p[i]\n                pos = i\n            if i + p[i] > r:\n                r = i + p[i]\n                l = i - p[i]\n        return s[pos - p[pos] + 2:pos + p[pos] - 1]\n    s = '#' + '#'.join(list((c for c in text))) + '#'\n    ans = manacher_odd(s)\n    return ''.join(ans.split(sep='#'))"
    }
  ]
}