{
  "task_id": "taco_8468",
  "entry_point": "count_possible_combinations",
  "mutant_count": 166,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 - 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 - 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 * 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 * 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "n = n * 2",
      "mutated_line": "n = n / 2",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n / 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "n = n * 2",
      "mutated_line": "n = n + 2",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n + 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "n = n * 2",
      "mutated_line": "n = n ** 2",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n ** 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 1\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = -1\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 1\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans -= cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans -= cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k != 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans += 1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans += 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return ans % mod",
      "mutated_line": "return ans * mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans * mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return ans % mod",
      "mutated_line": "return ans + mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans + mod"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 * 9 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 * 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 + 9 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 + 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 8) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 8) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 6) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 6) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 0) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 0) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 1) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 1) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + -7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + -7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 0 and r > n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 and r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] * g2[n - r] * mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] * mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] * g2[n - r] + mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] + mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n = n * 2",
      "mutated_line": "n = n * 3",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 3\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n = n * 2",
      "mutated_line": "n = n * 1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 1\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n = n * 2",
      "mutated_line": "n = n * 0",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 0\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n = n * 2",
      "mutated_line": "n = n * 1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 1\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n = n * 2",
      "mutated_line": "n = n * -2",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * -2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "r = min(n, k + 1)",
      "mutated_line": "r = min(n, k - 1)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k - 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "r = min(n, k + 1)",
      "mutated_line": "r = min(n, k * 1)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k * 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g1 = [1, 1]",
      "mutated_line": "g1 = [2, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [2, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g1 = [1, 1]",
      "mutated_line": "g1 = [0, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [0, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g1 = [1, 1]",
      "mutated_line": "g1 = [0, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [0, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g1 = [1, 1]",
      "mutated_line": "g1 = [-1, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [-1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g1 = [1, 1]",
      "mutated_line": "g1 = [1, 2]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 2]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g1 = [1, 1]",
      "mutated_line": "g1 = [1, 0]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 0]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g1 = [1, 1]",
      "mutated_line": "g1 = [1, 0]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 0]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g1 = [1, 1]",
      "mutated_line": "g1 = [1, -1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, -1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g2 = [1, 1]",
      "mutated_line": "g2 = [2, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [2, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g2 = [1, 1]",
      "mutated_line": "g2 = [0, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [0, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g2 = [1, 1]",
      "mutated_line": "g2 = [0, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [0, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g2 = [1, 1]",
      "mutated_line": "g2 = [-1, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [-1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g2 = [1, 1]",
      "mutated_line": "g2 = [1, 2]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 2]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g2 = [1, 1]",
      "mutated_line": "g2 = [1, 0]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 0]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g2 = [1, 1]",
      "mutated_line": "g2 = [1, 0]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 0]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g2 = [1, 1]",
      "mutated_line": "g2 = [1, -1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, -1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [1, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [1, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [-1, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [-1, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [1, 1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [1, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [0, 2]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 2]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [0, 0]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 0]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [0, 0]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 0]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [0, -1]",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, -1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(3, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(1, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(0, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(1, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(-2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n - 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n * 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) / cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) / cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) + cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) + cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) ** cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) ** cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 2:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 0:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 0:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == -1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 2",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 2\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 0\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 0\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= -1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= -1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=11 ** 9 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=11 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=9 ** 9 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=9 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=0 ** 9 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=0 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=1 ** 9 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=1 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=-10 ** 9 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=-10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 10 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 10 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 8 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 8 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 0 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 0 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 1 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 1 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_combinations(n: int, k: int, mod: int = 10**9 + 7) -> int:",
      "mutated_line": "def count_possible_combinations(n: int, k: int, mod: int=10 ** -9 + 7) -> int:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** -9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r <= 0 or r > n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r <= 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r >= 0 or r > n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r >= 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r != 0 or r > n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r != 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 0 or r >= n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r >= n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 0 or r <= n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r <= n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 0 or r != n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r != n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 1\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return -1\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 1\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = min(r, n - r)",
      "mutated_line": "r = min(r, n + r)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n + r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = min(r, n - r)",
      "mutated_line": "r = min(r, n * r)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n * r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] / g2[n - r] % mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] / g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return (g1[n] * g2[r] + g2[n - r]) % mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return (g1[n] * g2[r] + g2[n - r]) % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return (g1[n] * g2[r]) ** g2[n - r] % mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return (g1[n] * g2[r]) ** g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = min(n, k + 1)",
      "mutated_line": "r = min(n, k + 2)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 2)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = min(n, k + 1)",
      "mutated_line": "r = min(n, k + 0)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 0)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = min(n, k + 1)",
      "mutated_line": "r = min(n, k + 0)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 0)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = min(n, k + 1)",
      "mutated_line": "r = min(n, k + -1)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + -1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 2):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 0):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 0):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + -1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-1] * i * mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i * mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-1] * i + mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i + mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] * (mod // i) * mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) * mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] * (mod // i) + mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) + mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-1] * mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] * mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-1] + mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] + mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 1 or r > n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 1 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < -1 or r > n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < -1 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 1 or r > n:",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 1 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] / g2[r] * g2[n - r] % mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] / g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return (g1[n] + g2[r]) * g2[n - r] % mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return (g1[n] + g2[r]) * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] ** g2[r] * g2[n - r] % mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] ** g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-1] / i % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] / i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append((g1[-1] + i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append((g1[-1] + i) % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-1] ** i % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] ** i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] / (mod // i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] / (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append((-inverse[mod % i] + mod // i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append((-inverse[mod % i] + mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append((-inverse[mod % i]) ** (mod // i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append((-inverse[mod % i]) ** (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] / inverse[-1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] / inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append((g2[-1] + inverse[-1]) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append((g2[-1] + inverse[-1]) % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] ** inverse[-1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] ** inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n / 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n / 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n * 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n * 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 + 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 + 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 * 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 * 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] * g2[n + r] % mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n + r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] * g2[n * r] % mod",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n * r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(+inverse[mod % i] * (mod // i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(+inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] * (mod / i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod / i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] * (mod * i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod * i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 3, i, mod) * cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 3, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 1, i, mod) * cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 1, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 0, i, mod) * cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 0, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 1, i, mod) * cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 1, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // -2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // -2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n / 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n / 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n * 2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n * 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 2, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 2, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 0, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 0, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 0, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 0, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - -1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - -1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[+1] * i % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[+1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[+1] * inverse[-1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[+1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[+1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[+1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 3 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 3 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 1 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 1 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 0 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 0 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // 1 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 1 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)",
      "mutated_line": "ans += cmb(n // 2, i, mod) * cmb(n // -2 - 1, i, mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // -2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-2] * i % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-2] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-0] * i % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-0] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-0] * i % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-0] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[--1] * i % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[--1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod * i] * (mod // i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod * i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod + i] * (mod // i) % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod + i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-2] * inverse[-1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-2] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-0] * inverse[-1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-0] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-0] * inverse[-1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-0] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[--1] * inverse[-1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[--1] * inverse[-1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-2] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-2] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-0] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-0] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-0] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-0] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[--1] % mod)",
      "code": "def count_possible_combinations(n: int, k: int, mod: int=10 ** 9 + 7) -> int:\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    n = n * 2\n    r = min(n, k + 1)\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, n + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[--1] % mod)\n    ans = 0\n    for i in range(r):\n        ans += cmb(n // 2, i, mod) * cmb(n // 2 - 1, i, mod)\n    if k == 1:\n        ans -= 1\n    return ans % mod"
    }
  ]
}