{
  "task_id": "taco_719",
  "entry_point": "max_cute_set_size",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inv = [0] * n",
      "mutated_line": "inv = [0] / n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] / n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inv = [0] * n",
      "mutated_line": "inv = [0] + n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] + n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inv = [0] * n",
      "mutated_line": "inv = [0] ** n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] ** n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "outv = [0] * n",
      "mutated_line": "outv = [0] / n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] / n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "outv = [0] * n",
      "mutated_line": "outv = [0] + n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] + n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "outv = [0] * n",
      "mutated_line": "outv = [0] ** n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] ** n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "inv[u] += 1",
      "mutated_line": "inv[u] -= 1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] -= 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "outv[v] += 1",
      "mutated_line": "outv[v] -= 1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] -= 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "inv[a] -= 1",
      "mutated_line": "inv[a] += 1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] += 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "outv[b] -= 1",
      "mutated_line": "outv[b] += 1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] += 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [0] / n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] / n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [0] + n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] + n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [0] ** n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] ** n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return max(dp) + 1",
      "mutated_line": "return max(dp) - 1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return max(dp) + 1",
      "mutated_line": "return max(dp) * 1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) * 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[u] += 1",
      "mutated_line": "inv[u] += 2",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 2\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[u] += 1",
      "mutated_line": "inv[u] += 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 0\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[u] += 1",
      "mutated_line": "inv[u] += 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 0\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[u] += 1",
      "mutated_line": "inv[u] += -1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += -1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "outv[v] += 1",
      "mutated_line": "outv[v] += 2",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 2\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "outv[v] += 1",
      "mutated_line": "outv[v] += 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 0\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "outv[v] += 1",
      "mutated_line": "outv[v] += 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 0\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "outv[v] += 1",
      "mutated_line": "outv[v] += -1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += -1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 1 or outv[v] > 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 or outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inv[a] -= 1",
      "mutated_line": "inv[a] -= 2",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 2\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inv[a] -= 1",
      "mutated_line": "inv[a] -= 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 0\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inv[a] -= 1",
      "mutated_line": "inv[a] -= 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 0\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inv[a] -= 1",
      "mutated_line": "inv[a] -= -1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= -1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "outv[b] -= 1",
      "mutated_line": "outv[b] -= 2",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 2\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "outv[b] -= 1",
      "mutated_line": "outv[b] -= 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 0\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "outv[b] -= 1",
      "mutated_line": "outv[b] -= 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 0\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "outv[b] -= 1",
      "mutated_line": "outv[b] -= -1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= -1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if outv[i] <= 0:",
      "mutated_line": "if outv[i] < 0:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] < 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if outv[i] <= 0:",
      "mutated_line": "if outv[i] > 0:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] > 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if outv[i] <= 0:",
      "mutated_line": "if outv[i] == 0:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] == 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "outv[nextNode] -= 1",
      "mutated_line": "outv[nextNode] += 1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] += 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return max(dp) + 1",
      "mutated_line": "return max(dp) + 2",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return max(dp) + 1",
      "mutated_line": "return max(dp) + 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return max(dp) + 1",
      "mutated_line": "return max(dp) + 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return max(dp) + 1",
      "mutated_line": "return max(dp) + -1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inv = [0] * n",
      "mutated_line": "inv = [1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [1] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inv = [0] * n",
      "mutated_line": "inv = [-1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [-1] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inv = [0] * n",
      "mutated_line": "inv = [1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [1] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "outv = [0] * n",
      "mutated_line": "outv = [1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [1] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "outv = [0] * n",
      "mutated_line": "outv = [-1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [-1] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "outv = [0] * n",
      "mutated_line": "outv = [1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [1] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] >= 1 and outv[v] > 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] >= 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] <= 1 and outv[v] > 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] <= 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] != 1 and outv[v] > 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] != 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 1 and outv[v] >= 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] >= 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 1 and outv[v] <= 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] <= 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 1 and outv[v] != 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] != 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if outv[i] <= 0:",
      "mutated_line": "if outv[i] <= 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 1:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if outv[i] <= 0:",
      "mutated_line": "if outv[i] <= -1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= -1:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if outv[i] <= 0:",
      "mutated_line": "if outv[i] <= 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 1:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [1] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [-1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [-1] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [1] * n",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [1] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "outv[nextNode] -= 1",
      "mutated_line": "outv[nextNode] -= 2",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 2\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "outv[nextNode] -= 1",
      "mutated_line": "outv[nextNode] -= 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 0\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "outv[nextNode] -= 1",
      "mutated_line": "outv[nextNode] -= 0",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 0\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "outv[nextNode] -= 1",
      "mutated_line": "outv[nextNode] -= -1",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= -1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if outv[nextNode] == 0:",
      "mutated_line": "if outv[nextNode] != 0:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] != 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 2 and outv[v] > 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 2 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 0 and outv[v] > 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 0 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 0 and outv[v] > 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 0 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > -1 and outv[v] > 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > -1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 1 and outv[v] > 2:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 2:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 1 and outv[v] > 0:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 0:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 1 and outv[v] > 0:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 0:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if inv[u] > 1 and outv[v] > 1:",
      "mutated_line": "if inv[u] > 1 and outv[v] > -1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > -1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 1)",
      "mutated_line": "dp[nextNode] = max(dp[nextNode], dp[node] - 1)",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] - 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 1)",
      "mutated_line": "dp[nextNode] = max(dp[nextNode], dp[node] * 1)",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] * 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if outv[nextNode] == 0:",
      "mutated_line": "if outv[nextNode] == 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 1:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if outv[nextNode] == 0:",
      "mutated_line": "if outv[nextNode] == -1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == -1:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if outv[nextNode] == 0:",
      "mutated_line": "if outv[nextNode] == 1:",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 1:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 1)",
      "mutated_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 2)",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 2)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 1)",
      "mutated_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 0)",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 0)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 1)",
      "mutated_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 0)",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + 0)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[nextNode] = max(dp[nextNode], dp[node] + 1)",
      "mutated_line": "dp[nextNode] = max(dp[nextNode], dp[node] + -1)",
      "code": "def max_cute_set_size(n, m, edges):\n    from collections import deque\n    g = [[] for _ in range(n)]\n    inv = [0] * n\n    outv = [0] * n\n    for (u, v) in edges:\n        inv[u] += 1\n        outv[v] += 1\n    S = set()\n    for (u, v) in edges:\n        if inv[u] > 1 and outv[v] > 1:\n            g[u].append(v)\n        else:\n            S.add((u, v))\n    for (a, b) in S:\n        inv[a] -= 1\n        outv[b] -= 1\n    q = deque()\n    for i in range(n):\n        if outv[i] <= 0:\n            q.append(i)\n    dp = [0] * n\n    while q:\n        node = q.pop()\n        for nextNode in g[node]:\n            dp[nextNode] = max(dp[nextNode], dp[node] + -1)\n            outv[nextNode] -= 1\n            if outv[nextNode] == 0:\n                q.appendleft(nextNode)\n    return max(dp) + 1"
    }
  ]
}