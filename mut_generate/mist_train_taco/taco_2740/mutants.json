{
  "task_id": "taco_2740",
  "entry_point": "find_minimum_median_spanning_tree",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edge_count = 0",
      "mutated_line": "edge_count = 1",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 1\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edge_count = 0",
      "mutated_line": "edge_count = -1",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = -1\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edge_count = 0",
      "mutated_line": "edge_count = 1",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 1\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 1) / 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) / 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 1) * 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) * 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n - 1)",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n - 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n * 1)",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n * 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "edge_count += 1",
      "mutated_line": "edge_count -= 1",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count -= 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n + 1) // 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n + 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = n * 1 // 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = n * 1 // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 1) // 3",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 3\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 1) // 1",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 1\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 1) // 0",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 0\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 1) // 1",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 1\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 1) // -2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // -2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if self.table[x] < 0:",
      "mutated_line": "if self.table[x] <= 0:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] <= 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if self.table[x] < 0:",
      "mutated_line": "if self.table[x] >= 0:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] >= 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if self.table[x] < 0:",
      "mutated_line": "if self.table[x] != 0:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] != 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s1 != s2:",
      "mutated_line": "if s1 == s2:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 == s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return True\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n + 2)",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 2)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n + 0)",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 0)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n + 0)",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 0)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n + -1)",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + -1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "edge_count += 1",
      "mutated_line": "edge_count += 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 2\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "edge_count += 1",
      "mutated_line": "edge_count += 0",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 0\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "edge_count += 1",
      "mutated_line": "edge_count += 0",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 0\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "edge_count += 1",
      "mutated_line": "edge_count += -1",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += -1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if edge_count == n - 1:",
      "mutated_line": "if edge_count != n - 1:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count != n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 2) // 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 2) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 0) // 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 0) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - 0) // 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 0) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "median_index = (n - 1) // 2",
      "mutated_line": "median_index = (n - -1) // 2",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - -1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "self.table = [-1 for _ in range(size)]",
      "mutated_line": "self.table = [+1 for _ in range(size)]",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [+1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if self.table[x] < 0:",
      "mutated_line": "if self.table[x] < 1:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 1:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if self.table[x] < 0:",
      "mutated_line": "if self.table[x] < -1:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < -1:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if self.table[x] < 0:",
      "mutated_line": "if self.table[x] < 1:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 1:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.table[s1] <= self.table[s2]:",
      "mutated_line": "if self.table[s1] < self.table[s2]:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] < self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.table[s1] <= self.table[s2]:",
      "mutated_line": "if self.table[s1] > self.table[s2]:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] > self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.table[s1] <= self.table[s2]:",
      "mutated_line": "if self.table[s1] == self.table[s2]:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] == self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "self.table[s1] += self.table[s2]",
      "mutated_line": "self.table[s1] -= self.table[s2]",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] -= self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "self.table[s2] += self.table[s1]",
      "mutated_line": "self.table[s2] -= self.table[s1]",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] -= self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return False\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if edge_count == n - 1:",
      "mutated_line": "if edge_count == n + 1:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n + 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if edge_count == n - 1:",
      "mutated_line": "if edge_count == n * 1:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n * 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.table = [-1 for _ in range(size)]",
      "mutated_line": "self.table = [-2 for _ in range(size)]",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-2 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.table = [-1 for _ in range(size)]",
      "mutated_line": "self.table = [-0 for _ in range(size)]",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-0 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.table = [-1 for _ in range(size)]",
      "mutated_line": "self.table = [-0 for _ in range(size)]",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-0 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.table = [-1 for _ in range(size)]",
      "mutated_line": "self.table = [--1 for _ in range(size)]",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [--1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sorted_edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "sorted_edges = sorted(edges, key=lambda x: x[3])",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[3])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sorted_edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "sorted_edges = sorted(edges, key=lambda x: x[1])",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[1])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sorted_edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "sorted_edges = sorted(edges, key=lambda x: x[0])",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[0])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sorted_edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "sorted_edges = sorted(edges, key=lambda x: x[1])",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[1])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sorted_edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "sorted_edges = sorted(edges, key=lambda x: x[-2])",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[-2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if edge_count == n - 1:",
      "mutated_line": "if edge_count == n - 2:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 2:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if edge_count == n - 1:",
      "mutated_line": "if edge_count == n - 0:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 0:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if edge_count == n - 1:",
      "mutated_line": "if edge_count == n - 0:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - 0:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if edge_count == n - 1:",
      "mutated_line": "if edge_count == n - -1:",
      "code": "def find_minimum_median_spanning_tree(n, m, edges):\n\n    class UnionFind:\n\n        def __init__(self, size):\n            self.table = [-1 for _ in range(size)]\n\n        def find(self, x):\n            if self.table[x] < 0:\n                return x\n            else:\n                self.table[x] = self.find(self.table[x])\n                return self.table[x]\n\n        def union(self, x, y):\n            s1 = self.find(x)\n            s2 = self.find(y)\n            if s1 != s2:\n                if self.table[s1] <= self.table[s2]:\n                    self.table[s1] += self.table[s2]\n                    self.table[s2] = s1\n                else:\n                    self.table[s2] += self.table[s1]\n                    self.table[s1] = s2\n                return True\n            return False\n    sorted_edges = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    edge_count = 0\n    selected_edges = []\n    for (s, t, c) in sorted_edges:\n        if uf.union(s, t):\n            selected_edges.append(c)\n            edge_count += 1\n            if edge_count == n - -1:\n                break\n    selected_edges.sort()\n    median_index = (n - 1) // 2\n    median_value = selected_edges[median_index]\n    return median_value"
    }
  ]
}