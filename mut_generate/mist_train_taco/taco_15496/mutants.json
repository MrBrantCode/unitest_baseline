{
  "task_id": "taco_15496",
  "entry_point": "has_cycle_in_board",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 0 or board[x - 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 or board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 0 or board[x][y - 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 or board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 1 or board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 or board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 1 or board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 or board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return True\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x >= 0 and board[x - 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x >= 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x <= 0 and board[x - 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x <= 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x != 0 and board[x - 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x != 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 0 and board[x - 1][y] != colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] != colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y >= 0 and board[x][y - 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y >= 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y <= 0 and board[x][y - 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y <= 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y != 0 and board[x][y - 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y != 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 0 and board[x][y - 1] != colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] != colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x <= n - 1 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x <= n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x >= n - 1 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x >= n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x != n - 1 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x != n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 1 and board[x + 1][y] != colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] != colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y <= m - 1 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y <= m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y >= m - 1 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y >= m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y != m - 1 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y != m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 1 and board[x][y + 1] != colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] != colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if v in visited:",
      "mutated_line": "if v not in visited:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v not in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (i, j) not in visited:",
      "mutated_line": "if (i, j) in visited:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 1 and board[x - 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 1 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > -1 and board[x - 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > -1 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 1 and board[x - 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 1 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 1 and board[x][y - 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 1 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > -1 and board[x][y - 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > -1 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 1 and board[x][y - 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 1 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n + 1 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n + 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n * 1 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n * 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m + 1 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m + 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m * 1 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m * 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return False\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if u != parent:",
      "mutated_line": "if u == parent:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u == parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res.append((x - 1, y))",
      "mutated_line": "res.append((x + 1, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x + 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res.append((x - 1, y))",
      "mutated_line": "res.append((x * 1, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x * 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 0 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y + 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 0 and board[x][y * 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y * 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res.append((x, y - 1))",
      "mutated_line": "res.append((x, y + 1))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y + 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "res.append((x, y - 1))",
      "mutated_line": "res.append((x, y * 1))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y * 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 2 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 2 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 0 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 0 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 0 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 0 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - -1 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - -1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((x + 1, y))",
      "mutated_line": "res.append((x - 1, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x - 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((x + 1, y))",
      "mutated_line": "res.append((x * 1, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x * 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 2 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 2 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 0 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 0 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 0 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 0 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - -1 and board[x][y + 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - -1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 1 and board[x][y - 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y - 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 1 and board[x][y * 1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y * 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res.append((x, y + 1))",
      "mutated_line": "res.append((x, y - 1))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y - 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res.append((x, y + 1))",
      "mutated_line": "res.append((x, y * 1))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y * 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return False\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 0 and board[x + 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x + 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 0 and board[x * 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x * 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res.append((x - 1, y))",
      "mutated_line": "res.append((x - 2, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 2, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res.append((x - 1, y))",
      "mutated_line": "res.append((x - 0, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 0, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res.append((x - 1, y))",
      "mutated_line": "res.append((x - 0, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 0, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res.append((x - 1, y))",
      "mutated_line": "res.append((x - -1, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - -1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 0 and board[x][y - 2] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 2] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 0 and board[x][y - 0] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 0] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 0 and board[x][y - 0] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 0] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y > 0 and board[x][y - 1] == colour:",
      "mutated_line": "if y > 0 and board[x][y - -1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - -1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res.append((x, y - 1))",
      "mutated_line": "res.append((x, y - 2))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 2))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res.append((x, y - 1))",
      "mutated_line": "res.append((x, y - 0))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 0))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res.append((x, y - 1))",
      "mutated_line": "res.append((x, y - 0))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 0))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res.append((x, y - 1))",
      "mutated_line": "res.append((x, y - -1))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - -1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 1 and board[x - 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x - 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 1 and board[x * 1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x * 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((x + 1, y))",
      "mutated_line": "res.append((x + 2, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 2, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((x + 1, y))",
      "mutated_line": "res.append((x + 0, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 0, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((x + 1, y))",
      "mutated_line": "res.append((x + 0, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 0, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((x + 1, y))",
      "mutated_line": "res.append((x + -1, y))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + -1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 1 and board[x][y + 2] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 2] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 1 and board[x][y + 0] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 0] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 1 and board[x][y + 0] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 0] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if y < m - 1 and board[x][y + 1] == colour:",
      "mutated_line": "if y < m - 1 and board[x][y + -1] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + -1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res.append((x, y + 1))",
      "mutated_line": "res.append((x, y + 2))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 2))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res.append((x, y + 1))",
      "mutated_line": "res.append((x, y + 0))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 0))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res.append((x, y + 1))",
      "mutated_line": "res.append((x, y + 0))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 0))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res.append((x, y + 1))",
      "mutated_line": "res.append((x, y + -1))",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + -1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 0 and board[x - 2][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 2][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 0 and board[x - 0][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 0][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 0 and board[x - 0][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 0][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x > 0 and board[x - 1][y] == colour:",
      "mutated_line": "if x > 0 and board[x - -1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - -1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 1 and board[x + 2][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 2][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 1 and board[x + 0][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 0][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 1 and board[x + 0][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + 0][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < n - 1 and board[x + 1][y] == colour:",
      "mutated_line": "if x < n - 1 and board[x + -1][y] == colour:",
      "code": "def has_cycle_in_board(n, m, board):\n\n    def neighbours(vertex, colour):\n        (x, y) = vertex\n        res = []\n        if x > 0 and board[x - 1][y] == colour:\n            res.append((x - 1, y))\n        if y > 0 and board[x][y - 1] == colour:\n            res.append((x, y - 1))\n        if x < n - 1 and board[x + -1][y] == colour:\n            res.append((x + 1, y))\n        if y < m - 1 and board[x][y + 1] == colour:\n            res.append((x, y + 1))\n        return res\n\n    def find_cycle(x, y):\n        colour = board[x][y]\n        visited = set()\n        stack = [((x, y), None)]\n        while stack:\n            (v, parent) = stack.pop()\n            if v in visited:\n                return True\n            visited.add(v)\n            for u in neighbours(v, colour):\n                if u != parent:\n                    stack.append((u, v))\n        return False\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                if find_cycle(i, j):\n                    return True\n                visited.add((i, j))\n    return False"
    }
  ]
}