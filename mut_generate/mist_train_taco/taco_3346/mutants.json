{
  "task_id": "taco_3346",
  "entry_point": "minimum_cost_to_connect_graph",
  "mutant_count": 91,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rk = [0] * n",
      "mutated_line": "rk = [0] / n",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] / n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rk = [0] * n",
      "mutated_line": "rk = [0] + n",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] + n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rk = [0] * n",
      "mutated_line": "rk = [0] ** n",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] ** n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 1\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = -1\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 1\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 2",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 2\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 0",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 0\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = 0",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 0\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cnt = 1",
      "mutated_line": "cnt = -1",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = -1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(2, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(0, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(0, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(-1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while fa[x] != x:",
      "mutated_line": "while fa[x] == x:",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] == x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if u == v:",
      "mutated_line": "if u != v:",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u != v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if rk[u] < rk[v]:",
      "mutated_line": "if rk[u] <= rk[v]:",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] <= rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if rk[u] < rk[v]:",
      "mutated_line": "if rk[u] >= rk[v]:",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] >= rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if rk[u] < rk[v]:",
      "mutated_line": "if rk[u] != rk[v]:",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] != rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if rk[u] == rk[v]:",
      "mutated_line": "if rk[u] != rk[v]:",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] != rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "rk[u] += 1",
      "mutated_line": "rk[u] -= 1",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] -= 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return False\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if cnt == n:",
      "mutated_line": "if cnt != n:",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt != n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "ans += ee[2]",
      "mutated_line": "ans -= ee[2]",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans -= ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rk = [0] * n",
      "mutated_line": "rk = [1] * n",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [1] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rk = [0] * n",
      "mutated_line": "rk = [-1] * n",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [-1] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rk = [0] * n",
      "mutated_line": "rk = [1] * n",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [1] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return True\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rk[u] += 1",
      "mutated_line": "rk[u] += 2",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 2\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rk[u] += 1",
      "mutated_line": "rk[u] += 0",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 0\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rk[u] += 1",
      "mutated_line": "rk[u] += 0",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 0\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "rk[u] += 1",
      "mutated_line": "rk[u] += -1",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += -1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u + 1, v - 1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u + 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u * 1, v - 1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u * 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 1, v + 1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v + 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 1, v * 1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v * 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[0][0] - a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] - a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[0][0] * a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] * a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if unite(ee[0], ee[1]):",
      "mutated_line": "if unite(ee[1], ee[1]):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[1], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if unite(ee[0], ee[1]):",
      "mutated_line": "if unite(ee[-1], ee[1]):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[-1], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if unite(ee[0], ee[1]):",
      "mutated_line": "if unite(ee[1], ee[1]):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[1], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if unite(ee[0], ee[1]):",
      "mutated_line": "if unite(ee[0], ee[2]):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[2]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if unite(ee[0], ee[1]):",
      "mutated_line": "if unite(ee[0], ee[0]):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[0]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if unite(ee[0], ee[1]):",
      "mutated_line": "if unite(ee[0], ee[0]):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[0]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if unite(ee[0], ee[1]):",
      "mutated_line": "if unite(ee[0], ee[-1]):",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[-1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += ee[2]",
      "mutated_line": "ans += ee[3]",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[3]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += ee[2]",
      "mutated_line": "ans += ee[1]",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[1]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += ee[2]",
      "mutated_line": "ans += ee[0]",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[0]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += ee[2]",
      "mutated_line": "ans += ee[1]",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[1]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += ee[2]",
      "mutated_line": "ans += ee[-2]",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[-2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 2, v - 1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 2, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 0, v - 1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 0, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 0, v - 1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 0, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - -1, v - 1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - -1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 1, v - 2, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 2, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 1, v - 0, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 0, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 1, v - 0, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 0, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e.append((u - 1, v - 1, w))",
      "mutated_line": "e.append((u - 1, v - -1, w))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - -1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a = sorted(zip(a, range(n)), key=lambda x: x[0])",
      "mutated_line": "a = sorted(zip(a, range(n)), key=lambda x: x[1])",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[1])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a = sorted(zip(a, range(n)), key=lambda x: x[0])",
      "mutated_line": "a = sorted(zip(a, range(n)), key=lambda x: x[-1])",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[-1])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a = sorted(zip(a, range(n)), key=lambda x: x[0])",
      "mutated_line": "a = sorted(zip(a, range(n)), key=lambda x: x[1])",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[1])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][2], a[i][1], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][2], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][0], a[i][1], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][0], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][0], a[i][1], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][0], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][-1], a[i][1], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][-1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][2], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][2], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][0], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][0], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][0], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][0], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][-1], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][-1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "e.sort(key=lambda x: x[2])",
      "mutated_line": "e.sort(key=lambda x: x[3])",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[3])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "e.sort(key=lambda x: x[2])",
      "mutated_line": "e.sort(key=lambda x: x[1])",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[1])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "e.sort(key=lambda x: x[2])",
      "mutated_line": "e.sort(key=lambda x: x[0])",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[0])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "e.sort(key=lambda x: x[2])",
      "mutated_line": "e.sort(key=lambda x: x[1])",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[1])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "e.sort(key=lambda x: x[2])",
      "mutated_line": "e.sort(key=lambda x: x[-2])",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[-2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[1][1], a[i][1], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[1][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[-1][1], a[i][1], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[-1][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[1][1], a[i][1], a[0][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[1][1], a[i][1], a[0][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[0][1] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][1] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[0][-1] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][-1] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[0][1] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][1] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][1]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][1]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][-1]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][-1]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][1]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[0][0] + a[i][1]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[1][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[1][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[-1][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[-1][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))",
      "mutated_line": "e.append((a[0][1], a[i][1], a[1][0] + a[i][0]))",
      "code": "def minimum_cost_to_connect_graph(n, m, a, offers):\n    e = []\n    for (u, v, w) in offers:\n        e.append((u - 1, v - 1, w))\n    a = sorted(zip(a, range(n)), key=lambda x: x[0])\n    for i in range(1, n):\n        e.append((a[0][1], a[i][1], a[1][0] + a[i][0]))\n    fa = list(range(n))\n    rk = [0] * n\n\n    def find(x):\n        while fa[x] != x:\n            fa[x] = fa[fa[x]]\n            x = fa[x]\n        return x\n\n    def unite(u, v):\n        (u, v) = (find(u), find(v))\n        if u == v:\n            return False\n        if rk[u] < rk[v]:\n            (u, v) = (v, u)\n        fa[v] = u\n        if rk[u] == rk[v]:\n            rk[u] += 1\n        return True\n    e.sort(key=lambda x: x[2])\n    ans = 0\n    cnt = 1\n    for ee in e:\n        if cnt == n:\n            break\n        if unite(ee[0], ee[1]):\n            ans += ee[2]\n            cnt += 1\n    return ans"
    }
  ]
}