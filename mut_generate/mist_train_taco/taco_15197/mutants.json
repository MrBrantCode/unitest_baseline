{
  "task_id": "taco_15197",
  "entry_point": "process_commands",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if command[0] == 'W':",
      "mutated_line": "if command[0] != 'W':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] != 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if command[0] == 'W':",
      "mutated_line": "if command[0] == '':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == '':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "idx_mem = 0",
      "mutated_line": "idx_mem = 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 1\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "idx_mem = 0",
      "mutated_line": "idx_mem = -1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = -1\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "idx_mem = 0",
      "mutated_line": "idx_mem = 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 1\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "idx = 0",
      "mutated_line": "idx = 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 1\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "idx = 0",
      "mutated_line": "idx = -1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = -1\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "idx = 0",
      "mutated_line": "idx = 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 1\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while idx_mem < len(mem):",
      "mutated_line": "while idx_mem <= len(mem):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem <= len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while idx_mem < len(mem):",
      "mutated_line": "while idx_mem >= len(mem):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem >= len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while idx_mem < len(mem):",
      "mutated_line": "while idx_mem != len(mem):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem != len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem -= 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem -= 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif command[0] == 'D':",
      "mutated_line": "elif command[0] != 'D':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] != 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if command[0] == 'W':",
      "mutated_line": "if command[1] == 'W':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[1] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if command[0] == 'W':",
      "mutated_line": "if command[-1] == 'W':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[-1] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if command[0] == 'W':",
      "mutated_line": "if command[1] == 'W':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[1] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if idx != l:",
      "mutated_line": "if idx == l:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx == l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem += 2",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 2\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem += 0",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 0\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem += 0",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 0\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem += -1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += -1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif command[0] == 'D':",
      "mutated_line": "elif command[0] == '':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == '':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif command[0] == 'R':",
      "mutated_line": "elif command[0] != 'R':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] != 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "space = l - idx",
      "mutated_line": "space = l + idx",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l + idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "space = l - idx",
      "mutated_line": "space = l * idx",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l * idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert space > 0, (mem, l, idx)",
      "mutated_line": "assert space >= 0, (mem, l, idx)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space >= 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert space > 0, (mem, l, idx)",
      "mutated_line": "assert space <= 0, (mem, l, idx)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space <= 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert space > 0, (mem, l, idx)",
      "mutated_line": "assert space != 0, (mem, l, idx)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space != 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if subS <= space:",
      "mutated_line": "if subS < space:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS < space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if subS <= space:",
      "mutated_line": "if subS > space:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS > space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if subS <= space:",
      "mutated_line": "if subS == space:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS == space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "subS -= space",
      "mutated_line": "subS += space",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS += space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem -= 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem -= 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif command[0] == 'D':",
      "mutated_line": "elif command[1] == 'D':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[1] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif command[0] == 'D':",
      "mutated_line": "elif command[-1] == 'D':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[-1] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif command[0] == 'D':",
      "mutated_line": "elif command[1] == 'D':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[1] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) + 1, -1, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) + 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) * 1, -1, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) * 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, +1, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, +1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, -1, +1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, +1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if mem[idx_mem][2] == Id:",
      "mutated_line": "if mem[idx_mem][2] != Id:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] != Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif command[0] == 'R':",
      "mutated_line": "elif command[0] == '':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == '':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) + 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) + 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) * 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) * 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if idx_mem == -1:",
      "mutated_line": "if idx_mem != -1:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem != -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[2]), int(command[2]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[2]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[0]), int(command[2]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[0]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[0]), int(command[2]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[0]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[-1]), int(command[2]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[-1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[1]), int(command[3]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[3]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[1]), int(command[1]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[1]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[1]), int(command[0]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[0]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[1]), int(command[1]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[1]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "Id, S = int(command[1]), int(command[2])",
      "mutated_line": "(Id, S) = (int(command[1]), int(command[-2]))",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[-2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "assert space > 0, (mem, l, idx)",
      "mutated_line": "assert space > 1, (mem, l, idx)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 1, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "assert space > 0, (mem, l, idx)",
      "mutated_line": "assert space > -1, (mem, l, idx)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > -1, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "assert space > 0, (mem, l, idx)",
      "mutated_line": "assert space > 1, (mem, l, idx)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 1, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "subS = 0",
      "mutated_line": "subS = 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 1\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "subS = 0",
      "mutated_line": "subS = -1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = -1\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "subS = 0",
      "mutated_line": "subS = 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 1\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem += 2",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 2\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem += 0",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 0\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem += 0",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 0\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "idx_mem += 1",
      "mutated_line": "idx_mem += -1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += -1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "mem.append([idx, idx + subS, Id])",
      "mutated_line": "mem.append([idx, idx - subS, Id])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx - subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "mem.append([idx, idx + subS, Id])",
      "mutated_line": "mem.append([idx, idx * subS, Id])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx * subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Id = int(command[1])",
      "mutated_line": "Id = int(command[2])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[2])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Id = int(command[1])",
      "mutated_line": "Id = int(command[0])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[0])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Id = int(command[1])",
      "mutated_line": "Id = int(command[0])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[0])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Id = int(command[1])",
      "mutated_line": "Id = int(command[-1])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[-1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 2, -1, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 2, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 0, -1, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 0, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 0, -1, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 0, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - -1, -1, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - -1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, -2, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -2, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, -0, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -0, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, -0, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -0, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, --1, -1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, --1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, -1, -2):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -2):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, -1, -0):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -0):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, -1, -0):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -0):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for idx_mem in range(len(mem) - 1, -1, -1):",
      "mutated_line": "for idx_mem in range(len(mem) - 1, -1, --1):",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, --1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif command[0] == 'R':",
      "mutated_line": "elif command[1] == 'R':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[1] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif command[0] == 'R':",
      "mutated_line": "elif command[-1] == 'R':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[-1] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif command[0] == 'R':",
      "mutated_line": "elif command[1] == 'R':",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[1] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 2",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 2\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 0",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 0\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 0",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 0\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - -1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - -1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "if idx_mem == -1:",
      "mutated_line": "if idx_mem == +1:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == +1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if P < r:",
      "mutated_line": "if P <= r:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P <= r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if P < r:",
      "mutated_line": "if P >= r:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P >= r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if P < r:",
      "mutated_line": "if P != r:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P != r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mem[idx_mem][2] == Id:",
      "mutated_line": "if mem[idx_mem][3] == Id:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][3] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mem[idx_mem][2] == Id:",
      "mutated_line": "if mem[idx_mem][1] == Id:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][1] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mem[idx_mem][2] == Id:",
      "mutated_line": "if mem[idx_mem][0] == Id:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][0] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mem[idx_mem][2] == Id:",
      "mutated_line": "if mem[idx_mem][1] == Id:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][1] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mem[idx_mem][2] == Id:",
      "mutated_line": "if mem[idx_mem][-2] == Id:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][-2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "P = int(command[1])",
      "mutated_line": "P = int(command[2])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[2])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "P = int(command[1])",
      "mutated_line": "P = int(command[0])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[0])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "P = int(command[1])",
      "mutated_line": "P = int(command[0])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[0])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "P = int(command[1])",
      "mutated_line": "P = int(command[-1])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[-1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if idx_mem == -1:",
      "mutated_line": "if idx_mem == -2:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -2:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if idx_mem == -1:",
      "mutated_line": "if idx_mem == -0:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -0:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if idx_mem == -1:",
      "mutated_line": "if idx_mem == -0:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -0:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if idx_mem == -1:",
      "mutated_line": "if idx_mem == --1:",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == --1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(+1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mem.insert(idx_mem, [idx, idx + subS, Id])",
      "mutated_line": "mem.insert(idx_mem, [idx, idx - subS, Id])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx - subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mem.insert(idx_mem, [idx, idx + subS, Id])",
      "mutated_line": "mem.insert(idx_mem, [idx, idx * subS, Id])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx * subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mem.insert(idx_mem, [idx, idx + space, Id])",
      "mutated_line": "mem.insert(idx_mem, [idx, idx - space, Id])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx - space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mem.insert(idx_mem, [idx, idx + space, Id])",
      "mutated_line": "mem.insert(idx_mem, [idx, idx * space, Id])",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx * space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000001, -1]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000001, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 99999999999999, -1]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 99999999999999, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 0, -1]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 0, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 1, -1]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 1, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, -100000000000000, -1]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, -100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, +1]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, +1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-2)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-0)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-0)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(--1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(+1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -2]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -2]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -0]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -0]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -0]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -0]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1",
      "mutated_line": "idx_mem = bisect_right(mem, [P, 100000000000000, --1]) - 1",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, --1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(-0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "from bisect import bisect_right\n\ndef process_commands(commands):\n    mem = []\n    results = []\n    for command in commands:\n        if command[0] == 'W':\n            (Id, S) = (int(command[1]), int(command[2]))\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                (l, r, _) = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx + subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx + space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx + subS, Id])\n        elif command[0] == 'D':\n            Id = int(command[1])\n            for idx_mem in range(len(mem) - 1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        elif command[0] == 'R':\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            if idx_mem == -1:\n                results.append(-1)\n            else:\n                (l, r, id_) = mem[idx_mem]\n                if P < r:\n                    results.append(id_)\n                else:\n                    results.append(--1)\n    return results"
    }
  ]
}