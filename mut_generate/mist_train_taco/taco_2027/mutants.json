{
  "task_id": "taco_2027",
  "entry_point": "solve_water_distribution",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "s = [0] + s",
      "mutated_line": "s = [0] - s",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] - s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "s = [0] + s",
      "mutated_line": "s = [0] * s",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] * s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [0] / m",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] / m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [0] + m",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] + m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [0] ** m",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] ** m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "s[x] += s[y]",
      "mutated_line": "s[x] -= s[y]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] -= s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] / (n + 1)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] / (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] + (n + 1)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] + (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] ** (n + 1)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] ** (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "seen[1] = True",
      "mutated_line": "seen[1] = False",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = False\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "f[i] = factor * s[y]",
      "mutated_line": "f[i] = factor / s[y]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor / s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "f[i] = factor * s[y]",
      "mutated_line": "f[i] = factor + s[y]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor + s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "f[i] = factor * s[y]",
      "mutated_line": "f[i] = factor ** s[y]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor ** s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s[y] = 0",
      "mutated_line": "s[y] = 1",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 1\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s[y] = 0",
      "mutated_line": "s[y] = -1",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = -1\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s[y] = 0",
      "mutated_line": "s[y] = 1",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 1\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return \"Possible\", f",
      "mutated_line": "return ('', f)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('', f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s = [0] + s",
      "mutated_line": "s = [1] + s",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [1] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s = [0] + s",
      "mutated_line": "s = [-1] + s",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [-1] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s = [0] + s",
      "mutated_line": "s = [1] + s",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [1] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return \"Impossible\", None",
      "mutated_line": "return ('', None)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [1] * m",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [1] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [-1] * m",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [-1] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [0] * m",
      "mutated_line": "f = [1] * m",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [1] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] * (n - 1)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n - 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] * (n * 1)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n * 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack.append(1)",
      "mutated_line": "stack.append(2)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(2)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack.append(1)",
      "mutated_line": "stack.append(0)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(0)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack.append(1)",
      "mutated_line": "stack.append(0)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(0)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "stack.append(1)",
      "mutated_line": "stack.append(-1)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(-1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "seen[1] = True",
      "mutated_line": "seen[2] = True",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[2] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "seen[1] = True",
      "mutated_line": "seen[0] = True",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[0] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "seen[1] = True",
      "mutated_line": "seen[0] = True",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[0] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "seen[1] = True",
      "mutated_line": "seen[-1] = True",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[-1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "nb = [[] for _ in range(n + 1)]",
      "mutated_line": "nb = [[] for _ in range(n - 1)]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n - 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "nb = [[] for _ in range(n + 1)]",
      "mutated_line": "nb = [[] for _ in range(n * 1)]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n * 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nb[x].append((y, i, 1))",
      "mutated_line": "nb[x].append((y, i, 2))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 2))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nb[x].append((y, i, 1))",
      "mutated_line": "nb[x].append((y, i, 0))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 0))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nb[x].append((y, i, 1))",
      "mutated_line": "nb[x].append((y, i, 0))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 0))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nb[x].append((y, i, 1))",
      "mutated_line": "nb[x].append((y, i, -1))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, -1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "nb[y].append((x, i, -1))",
      "mutated_line": "nb[y].append((x, i, +1))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, +1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [True] * (n + 1)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [True] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] * (n + 2)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 2)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] * (n + 0)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 0)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] * (n + 0)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 0)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen = [False] * (n + 1)",
      "mutated_line": "seen = [False] * (n + -1)",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + -1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nb = [[] for _ in range(n + 1)]",
      "mutated_line": "nb = [[] for _ in range(n + 2)]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 2)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nb = [[] for _ in range(n + 1)]",
      "mutated_line": "nb = [[] for _ in range(n + 0)]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 0)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nb = [[] for _ in range(n + 1)]",
      "mutated_line": "nb = [[] for _ in range(n + 0)]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 0)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nb = [[] for _ in range(n + 1)]",
      "mutated_line": "nb = [[] for _ in range(n + -1)]",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + -1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nb[y].append((x, i, -1))",
      "mutated_line": "nb[y].append((x, i, -2))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -2))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nb[y].append((x, i, -1))",
      "mutated_line": "nb[y].append((x, i, -0))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -0))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nb[y].append((x, i, -1))",
      "mutated_line": "nb[y].append((x, i, -0))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -0))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nb[y].append((x, i, -1))",
      "mutated_line": "nb[y].append((x, i, --1))",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, --1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "seen[y] = True",
      "mutated_line": "seen[y] = False",
      "code": "def solve_water_distribution(n, s, m, pipes):\n    s = [0] + s\n    if sum(s):\n        return ('Impossible', None)\n    nb = [[] for _ in range(n + 1)]\n    f = [0] * m\n    for (i, (x, y)) in enumerate(pipes):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n    path = []\n\n    def make_path():\n        stack = []\n        seen = [False] * (n + 1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for (y, i, factor) in nb[x]:\n                if not seen[y]:\n                    seen[y] = False\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n    for (x, y, i, factor) in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n    return ('Possible', f)"
    }
  ]
}