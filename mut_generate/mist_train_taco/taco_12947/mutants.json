{
  "task_id": "taco_12947",
  "entry_point": "xorshift128plus",
  "mutant_count": 89,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 | 2 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 | 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 17 | y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 | y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 64 + 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 + 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 64 * 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 * 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s[0] = y",
      "mutated_line": "s[1] = y",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[1] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s[0] = y",
      "mutated_line": "s[-1] = y",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[-1] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s[0] = y",
      "mutated_line": "s[1] = y",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[1] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[2] = x ^ y ^ x >> 17 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[2] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[0] = x ^ y ^ x >> 17 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[0] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[0] = x ^ y ^ x >> 17 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[0] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[-1] = x ^ y ^ x >> 17 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[-1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = (x ^ y | x >> 17) ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = (x ^ y | x >> 17) ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "matrix = [[0] * n for _ in range(n)]",
      "mutated_line": "matrix = [[0] / n for _ in range(n)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] / n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "matrix = [[0] * n for _ in range(n)]",
      "mutated_line": "matrix = [[0] + n for _ in range(n)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] + n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "matrix = [[0] * n for _ in range(n)]",
      "mutated_line": "matrix = [[0] ** n for _ in range(n)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] ** n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 24 & 2 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 24 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 22 & 2 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 22 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 0 & 2 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 0 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 1 & 2 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 1 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << -23 & 2 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << -23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 * 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 * 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 + 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 + 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 64 - 2",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 2\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 64 - 0",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 0\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 64 - 0",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 0\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 64 - -1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - -1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = (x | y) ^ x >> 17 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = (x | y) ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 27",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 27\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 25",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 25\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 0",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 0\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 1\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 17 ^ y >> -26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> -26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i - 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i * 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)",
      "mutated_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) * (max_value + 1)",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) * (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)",
      "mutated_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) + (max_value + 1)",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) + (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "N_matrix = [[0] * N for _ in range(N)]",
      "mutated_line": "N_matrix = [[0] / N for _ in range(N)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] / N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "N_matrix = [[0] * N for _ in range(N)]",
      "mutated_line": "N_matrix = [[0] + N for _ in range(N)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] + N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "N_matrix = [[0] * N for _ in range(N)]",
      "mutated_line": "N_matrix = [[0] ** N for _ in range(N)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] ** N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(2, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(0, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(0, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(-1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "N_matrix[0][i] = 1",
      "mutated_line": "N_matrix[0][i] = 2",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 2\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "N_matrix[0][i] = 1",
      "mutated_line": "N_matrix[0][i] = 0",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 0\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "N_matrix[0][i] = 1",
      "mutated_line": "N_matrix[0][i] = 0",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 0\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "N_matrix[0][i] = 1",
      "mutated_line": "N_matrix[0][i] = -1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = -1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "N_matrix[i][0] = 1",
      "mutated_line": "N_matrix[i][0] = 2",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 2\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "N_matrix[i][0] = 1",
      "mutated_line": "N_matrix[i][0] = 0",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 0\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "N_matrix[i][0] = 1",
      "mutated_line": "N_matrix[i][0] = 0",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 0\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "N_matrix[i][0] = 1",
      "mutated_line": "N_matrix[i][0] = -1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = -1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 3 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 3 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 1 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 1 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 0 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 0 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 1 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 1 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & -2 ** 64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & -2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 65 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 65 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 63 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 63 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 0 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 0 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** 1 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 1 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x ^= x << 23 & 2 ** 64 - 1",
      "mutated_line": "x ^= x << 23 & 2 ** -64 - 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** -64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 18 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 18 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 16 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 16 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 0 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 0 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> 1 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 1 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s[1] = x ^ y ^ x >> 17 ^ y >> 26",
      "mutated_line": "s[1] = x ^ y ^ x >> -17 ^ y >> 26",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> -17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "matrix = [[0] * n for _ in range(n)]",
      "mutated_line": "matrix = [[1] * n for _ in range(n)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[1] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "matrix = [[0] * n for _ in range(n)]",
      "mutated_line": "matrix = [[-1] * n for _ in range(n)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "matrix = [[0] * n for _ in range(n)]",
      "mutated_line": "matrix = [[1] * n for _ in range(n)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[1] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 2, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 0, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 0, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + -1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)",
      "mutated_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value - 1)",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value - 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)",
      "mutated_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value * 1)",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value * 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "N_matrix[i][0] = 1",
      "mutated_line": "N_matrix[i][1] = 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][1] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "N_matrix[i][0] = 1",
      "mutated_line": "N_matrix[i][-1] = 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][-1] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "N_matrix[i][0] = 1",
      "mutated_line": "N_matrix[i][1] = 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][1] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)",
      "mutated_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 2)",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 2)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)",
      "mutated_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 0)",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 0)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)",
      "mutated_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 0)",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 0)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)",
      "mutated_line": "matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + -1)",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + -1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "N_matrix = [[0] * N for _ in range(N)]",
      "mutated_line": "N_matrix = [[1] * N for _ in range(N)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[1] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "N_matrix = [[0] * N for _ in range(N)]",
      "mutated_line": "N_matrix = [[-1] * N for _ in range(N)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[-1] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "N_matrix = [[0] * N for _ in range(N)]",
      "mutated_line": "N_matrix = [[1] * N for _ in range(N)]",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[1] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "N_matrix[0][i] = 1",
      "mutated_line": "N_matrix[1][i] = 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[1][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "N_matrix[0][i] = 1",
      "mutated_line": "N_matrix[-1][i] = 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[-1][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "N_matrix[0][i] = 1",
      "mutated_line": "N_matrix[1][i] = 1",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[1][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append(''.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "result.append(''.join(map(str, N_matrix[i])))",
      "mutated_line": "result.append('MUTATED'.join(map(str, N_matrix[i])))",
      "code": "import math\n\ndef xorshift128plus(s):\n    (x, y) = s\n    x ^= x << 23 & 2 ** 64 - 1\n    s[0] = y\n    s[1] = x ^ y ^ x >> 17 ^ y >> 26\n    return y\n\ndef generate_cost_matrix(n, max_value, seeds):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        s = seeds[i]\n        for j in range(i + 1, n):\n            matrix[i][j] = matrix[j][i] = xorshift128plus(s) % (max_value + 1)\n    return matrix\n\ndef minimize_network_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, Cmax, Hmax, seeds_C, seeds_H) = test_cases[t]\n        C = generate_cost_matrix(N, Cmax, seeds_C)\n        H = generate_cost_matrix(N, Hmax, seeds_H)\n        N_matrix = [[0] * N for _ in range(N)]\n        for i in range(1, N):\n            N_matrix[0][i] = 1\n            N_matrix[i][0] = 1\n        result = []\n        for i in range(N):\n            result.append('MUTATED'.join(map(str, N_matrix[i])))\n        results.append(result)\n    return results"
    }
  ]
}