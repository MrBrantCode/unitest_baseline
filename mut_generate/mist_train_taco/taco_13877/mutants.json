{
  "task_id": "taco_13877",
  "entry_point": "can_arrange_jigsaw_pieces",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 * h - 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h - 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 * h * 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h * 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "state = [0] * n_nodes",
      "mutated_line": "",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] / n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "state = [0] * n_nodes",
      "mutated_line": "",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] + n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "state = [0] * n_nodes",
      "mutated_line": "",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] ** n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return 'YES'",
      "mutated_line": "return ''",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 / h + 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 / h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 + h + 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 + h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 ** h + 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 ** h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 * h + 2",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 2\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 * h + 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 0\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 * h + 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 0\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 2 * h + -1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + -1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if c[i] == 0:",
      "mutated_line": "if c[i] != 0:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] != 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if d[i] == 0:",
      "mutated_line": "if d[i] != 0:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] != 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "out_degree[i] += 1",
      "mutated_line": "out_degree[i] -= 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] -= 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] -= 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] -= 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < h:",
      "mutated_line": "if i <= h:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i <= h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < h:",
      "mutated_line": "if i >= h:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i >= h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < h:",
      "mutated_line": "if i != h:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i != h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if h < i:",
      "mutated_line": "if h <= i:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h <= i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if h < i:",
      "mutated_line": "if h >= i:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h >= i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if h < i:",
      "mutated_line": "if h != i:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h != i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = False",
      "mutated_line": "res = True",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = True\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "state[root] = 1",
      "mutated_line": "state[root] = 2",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 2\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "state[root] = 1",
      "mutated_line": "state[root] = 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 0\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "state[root] = 1",
      "mutated_line": "state[root] = 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 0\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "state[root] = 1",
      "mutated_line": "state[root] = -1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = -1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "state[root] = 2",
      "mutated_line": "state[root] = 3",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 3\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "state[root] = 2",
      "mutated_line": "state[root] = 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 1\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "state[root] = 2",
      "mutated_line": "state[root] = 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 0\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "state[root] = 2",
      "mutated_line": "state[root] = 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 1\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "state[root] = 2",
      "mutated_line": "state[root] = -2",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = -2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if (in_degree[root], out_degree[root]) == (0, 0):",
      "mutated_line": "if (in_degree[root], out_degree[root]) != (0, 0):",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) != (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "res |= in_degree[root] != out_degree[root]",
      "mutated_line": "res |= in_degree[root] == out_degree[root]",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] == out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] != 0:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] != 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 3 * h + 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 3 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 1 * h + 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 1 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 0 * h + 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 0 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = 1 * h + 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 1 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n_nodes = 2 * h + 1",
      "mutated_line": "n_nodes = -2 * h + 1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = -2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if c[i] == 0:",
      "mutated_line": "if c[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 1:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if c[i] == 0:",
      "mutated_line": "if c[i] == -1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == -1:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if c[i] == 0:",
      "mutated_line": "if c[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 1:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "l = -c[i]",
      "mutated_line": "l = +c[i]",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = +c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if d[i] == 0:",
      "mutated_line": "if d[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 1:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if d[i] == 0:",
      "mutated_line": "if d[i] == -1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == -1:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if d[i] == 0:",
      "mutated_line": "if d[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 1:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "r = -b[i]",
      "mutated_line": "r = +b[i]",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = +b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "adj[l + h].append(r + h)",
      "mutated_line": "adj[l + h].append(r - h)",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r - h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "adj[l + h].append(r + h)",
      "mutated_line": "adj[l + h].append(r * h)",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r * h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r_adj[r + h].append(l + h)",
      "mutated_line": "r_adj[r + h].append(l - h)",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l - h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r_adj[r + h].append(l + h)",
      "mutated_line": "r_adj[r + h].append(l * h)",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l * h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "out_degree[i] += 1",
      "mutated_line": "out_degree[i] += 2",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 2\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "out_degree[i] += 1",
      "mutated_line": "out_degree[i] += 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 0\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "out_degree[i] += 1",
      "mutated_line": "out_degree[i] += 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 0\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "out_degree[i] += 1",
      "mutated_line": "out_degree[i] += -1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += -1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] += 2",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 2\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] += 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 0\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] += 0",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 0\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] += -1",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += -1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "state = [0] * n_nodes",
      "mutated_line": "",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [1] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "state = [0] * n_nodes",
      "mutated_line": "",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [-1] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "state = [0] * n_nodes",
      "mutated_line": "",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [1] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] != 0:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] != 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] != 0:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] != 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return False\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 1:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == -1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == -1:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 1:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not out_degree[i] <= in_degree[i]:",
      "mutated_line": "if not out_degree[i] < in_degree[i]:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] < in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not out_degree[i] <= in_degree[i]:",
      "mutated_line": "if not out_degree[i] > in_degree[i]:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] > in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not out_degree[i] <= in_degree[i]:",
      "mutated_line": "if not out_degree[i] == in_degree[i]:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] == in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return ''\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if not in_degree[i] <= out_degree[i]:",
      "mutated_line": "if not in_degree[i] < out_degree[i]:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] < out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if not in_degree[i] <= out_degree[i]:",
      "mutated_line": "if not in_degree[i] > out_degree[i]:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] > out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if not in_degree[i] <= out_degree[i]:",
      "mutated_line": "if not in_degree[i] == out_degree[i]:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] == out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return ''\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 1:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == -1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == -1:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 1:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 1:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == -1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == -1:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if state[i] == 0:",
      "mutated_line": "if state[i] == 1:",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 1:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if (in_degree[root], out_degree[root]) == (0, 0):",
      "mutated_line": "if (in_degree[root], out_degree[root]) == (1, 0):",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (1, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if (in_degree[root], out_degree[root]) == (0, 0):",
      "mutated_line": "if (in_degree[root], out_degree[root]) == (-1, 0):",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (-1, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if (in_degree[root], out_degree[root]) == (0, 0):",
      "mutated_line": "if (in_degree[root], out_degree[root]) == (1, 0):",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (1, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if (in_degree[root], out_degree[root]) == (0, 0):",
      "mutated_line": "if (in_degree[root], out_degree[root]) == (0, 1):",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 1):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if (in_degree[root], out_degree[root]) == (0, 0):",
      "mutated_line": "if (in_degree[root], out_degree[root]) == (0, -1):",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, -1):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if (in_degree[root], out_degree[root]) == (0, 0):",
      "mutated_line": "if (in_degree[root], out_degree[root]) == (0, 1):",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 1):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return ''\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "adj[l + h].append(r + h)",
      "mutated_line": "adj[l - h].append(r + h)",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l - h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "adj[l + h].append(r + h)",
      "mutated_line": "adj[l * h].append(r + h)",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l * h].append(r + h)\n        r_adj[r + h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r_adj[r + h].append(l + h)",
      "mutated_line": "r_adj[r - h].append(l + h)",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r - h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r_adj[r + h].append(l + h)",
      "mutated_line": "r_adj[r * h].append(l + h)",
      "code": "def can_arrange_jigsaw_pieces(n, h, a, b, c, d):\n    n_nodes = 2 * h + 1\n    n_edges = n\n    adj = [[] for _ in range(n_nodes)]\n    r_adj = [[] for _ in range(n_nodes)]\n    for i in range(n_edges):\n        if c[i] == 0:\n            l = a[i]\n        else:\n            l = -c[i]\n        if d[i] == 0:\n            r = -b[i]\n        else:\n            r = d[i]\n        adj[l + h].append(r + h)\n        r_adj[r * h].append(l + h)\n    in_degree = Counter()\n    out_degree = Counter()\n    for i in range(n_nodes):\n        for j in adj[i]:\n            out_degree[i] += 1\n            in_degree[j] += 1\n    for i in range(n_nodes):\n        if i < h:\n            if not out_degree[i] <= in_degree[i]:\n                return 'NO'\n        if h < i:\n            if not in_degree[i] <= out_degree[i]:\n                return 'NO'\n    state = [0] * n_nodes\n\n    def dfs(root):\n        res = False\n        state[root] = 1\n        for i in adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        for i in r_adj[root]:\n            if state[i] == 0:\n                res |= dfs(i)\n        state[root] = 2\n        if (in_degree[root], out_degree[root]) == (0, 0):\n            return True\n        res |= in_degree[root] != out_degree[root]\n        return res\n    for i in range(n_nodes):\n        if state[i] == 0:\n            if not dfs(i):\n                return 'NO'\n    return 'YES'"
    }
  ]
}