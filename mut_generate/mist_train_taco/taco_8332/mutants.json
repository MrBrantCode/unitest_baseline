{
  "task_id": "taco_8332",
  "entry_point": "min_changes_to_breakfasts",
  "mutant_count": 84,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = min(costs) + n",
      "mutated_line": "res = min(costs) - n",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) - n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = min(costs) + n",
      "mutated_line": "res = min(costs) * n",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) * n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if res > n:",
      "mutated_line": "if res >= n:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res >= n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if res > n:",
      "mutated_line": "if res <= n:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res <= n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if res > n:",
      "mutated_line": "if res != n:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res != n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n - 1, 0]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n - 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n * 1, 0]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n * 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n + 1, 1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 1]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n + 1, -1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, -1]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n + 1, 1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 1]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "qual = [0]",
      "mutated_line": "qual = [1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [1]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "qual = [0]",
      "mutated_line": "qual = [-1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [-1]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "qual = [0]",
      "mutated_line": "qual = [1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [1]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if pl > 0:",
      "mutated_line": "if pl >= 0:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl >= 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if pl > 0:",
      "mutated_line": "if pl <= 0:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl <= 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if pl > 0:",
      "mutated_line": "if pl != 0:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl != 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if pa != 0:",
      "mutated_line": "if pa == 0:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa == 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if pr < len(qual):",
      "mutated_line": "if pr <= len(qual):",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr <= len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if pr < len(qual):",
      "mutated_line": "if pr >= len(qual):",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr >= len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if pr < len(qual):",
      "mutated_line": "if pr != len(qual):",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr != len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return +1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n + i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n + i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n * i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n * i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l * n + i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n + i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l * n * i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n * i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l * n - i, r * n + i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n + i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l * n - i, r * n * i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n * i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n + 2, 0]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 2, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n + 0, 0]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 0, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n + 0, 0]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 0, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "costs = [n + 1, 0]",
      "mutated_line": "costs = [n + -1, 0]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + -1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if pl > 0:",
      "mutated_line": "if pl > 1:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 1:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if pl > 0:",
      "mutated_line": "if pl > -1:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > -1:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if pl > 0:",
      "mutated_line": "if pl > 1:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 1:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "qual = [l] + qual[pl:]",
      "mutated_line": "qual = [l] - qual[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] - qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "qual = [l] + qual[pl:]",
      "mutated_line": "qual = [l] * qual[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] * qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "costs = [n + 1] + costs[pl:]",
      "mutated_line": "costs = [n + 1] - costs[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] - costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "costs = [n + 1] + costs[pl:]",
      "mutated_line": "costs = [n + 1] * costs[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] * costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pa != 0:",
      "mutated_line": "if pa != 1:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 1:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pa != 0:",
      "mutated_line": "if pa != -1:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != -1:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pa != 0:",
      "mutated_line": "if pa != 1:",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 1:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if pa < len(qual):",
      "mutated_line": "if pa <= len(qual):",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa <= len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if pa < len(qual):",
      "mutated_line": "if pa >= len(qual):",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa >= len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if pa < len(qual):",
      "mutated_line": "if pa != len(qual):",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa != len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -2\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -0\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -0\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return --1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "aclr.sort(key=itemgetter(1))",
      "mutated_line": "aclr.sort(key=itemgetter(2))",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(2))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "aclr.sort(key=itemgetter(1))",
      "mutated_line": "aclr.sort(key=itemgetter(0))",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(0))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "aclr.sort(key=itemgetter(1))",
      "mutated_line": "aclr.sort(key=itemgetter(0))",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(0))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "aclr.sort(key=itemgetter(1))",
      "mutated_line": "aclr.sort(key=itemgetter(-1))",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(-1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a / n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a / n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a + n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a + n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a ** n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a ** n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l / n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l / n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l + n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l + n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l ** n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l ** n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l * n - i, r / n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r / n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l * n - i, r + n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r + n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "mutated_line": "alrv = [(a * n - i, l * n - i, r ** n - i) for (i, (a, _, l, r)) in enumerate(aclr)]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r ** n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "costs = [n + 1] + costs[pl:]",
      "mutated_line": "costs = [n - 1] + costs[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n - 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "costs = [n + 1] + costs[pl:]",
      "mutated_line": "costs = [n * 1] + costs[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n * 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-1] + 1)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] + 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-1] * 1)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] * 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "costs = costs[:pr + 1]",
      "mutated_line": "costs = costs[:pr - 1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr - 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "costs = costs[:pr + 1]",
      "mutated_line": "costs = costs[:pr * 1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr * 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs = [n + 1] + costs[pl:]",
      "mutated_line": "costs = [n + 2] + costs[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 2] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs = [n + 1] + costs[pl:]",
      "mutated_line": "costs = [n + 0] + costs[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 0] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs = [n + 1] + costs[pl:]",
      "mutated_line": "costs = [n + 0] + costs[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 0] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "costs = [n + 1] + costs[pl:]",
      "mutated_line": "costs = [n + -1] + costs[pl:]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + -1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-1] - 2)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 2)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-1] - 0)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 0)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-1] - 0)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 0)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-1] - -1)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - -1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "costs = costs[:pr + 1]",
      "mutated_line": "costs = costs[:pr + 2]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 2]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "costs = costs[:pr + 1]",
      "mutated_line": "costs = costs[:pr + 0]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 0]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "costs = costs[:pr + 1]",
      "mutated_line": "costs = costs[:pr + 0]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 0]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "costs = costs[:pr + 1]",
      "mutated_line": "costs = costs[:pr + -1]",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + -1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[+1] - 1)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[+1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-2] - 1)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-2] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-0] - 1)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-0] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[-0] - 1)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[-0] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "costs.append(costs[-1] - 1)",
      "mutated_line": "costs.append(costs[--1] - 1)",
      "code": "from bisect import bisect\nfrom operator import itemgetter\n\ndef min_changes_to_breakfasts(n, aclr):\n    aclr.sort()\n    aclr.sort(key=itemgetter(1))\n    alrv = [(a * n - i, l * n - i, r * n - i) for (i, (a, _, l, r)) in enumerate(aclr)]\n    costs = [n + 1, 0]\n    qual = [0]\n    for (a, l, r) in alrv:\n        pl = bisect(qual, l)\n        if pl > 0:\n            qual = [l] + qual[pl:]\n            costs = [n + 1] + costs[pl:]\n        pa = bisect(qual, a)\n        if pa != 0:\n            if pa < len(qual):\n                qual[pa] = a\n            else:\n                qual.append(a)\n                costs.append(costs[--1] - 1)\n        pr = bisect(qual, r)\n        if pr < len(qual):\n            qual = qual[:pr]\n            costs = costs[:pr + 1]\n    res = min(costs) + n\n    if res > n:\n        return -1\n    else:\n        return res"
    }
  ]
}