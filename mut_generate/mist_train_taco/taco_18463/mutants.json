{
  "task_id": "taco_18463",
  "entry_point": "calculate_max_satisfaction",
  "mutant_count": 101,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while len(po) != n:",
      "mutated_line": "while len(po) == n:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) == n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ma = 0",
      "mutated_line": "ma = 1",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 1\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ma = 0",
      "mutated_line": "ma = -1",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = -1\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ma = 0",
      "mutated_line": "ma = 1",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 1\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "tree = [[0] * n for _ in range(n)]",
      "mutated_line": "tree = [[0] / n for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] / n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "tree = [[0] * n for _ in range(n)]",
      "mutated_line": "tree = [[0] + n for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] + n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "tree = [[0] * n for _ in range(n)]",
      "mutated_line": "tree = [[0] ** n for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] ** n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "po = [1]",
      "mutated_line": "po = [2]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [2]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "po = [1]",
      "mutated_line": "po = [0]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [0]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "po = [1]",
      "mutated_line": "po = [0]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [0]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "po = [1]",
      "mutated_line": "po = [-1]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [-1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] / (po[-1] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] / (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] + po[-1] * 2 for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] + po[-1] * 2 for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] ** (po[-1] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] ** (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] / 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] / 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] + 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] + 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] ** 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] ** 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] / 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] / 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] + 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] + 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] ** 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] ** 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if bin(i)[2:].count('1') == m:",
      "mutated_line": "if bin(i)[2:].count('1') != m:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') != m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 1][y + 1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y + 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 1][y * 1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y * 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-1] / 2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] / 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-1] + 2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] + 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-1] ** 2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] ** 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-1] / 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] / 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-1] + 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] + 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * po[-1] ** 2 for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * po[-1] ** 2 for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * 3):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 3):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * 1):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 1):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * 0):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 0):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * 1):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 1):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * -2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * -2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i & po[j]:",
      "mutated_line": "if i | po[j]:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i | po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * 3):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 3):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * 1):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 1):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * 0):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 0):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * 1):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 1):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-1] * -2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * -2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "tree = [[0] * n for _ in range(n)]",
      "mutated_line": "tree = [[1] * n for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[1] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "tree = [[0] * n for _ in range(n)]",
      "mutated_line": "tree = [[-1] * n for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[-1] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "tree = [[0] * n for _ in range(n)]",
      "mutated_line": "tree = [[1] * n for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[1] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x + 1][y - 1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x + 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x * 1][y - 1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x * 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 1][y - 2] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 2] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 1][y - 0] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 0] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 1][y - 0] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 0] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 1][y - -1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - -1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-1] * 3)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 3)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-1] * 1)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 1)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-1] * 0)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 0)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-1] * 1)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 1)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-1] * -2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * -2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[1] * (po[-1] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[1] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[-1] * (po[-1] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[-1] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[1] * (po[-1] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[1] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-1] * 3) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 3) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-1] * 1) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 1) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-1] * 0) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 0) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-1] * 1) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 1) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-1] * -2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * -2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[+1] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[+1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[+1] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[+1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bin(i)[2:].count('1') == m:",
      "mutated_line": "if bin(i)[2:].count('') == m:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 2][y - 1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 2][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 0][y - 1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 0][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - 0][y - 1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 0][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree[x - 1][y - 1] = float(z)",
      "mutated_line": "tree[x - -1][y - 1] = float(z)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - -1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[+1] * 2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[+1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[+1] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[+1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-2] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-2] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-0] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-0] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-0] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-0] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[--1] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[--1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-2] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-2] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-0] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-0] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[-0] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-0] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(po[-1] * 2):",
      "mutated_line": "for i in range(po[--1] * 2):",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[--1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-2] * 2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-2] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-0] * 2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-0] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[-0] * 2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-0] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "po.append(po[-1] * 2)",
      "mutated_line": "po.append(po[--1] * 2)",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[--1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-2] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-2] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-0] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-0] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[-0] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-0] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp = [[0] * (po[-1] * 2) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (po[--1] * 2) for _ in range(n)]",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[--1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if not i & po[k]:",
      "mutated_line": "if not i | po[k]:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i | po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "mutated_line": "dp[k][i - po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i - po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "mutated_line": "dp[k][i * po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i * po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "mutated_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] - tree[j][k])",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] - tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "mutated_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], (dp[j][i] + satisfaction[k]) * tree[j][k])",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], (dp[j][i] + satisfaction[k]) * tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bin(i)[2:].count('1') == m:",
      "mutated_line": "if bin(i)[3:].count('1') == m:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[3:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bin(i)[2:].count('1') == m:",
      "mutated_line": "if bin(i)[1:].count('1') == m:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[1:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bin(i)[2:].count('1') == m:",
      "mutated_line": "if bin(i)[0:].count('1') == m:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[0:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bin(i)[2:].count('1') == m:",
      "mutated_line": "if bin(i)[1:].count('1') == m:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[1:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if bin(i)[2:].count('1') == m:",
      "mutated_line": "if bin(i)[-2:].count('1') == m:",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[-2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "mutated_line": "dp[k][i + po[k]] = max(dp[k][i - po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i - po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "mutated_line": "dp[k][i + po[k]] = max(dp[k][i * po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i * po[k]], dp[j][i] + satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "mutated_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] - satisfaction[k] + tree[j][k])",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] - satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] + satisfaction[k] + tree[j][k])",
      "mutated_line": "dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] * satisfaction[k] + tree[j][k])",
      "code": "def calculate_max_satisfaction(n, m, k, satisfaction, rules):\n    tree = [[0] * n for _ in range(n)]\n    for (x, y, z) in rules:\n        tree[x - 1][y - 1] = float(z)\n    po = [1]\n    while len(po) != n:\n        po.append(po[-1] * 2)\n    dp = [[0] * (po[-1] * 2) for _ in range(n)]\n    for i in range(n):\n        dp[i][po[i]] = satisfaction[i]\n    for i in range(po[-1] * 2):\n        for j in range(n):\n            if i & po[j]:\n                for k in range(n):\n                    if not i & po[k]:\n                        dp[k][i + po[k]] = max(dp[k][i + po[k]], dp[j][i] * satisfaction[k] + tree[j][k])\n    ma = 0\n    for i in range(po[-1] * 2):\n        if bin(i)[2:].count('1') == m:\n            for j in range(n):\n                ma = max(ma, dp[j][i])\n    return int(ma)"
    }
  ]
}