{
  "task_id": "taco_3797",
  "entry_point": "can_vlad_guarantee_victory",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] / (n + 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] / (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] + (n + 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] + (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] ** (n + 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] ** (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] / (n + 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] / (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] + (n + 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] + (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] ** (n + 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] ** (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[1] = 0",
      "mutated_line": "visit[1] = 1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 1\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[1] = 0",
      "mutated_line": "visit[1] = -1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = -1\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[1] = 0",
      "mutated_line": "visit[1] = 1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 1\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "answer = 'NO'",
      "mutated_line": "answer = ''",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = ''\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] * (n - 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n - 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] * (n * 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n * 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "check[friend] = 0",
      "mutated_line": "check[friend] = 1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 1\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "check[friend] = 0",
      "mutated_line": "check[friend] = -1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = -1\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "check[friend] = 0",
      "mutated_line": "check[friend] = 1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 1\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] * (n - 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n - 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] * (n * 1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n * 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[1] = 0",
      "mutated_line": "visit[2] = 0",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[2] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[1] = 0",
      "mutated_line": "visit[0] = 0",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[0] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[1] = 0",
      "mutated_line": "visit[0] = 0",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[0] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[1] = 0",
      "mutated_line": "visit[-1] = 0",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[-1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 1 or len(conn[pos]) == 1:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 or len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] * (n + 2)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 2)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] * (n + 0)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 0)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] * (n + 0)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 0)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "check = [n] * (n + 1)",
      "mutated_line": "check = [n] * (n + -1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + -1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if check[nextPos] < n:",
      "mutated_line": "if check[nextPos] <= n:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] <= n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if check[nextPos] < n:",
      "mutated_line": "if check[nextPos] >= n:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] >= n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if check[nextPos] < n:",
      "mutated_line": "if check[nextPos] != n:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] != n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check[nextPos] = check[pos] + 1",
      "mutated_line": "check[nextPos] = check[pos] - 1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] - 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check[nextPos] = check[pos] + 1",
      "mutated_line": "check[nextPos] = check[pos] * 1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] * 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "q = deque([1])",
      "mutated_line": "q = deque([2])",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([2])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "q = deque([1])",
      "mutated_line": "q = deque([0])",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([0])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "q = deque([1])",
      "mutated_line": "q = deque([0])",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([0])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "q = deque([1])",
      "mutated_line": "q = deque([-1])",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([-1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] * (n + 2)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 2)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] * (n + 0)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 0)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] * (n + 0)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 0)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "visit = [n] * (n + 1)",
      "mutated_line": "visit = [n] * (n + -1)",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + -1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos == 1 and len(conn[pos]) == 1:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos == 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 1 and len(conn[pos]) != 1:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) != 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "answer = 'YES'",
      "mutated_line": "answer = ''",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = ''\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if visit[nextPos] < n:",
      "mutated_line": "if visit[nextPos] <= n:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] <= n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if visit[nextPos] < n:",
      "mutated_line": "if visit[nextPos] >= n:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] >= n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if visit[nextPos] < n:",
      "mutated_line": "if visit[nextPos] != n:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] != n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "visit[nextPos] = visit[pos] + 1",
      "mutated_line": "visit[nextPos] = visit[pos] - 1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] - 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "visit[nextPos] = visit[pos] + 1",
      "mutated_line": "visit[nextPos] = visit[pos] * 1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] * 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "conn = [[] for _ in range(n + 1)]",
      "mutated_line": "for (v, u) in corridors:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n - 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "conn = [[] for _ in range(n + 1)]",
      "mutated_line": "for (v, u) in corridors:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n * 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check[nextPos] = check[pos] + 1",
      "mutated_line": "check[nextPos] = check[pos] + 2",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 2\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check[nextPos] = check[pos] + 1",
      "mutated_line": "check[nextPos] = check[pos] + 0",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 0\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check[nextPos] = check[pos] + 1",
      "mutated_line": "check[nextPos] = check[pos] + 0",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 0\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check[nextPos] = check[pos] + 1",
      "mutated_line": "check[nextPos] = check[pos] + -1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + -1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 2 and len(conn[pos]) == 1:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 2 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 0 and len(conn[pos]) == 1:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 0 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 0 and len(conn[pos]) == 1:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 0 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != -1 and len(conn[pos]) == 1:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != -1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 1 and len(conn[pos]) == 2:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 2:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 1 and len(conn[pos]) == 0:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 0:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 1 and len(conn[pos]) == 0:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 0:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if pos != 1 and len(conn[pos]) == 1:",
      "mutated_line": "if pos != 1 and len(conn[pos]) == -1:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == -1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] + 1 > check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 > check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] + 1 < check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 < check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] + 1 == check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 == check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "visit[nextPos] = visit[pos] + 1",
      "mutated_line": "visit[nextPos] = visit[pos] + 2",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "visit[nextPos] = visit[pos] + 1",
      "mutated_line": "visit[nextPos] = visit[pos] + 0",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 0\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "visit[nextPos] = visit[pos] + 1",
      "mutated_line": "visit[nextPos] = visit[pos] + 0",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 0\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "visit[nextPos] = visit[pos] + 1",
      "mutated_line": "visit[nextPos] = visit[pos] + -1",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + -1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "conn = [[] for _ in range(n + 1)]",
      "mutated_line": "for (v, u) in corridors:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 2)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "conn = [[] for _ in range(n + 1)]",
      "mutated_line": "for (v, u) in corridors:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 0)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "conn = [[] for _ in range(n + 1)]",
      "mutated_line": "for (v, u) in corridors:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 0)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "conn = [[] for _ in range(n + 1)]",
      "mutated_line": "for (v, u) in corridors:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + -1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] - 1 >= check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] - 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] * 1 >= check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] * 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] + 2 >= check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 2 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] + 0 >= check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 0 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] + 0 >= check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 0 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif visit[pos] + 1 >= check[nextPos]:",
      "mutated_line": "elif visit[pos] + -1 >= check[nextPos]:",
      "code": "from collections import deque\n\ndef can_vlad_guarantee_victory(n, k, friends_positions, corridors):\n    conn = [[] for _ in range(n + 1)]\n    for (v, u) in corridors:\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n] * (n + 1)\n    q = deque()\n    for friend in friends_positions:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque([1])\n    visit = [n] * (n + 1)\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + -1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    return answer"
    }
  ]
}