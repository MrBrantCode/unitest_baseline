{
  "task_id": "taco_8464",
  "entry_point": "construct_tree_from_pairs",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] / (n + 1)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] / (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] + (n + 1)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] + (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] ** (n + 1)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] ** (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if b < n:",
      "mutated_line": "if b <= n:",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b <= n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if b < n:",
      "mutated_line": "if b >= n:",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b >= n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if b < n:",
      "mutated_line": "if b != n:",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b != n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n + 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n * 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if V[i] <= i:",
      "mutated_line": "if V[i] < i:",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] < i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if V[i] <= i:",
      "mutated_line": "if V[i] > i:",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] > i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if V[i] <= i:",
      "mutated_line": "if V[i] == i:",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] == i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n - 1)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n - 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n * 1)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n * 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n + 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n * 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return \"YES\", edges",
      "mutated_line": "return ('', edges)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return ''\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 2):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 0):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 0):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - -1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return ''\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [True] * (n + 1)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [True] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 2)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 2)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 0)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 0)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 0)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 0)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + -1)",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + -1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 2):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 0):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 0):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - -1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "used[v] = True",
      "mutated_line": "used[v] = False",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = False\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(2, n + 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(2, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(0, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(0, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(-1, n + 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(-1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n - 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n - 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n * 1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n * 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i - 1]) for i in range(n - 1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i - 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i * 1]) for i in range(n - 1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i * 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 1]) for i in range(n + 1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n + 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 1]) for i in range(n * 1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n * 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 2):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 2):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 0):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 0):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 0):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 0):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + -1):",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + -1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "used[j] = True",
      "mutated_line": "used[j] = False",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = False\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 2]) for i in range(n - 1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 2]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 0]) for i in range(n - 1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 0]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 0]) for i in range(n - 1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 0]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + -1]) for i in range(n - 1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + -1]) for i in range(n - 1)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 2)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 2)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 0)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 0)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 0)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - 0)]\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - 1)]",
      "mutated_line": "edges = [(tree[i], tree[i + 1]) for i in range(n - -1)]",
      "code": "def construct_tree_from_pairs(n, pairs):\n    V = []\n    for (a, b) in pairs:\n        V.append(a)\n        if b < n:\n            return 'NO'\n    V.sort()\n    for i in range(n - 1):\n        if V[i] <= i:\n            return 'NO'\n    used = [False] * (n + 1)\n    tree = []\n    for i in range(n - 1):\n        v = V[i]\n        if not used[v]:\n            tree.append(v)\n            used[v] = True\n        else:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    tree.append(j)\n                    used[j] = True\n                    break\n    tree.append(n)\n    edges = [(tree[i], tree[i + 1]) for i in range(n - -1)]\n    return ('YES', edges)"
    }
  ]
}