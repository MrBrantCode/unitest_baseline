{
  "task_id": "taco_11048",
  "entry_point": "can_ninja_escape",
  "mutant_count": 290,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if left_wall[i] == '-':",
      "mutated_line": "if left_wall[i] != '-':",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] != '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if right_wall[i] == '-':",
      "mutated_line": "if right_wall[i] != '-':",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] != '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('VISITED', 2, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 2, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('VISITED', 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 0, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('VISITED', 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 0, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('VISITED', -1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', -1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('VISITED', 1, 1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 1, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('VISITED', 1, -1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, -1, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('VISITED', 1, 1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 1, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 1] = ('VISITED', 1, 0, True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, True)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][1] < g[c][2]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] < g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][1] > g[c][2]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] > g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][1] == g[c][2]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] == g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g or g[up][0] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g or g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g or g[down][0] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g or g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g or g[jump][0] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g or g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return True\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 'YES' if graphHasEscape(g) else 'NO'",
      "mutated_line": "return '' if graphHasEscape(g) else 'NO'",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return '' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 'YES' if graphHasEscape(g) else 'NO'",
      "mutated_line": "return 'YES' if graphHasEscape(g) else ''",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if left_wall[i] == '-':",
      "mutated_line": "if left_wall[i] == '':",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if right_wall[i] == '-':",
      "mutated_line": "if right_wall[i] == '':",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[2, 1] = ('VISITED', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[2, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[0, 1] = ('VISITED', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[0, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[0, 1] = ('VISITED', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[0, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[-1, 1] = ('VISITED', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[-1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 2] = ('VISITED', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 2] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 0] = ('VISITED', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 0] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, 0] = ('VISITED', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 0] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[1, 1] = ('VISITED', 1, 0, False)",
      "mutated_line": "g[1, -1] = ('VISITED', 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, -1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[1] - 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] - 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[1] * 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] * 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[1] + 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] + 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[1] * 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] * 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] / -1, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] / -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] + -1, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] + -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] ** (-1), c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] ** (-1), c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -1, c[1] - k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] - k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -1, c[1] * k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] * k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up not in g and g[up][0] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up not in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][0] != -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] != -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down not in g and g[down][0] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down not in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][0] != -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] != -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump not in g and g[jump][0] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump not in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][0] != -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] != -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' or (result[1] + 1 > n or result[1] + k > n) or (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' or (result[1] + 1 > n or result[1] + k > n) or (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (+1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (+1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-1, 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 1, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-1, -1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, -1, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-1, 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 1, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-1, 0, 1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 1, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-1, 0, -1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, -1, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-1, 0, 1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 1, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-1, 0, 0, True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, True)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (+1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (+1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-1, 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 1, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-1, -1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, -1, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-1, 1, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 1, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-1, 0, 1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 1, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-1, 0, -1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, -1, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-1, 0, 1, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 1, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-1, 0, 0, True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, True)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([(1, 1)])",
      "mutated_line": "q = deque([(2, 1)])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(2, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([(1, 1)])",
      "mutated_line": "q = deque([(0, 1)])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(0, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([(1, 1)])",
      "mutated_line": "q = deque([(0, 1)])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(0, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([(1, 1)])",
      "mutated_line": "q = deque([(-1, 1)])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(-1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([(1, 1)])",
      "mutated_line": "q = deque([(1, 2)])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 2)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([(1, 1)])",
      "mutated_line": "q = deque([(1, 0)])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 0)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([(1, 1)])",
      "mutated_line": "q = deque([(1, 0)])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 0)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([(1, 1)])",
      "mutated_line": "q = deque([(1, -1)])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, -1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[1], c[1] + 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[1], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[-1], c[1] + 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[-1], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[1], c[1] + 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[1], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[1] + 2)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 2)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[1] + 0)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 0)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[1] + 0)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 0)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[1] + -1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + -1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[1], c[1] - 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[1], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[-1], c[1] - 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[-1], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[1], c[1] - 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[1], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[1] - 2)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 2)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[1] - 0)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 0)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[1] - 0)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 0)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[1] - -1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - -1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * +1, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * +1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][2] <= g[c][2]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][2] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][0] <= g[c][2]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][0] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][0] <= g[c][2]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][0] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][-1] <= g[c][2]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][-1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][1] <= g[c][3]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][3]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][1] <= g[c][1]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][1]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][1] <= g[c][0]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][0]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][1] <= g[c][1]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][1]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if g[c][1] <= g[c][2]:",
      "mutated_line": "if g[c][1] <= g[c][-2]:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][-2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][1], g[c][2], False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], False)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][0] == +1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == +1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] * 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] * 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] - 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] - 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] * 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] * 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][0] == +1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == +1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] * 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] * 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] - 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] - 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] * 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] * 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][0] == +1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == +1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] - k, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] - k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] * k, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] * k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] - 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] - 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] * 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] * 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] != 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] != 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n and result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n and result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return False\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[2, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[2, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[0, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[0, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[0, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[0, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i - 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i - 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i * 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i * 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-2, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-2, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-0, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-0, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (-0, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-0, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 1] = (--1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (--1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[+1, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[+1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i - 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i - 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i * 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i * 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-2, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-2, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-0, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-0, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (-0, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-0, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 1] = (--1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (--1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[2] + 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[2] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[0] + 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[0] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[0] + 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[0] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "up = (c[0], c[1] + 1)",
      "mutated_line": "up = (c[0], c[-1] + 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[-1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[2] - 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[2] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[0] - 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[0] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[0] - 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[0] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "down = (c[0], c[1] - 1)",
      "mutated_line": "down = (c[0], c[-1] - 1)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[-1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[1] * -1, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[1] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[-1] * -1, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[-1] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[1] * -1, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[1] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -2, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -2, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -0, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -0, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -0, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -0, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * --1, c[1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * --1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -1, c[2] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[2] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -1, c[0] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[0] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -1, c[0] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[0] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "jump = (c[0] * -1, c[1] + k)",
      "mutated_line": "jump = (c[0] * -1, c[-1] + k)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[-1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][1], g[c][1], g[c][2], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][1], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][-1], g[c][1], g[c][2], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][-1], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][1], g[c][1], g[c][2], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][1], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][2], g[c][2], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][2], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][0], g[c][2], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][0], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][0], g[c][2], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][0], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][-1], g[c][2], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][-1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][1], g[c][3], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][3], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][1], g[c][1], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][1], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][1], g[c][0], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][0], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][1], g[c][1], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][1], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g[c] = (g[c][0], g[c][1], g[c][2], True)",
      "mutated_line": "g[c] = (g[c][0], g[c][1], g[c][-2], True)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][-2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][1] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][-1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][-1] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][1] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][0] == -2:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -2:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][0] == -0:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -0:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][0] == -0:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -0:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if up in g and g[up][0] == -1:",
      "mutated_line": "if up in g and g[up][0] == --1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == --1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 2, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 2, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 0, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 0, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 0, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 0, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + -1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + -1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 2, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 2, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 0, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 0, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 0, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 0, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + -1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + -1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][4])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][4])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][2])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][2])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][0])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][0])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][1])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][1])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][-3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][-3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][1] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][-1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][-1] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][1] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][0] == -2:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -2:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][0] == -0:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -0:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][0] == -0:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -0:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if down in g and g[down][0] == -1:",
      "mutated_line": "if down in g and g[down][0] == --1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == --1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 2, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 2, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 0, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 0, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 0, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 0, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - -1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - -1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 2, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 2, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 0, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 0, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 0, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 0, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + -1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + -1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][4])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][4])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][2])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][2])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][0])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][0])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][1])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][1])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][-3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][-3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][1] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][-1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][-1] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][1] == -1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][1] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][0] == -2:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -2:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][0] == -0:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -0:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][0] == -0:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -0:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jump in g and g[jump][0] == -1:",
      "mutated_line": "if jump in g and g[jump][0] == --1:",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == --1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 2, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 2, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 0, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 0, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 0, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 0, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + -1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + -1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][4])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][4])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][2])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][2])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][0])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][0])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][1])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][1])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][-3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][-3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == '' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == '' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 >= n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 >= n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 <= n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 <= n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 != n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 != n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k >= n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k >= n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k <= n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k <= n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k != n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k != n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 2] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 2] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 0] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 0] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + 0] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 0] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[1, i + -1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + -1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-2, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-2, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-0, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-0, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-0, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-0, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[--1, i + 1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[--1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 2] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 2] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 0] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 0] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + 0] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 0] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "g[-1, i + 1] = (-1, 0, 0, False)",
      "mutated_line": "g[-1, i + -1] = (-1, 0, 0, False)",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + -1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][2] + 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][2] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][0] + 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][0] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][0] + 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][0] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][-1] + 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][-1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][3] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][3] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][1] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][1] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][0] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][0] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][1] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][1] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[up] = ('VISITED', g[c][1] + 1, g[c][-2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][-2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][2] - 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][2] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][0] - 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][0] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][0] - 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][0] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][-1] - 1, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][-1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][3] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][3] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][1] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][1] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][0] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][0] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][1] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][1] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[down] = ('VISITED', g[c][1] - 1, g[c][-2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][-2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][2] + k, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][2] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][0] + k, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][0] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][0] + k, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][0] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][-1] + k, g[c][2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][-1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][3] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][3] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][1] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][1] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][0] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][0] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][1] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][1] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])",
      "mutated_line": "g[jump] = ('VISITED', g[c][1] + k, g[c][-2] + 1, g[c][3])",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][-2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[1] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[1] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[-1] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[-1] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[1] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[1] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] - 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] - 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] * 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] * 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] - k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] - k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] * k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] * k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[4]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[4]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[2]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[2]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[0]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[0]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[1]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[1]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[-3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[-3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 2 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 2 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 0 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 0 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 0 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 0 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + -1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + -1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[2] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[2] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[0] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[0] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[0] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[0] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[-1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[-1] + 1 > n or result[1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[2] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[2] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[0] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[0] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[0] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[0] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[1] + k > n) and (not result[3]):",
      "mutated_line": "if result[0] == 'VISITED' and (result[1] + 1 > n or result[-1] + k > n) and (not result[3]):",
      "code": "from collections import deque\n\ndef can_ninja_escape(n, k, left_wall, right_wall):\n    g = {}\n    for i in range(n):\n        if left_wall[i] == '-':\n            g[1, i + 1] = (-1, 0, 0, False)\n        if right_wall[i] == '-':\n            g[-1, i + 1] = (-1, 0, 0, False)\n    g[1, 1] = ('VISITED', 1, 0, False)\n    q = deque([(1, 1)])\n    while q:\n        c = q.popleft()\n        up = (c[0], c[1] + 1)\n        down = (c[0], c[1] - 1)\n        jump = (c[0] * -1, c[1] + k)\n        if g[c][1] <= g[c][2]:\n            g[c] = (g[c][0], g[c][1], g[c][2], True)\n        if up in g and g[up][0] == -1:\n            q.append(up)\n            g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n        if down in g and g[down][0] == -1:\n            q.append(down)\n            g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n        if jump in g and g[jump][0] == -1:\n            q.append(jump)\n            g[jump] = ('VISITED', g[c][1] + k, g[c][2] + 1, g[c][3])\n\n    def graphHasEscape(graph):\n        for node in graph:\n            result = graph[node]\n            if result[0] == 'VISITED' and (result[1] + 1 > n or result[-1] + k > n) and (not result[3]):\n                return True\n        return False\n    return 'YES' if graphHasEscape(g) else 'NO'"
    }
  ]
}