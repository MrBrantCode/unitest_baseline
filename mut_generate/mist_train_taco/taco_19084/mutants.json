{
  "task_id": "taco_19084",
  "entry_point": "distancia_euclidiana",
  "mutant_count": 176,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 or distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 or distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "resultado = 'NEITHER'",
      "mutated_line": "resultado = ''",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = ''\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) - math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) - math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) * math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) * math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) - math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) - math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) * math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) * math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) - math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) - math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) * math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) * math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] >= 0 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] >= 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] <= 0 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] <= 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] != 0 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] != 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] != distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] != distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "resultado = 'RIGHT'",
      "mutated_line": "resultado = ''",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = ''\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] -= 1",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] -= 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "pontos[i] -= 2",
      "mutated_line": "pontos[i] += 2",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] -= 1",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 1 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 1 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > -1 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > -1 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 1 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 1 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[1] - distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] - distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[1] * distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] * distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 6):",
      "mutated_line": "for i in range(1, 6):",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(1, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 6):",
      "mutated_line": "for i in range(-1, 6):",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(-1, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 6):",
      "mutated_line": "for i in range(1, 6):",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(1, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 6):",
      "mutated_line": "for i in range(0, 7):",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 7):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 6):",
      "mutated_line": "for i in range(0, 5):",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 5):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 6):",
      "mutated_line": "for i in range(0, 0):",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 0):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 6):",
      "mutated_line": "for i in range(0, 1):",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 1):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 6):",
      "mutated_line": "for i in range(0, -6):",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, -6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] += 2",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] += 0",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 0\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] += 0",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 0\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] += -1",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += -1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pontos[i] -= 2",
      "mutated_line": "pontos[i] -= 3",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 3\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pontos[i] -= 2",
      "mutated_line": "pontos[i] -= 1",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pontos[i] -= 2",
      "mutated_line": "pontos[i] -= 0",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 0\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pontos[i] -= 2",
      "mutated_line": "pontos[i] -= 1",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pontos[i] -= 2",
      "mutated_line": "pontos[i] -= -2",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= -2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] += 2",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 2\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] += 0",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 0\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] += 0",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 0\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pontos[i] += 1",
      "mutated_line": "pontos[i] += -1",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += -1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] + x[1], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] + x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] * x[1], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] * x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 3) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 3) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 1) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 1) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 0) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 0) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 1) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 1) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], -2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], -2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] + y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] + y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] * y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] * y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 3))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 3))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 1))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 1))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 0))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 0))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 1))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 1))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], -2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], -2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] + x[2], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] + x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] * x[2], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] * x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 3) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 3) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 1) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 1) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 0) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 0) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 1) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 1) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], -2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], -2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] + y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] + y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] * y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] * y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 3))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 3))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 1))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 1))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 0))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 0))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 1))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 1))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], -2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], -2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] + x[2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] + x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] * x[2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] * x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 3) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 3) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 1) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 1) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 0) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 0) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 1) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 1) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], -2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], -2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] + y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] + y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] * y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] * y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 3))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 3))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 1))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 1))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 0))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 0))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 1))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 1))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], -2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], -2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[1], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[1], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[-1], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[-1], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[1], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[1], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[3], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[3], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[1], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[1], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[0], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[0], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[1], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[1], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[-2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[-2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[5]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[5]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[3]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[3]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[0]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[0]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[1]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[1]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[-4]), (pontos[1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[-4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[2], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[2], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[0], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[0], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[0], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[0], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[-1], pontos[3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[-1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[4], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[4], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[2], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[2], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[0], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[0], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[1], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[1], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[-3], pontos[5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[-3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[6]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[6]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[4]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[4]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[0]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[0]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[1]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[1]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))",
      "mutated_line": "distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[-5]))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[-5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[1] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[1] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[-1] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[-1] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[1] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[1] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[3] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[3] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[1] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[1] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[0] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[0] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[1] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[1] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[-2] == distancias[1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[-2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "resultado = 'ALMOST'",
      "mutated_line": "resultado = ''",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = ''\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "resultado = 'ALMOST'",
      "mutated_line": "resultado = ''",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = ''\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[2] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[2] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[0] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[0] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[0] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[0] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[-1] + distancias[0]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[-1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[1]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[1]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[-1]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[-1]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]",
      "mutated_line": "return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[1]",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[1]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[1] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[-1] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[-1] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[1] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[0], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[0], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[0], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[0], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[-1], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[-1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[1] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[1] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[-1] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[-1] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[1] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[1] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[0], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[0], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[0], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[0], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[-1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[-1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[-1] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[-1] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[3], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[3], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[0], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[0], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[-2], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[-2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[-1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[-1] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[3], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[3], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[0], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[0], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[-2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[-2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[2] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[2] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[-1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[-1] - x[2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[3], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[3], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[1], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[1], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[0], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[0], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[1], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[1], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[-2], 2) + math.pow(y[1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[-2], 2) + math.pow(y[1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[2] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[2] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[0] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[-1] - y[2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[-1] - y[2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[3], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[3], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[1], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[0], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[0], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[1], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[1], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[2], 2))",
      "mutated_line": "lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[-2], 2))",
      "code": "import math\n\ndef distancia_euclidiana(x, y):\n    lados = []\n    lados.append(math.pow(x[0] - x[1], 2) + math.pow(y[0] - y[1], 2))\n    lados.append(math.pow(x[0] - x[2], 2) + math.pow(y[0] - y[2], 2))\n    lados.append(math.pow(x[1] - x[2], 2) + math.pow(y[1] - y[-2], 2))\n    return sorted(lados)\n\ndef is_right(pontos):\n    distancias = distancia_euclidiana((pontos[0], pontos[2], pontos[4]), (pontos[1], pontos[3], pontos[5]))\n    return distancias[0] > 0 and distancias[2] == distancias[1] + distancias[0]\n\ndef check_triangle_type(x1, y1, x2, y2, x3, y3):\n    pontos = [x1, y1, x2, y2, x3, y3]\n    resultado = 'NEITHER'\n    if is_right(pontos):\n        resultado = 'RIGHT'\n    else:\n        for i in range(0, 6):\n            pontos[i] += 1\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] -= 2\n            if is_right(pontos):\n                resultado = 'ALMOST'\n                break\n            pontos[i] += 1\n    return resultado"
    }
  ]
}