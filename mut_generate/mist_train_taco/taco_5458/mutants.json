{
  "task_id": "taco_5458",
  "entry_point": "calculate_maximum_beauty",
  "mutant_count": 135,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] / n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] / n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] + n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] + n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] ** n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] ** n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] - [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] - [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] * ([0] * (n - 1)))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] * ([0] * (n - 1)))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[0] / n for _ in range(2)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] / n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[0] + n for _ in range(2)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] + n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[0] ** n for _ in range(2)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] ** n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if poi[x] != len(y) and visi[y[poi[x]]]:",
      "mutated_line": "if poi[x] != len(y) or visi[y[poi[x]]]:",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) or visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] -= 1",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] -= 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if poi[x] == len(y):",
      "mutated_line": "if poi[x] != len(y):",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] != len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] -= 1",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] -= 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 1].append(v + 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v + 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 1].append(v * 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v * 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 1].append(u + 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u + 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 1].append(u * 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u * 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([1], [0] * n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([1], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([-1], [0] * n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([-1], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([1], [0] * n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([1], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [0] / (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] / (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + ([0] + (n - 1)))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + ([0] + (n - 1)))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [0] ** (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] ** (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if poi[x] != len(y) and visi[y[poi[x]]]:",
      "mutated_line": "if poi[x] == len(y) and visi[y[poi[x]]]:",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] == len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] += 2",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 2\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] += 0",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 0\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] += 0",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 0\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] += -1",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += -1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visi[i] = 1",
      "mutated_line": "visi[i] = 2",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 2\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visi[i] = 1",
      "mutated_line": "visi[i] = 0",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 0\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visi[i] = 1",
      "mutated_line": "visi[i] = 0",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 0\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visi[i] = 1",
      "mutated_line": "visi[i] = -1",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = -1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] += 2",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 2\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] += 0",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 0\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] += 0",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 0\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "poi[x] += 1",
      "mutated_line": "poi[x] += -1",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += -1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][1], dp[1][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][1], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][-1], dp[1][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][-1], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][1], dp[1][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][1], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][0], dp[1][1])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][0], dp[1][-1])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][-1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][0], dp[1][1])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 1].append(v - 2)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 2)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 1].append(v - 0)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 0)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 1].append(v - 0)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 0)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 1].append(v - -1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - -1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 1].append(u - 2)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 2)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 1].append(u - 0)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 0)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 1].append(u - 0)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 0)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 1].append(u - -1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - -1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [1] * n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [1] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [-1] * n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [-1] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [1] * n, [1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [1] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [2] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [2] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [0] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [0] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [0] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [0] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [-1] + [0] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [-1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [0] * (n + 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n + 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [0] * (n * 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n * 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[1] * n for _ in range(2)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[1] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[-1] * n for _ in range(2)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[-1] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[1] * n for _ in range(2)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[1] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[0] * n for _ in range(3)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(3)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[0] * n for _ in range(1)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(1)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[0] * n for _ in range(0)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(0)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[0] * n for _ in range(1)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(1)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[0] * n for _ in range(2)]",
      "mutated_line": "dp = [[0] * n for _ in range(-2)]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(-2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[+1], path[st[-1]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[+1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] -= max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] -= max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[1][0], dp[1][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[1][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[-1][0], dp[1][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[-1][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[1][0], dp[1][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[1][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][0], dp[2][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[2][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][0], dp[0][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[0][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][0], dp[0][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[0][0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return max(dp[0][0], dp[1][0])",
      "mutated_line": "return max(dp[0][0], dp[-1][0])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[-1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u + 1].append(v - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u + 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u * 1].append(v - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u * 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v + 1].append(u - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v + 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v * 1].append(u - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v * 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [1] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [1] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [-1] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [-1] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [1] * (n - 1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [1] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 2))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 2))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 0))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 0))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 0))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 0))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st, poi, visi = [0], [0] * n, [1] + [0] * (n - 1)",
      "mutated_line": "(st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - -1))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - -1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[-2], path[st[-1]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-2], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[-0], path[st[-1]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-0], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[-0], path[st[-1]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-0], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[--1], path[st[-1]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[--1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[-1], path[st[+1]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[+1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "z = st[-1]",
      "mutated_line": "z = st[+1]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[+1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for rr in range(2):",
      "mutated_line": "for rr in range(3):",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(3):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for rr in range(2):",
      "mutated_line": "for rr in range(1):",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(1):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for rr in range(2):",
      "mutated_line": "for rr in range(0):",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(0):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for rr in range(2):",
      "mutated_line": "for rr in range(1):",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(1):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for rr in range(2):",
      "mutated_line": "for rr in range(-2):",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(-2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 2].append(v - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 2].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 0].append(v - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 0].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - 0].append(v - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 0].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "path[u - 1].append(v - 1)",
      "mutated_line": "path[u - -1].append(v - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - -1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 2].append(u - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 2].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 0].append(u - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 0].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - 0].append(u - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 0].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "path[v - 1].append(u - 1)",
      "mutated_line": "path[v - -1].append(u - 1)",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - -1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[-1], path[st[-2]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-2]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[-1], path[st[-0]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-0]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[-1], path[st[-0]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-0]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = st[-1], path[st[-1]]",
      "mutated_line": "(x, y) = (st[-1], path[st[--1]])",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[--1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "z = st[-1]",
      "mutated_line": "z = st[-2]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-2]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "z = st[-1]",
      "mutated_line": "z = st[-0]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-0]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "z = st[-1]",
      "mutated_line": "z = st[-0]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-0]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "z = st[-1]",
      "mutated_line": "z = st[--1]",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[--1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] - abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] - abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] * abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] * abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] - abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] - abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] * abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] * abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] + vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] + vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] * vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] * vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] + vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] + vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] * vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] * vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[1][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[1][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[-1][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[-1][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[1][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[1][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[2][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[2][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[0][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[0][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[0][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[0][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[-1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[-1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][1] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][1] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][-1] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][-1] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][1] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][1] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][2] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][2] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][0] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][0] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][0] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][0] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][1] - vertices[z][rr]))",
      "mutated_line": "dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][-1] - vertices[z][rr]))",
      "code": "def calculate_maximum_beauty(n, vertices, edges):\n    path = [[] for _ in range(n)]\n    for (u, v) in edges:\n        path[u - 1].append(v - 1)\n        path[v - 1].append(u - 1)\n    (st, poi, visi) = ([0], [0] * n, [1] + [0] * (n - 1))\n    dp = [[0] * n for _ in range(2)]\n    while len(st):\n        (x, y) = (st[-1], path[st[-1]])\n        if poi[x] != len(y) and visi[y[poi[x]]]:\n            poi[x] += 1\n        if poi[x] == len(y):\n            st.pop()\n            if len(st):\n                z = st[-1]\n                for rr in range(2):\n                    dp[rr][z] += max(dp[0][x] + abs(vertices[x][0] - vertices[z][rr]), dp[1][x] + abs(vertices[x][-1] - vertices[z][rr]))\n        else:\n            i = y[poi[x]]\n            visi[i] = 1\n            st.append(i)\n            poi[x] += 1\n    return max(dp[0][0], dp[1][0])"
    }
  ]
}