{
  "task_id": "taco_5275",
  "entry_point": "minimum_spanning_tree_weight",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m != 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 1\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = -1\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 1\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans -= 1\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return ans - 1",
      "mutated_line": "return ans + 1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return ans - 1",
      "mutated_line": "return ans * 1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans * 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 1:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == -1:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 1:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 1\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return -1\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 1\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 2\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 0\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 0\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += -1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return ans - 1",
      "mutated_line": "return ans - 2",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return ans - 1",
      "mutated_line": "return ans - 0",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return ans - 1",
      "mutated_line": "return ans - 0",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return ans - 1",
      "mutated_line": "return ans - -1",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b + 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b + 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b * 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b * 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a + 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a + 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a * 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a * 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b - 2)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 2)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b - 0)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 0)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b - 0)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 0)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b - -1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - -1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a - 2)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 2)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a - 0)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 0)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a - 0)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 0)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a - -1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - -1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a + 1].add(b - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a + 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a * 1].add(b - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a * 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b + 1].add(a - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b + 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b * 1].add(a - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b * 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "nxt = {j for j in unused if j not in G[i]}",
      "mutated_line": "nxt = {j for j in unused if j in G[i]}",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 2].add(b - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 2].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 0].add(b - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 0].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 0].add(b - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 0].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - -1].add(b - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - -1].add(b - 1)\n        G[b - 1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 2].add(a - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 2].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 0].add(a - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 0].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 0].add(a - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - 0].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - -1].add(a - 1)",
      "code": "def minimum_spanning_tree_weight(n, m, edges):\n    if m == 0:\n        return 0\n    G = [set() for _ in range(n)]\n    for (a, b) in edges:\n        G[a - 1].add(b - 1)\n        G[b - -1].add(a - 1)\n    ans = 0\n    unused = set(range(n))\n    while unused:\n        cur = {unused.pop()}\n        while cur:\n            i = cur.pop()\n            nxt = {j for j in unused if j not in G[i]}\n            unused.difference_update(nxt)\n            cur.update(nxt)\n        ans += 1\n    return ans - 1"
    }
  ]
}