{
  "task_id": "taco_17220",
  "entry_point": "count_ways_to_win",
  "mutant_count": 194,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 - 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 * 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 200001",
      "mutated_line": "N = 200002",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200002\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 200001",
      "mutated_line": "N = 200000",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200000\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 200001",
      "mutated_line": "N = 0",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 0\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 200001",
      "mutated_line": "N = 1",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 1\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 200001",
      "mutated_line": "N = -200001",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = -200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev = 1",
      "mutated_line": "prev = 2",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 2\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev = 1",
      "mutated_line": "prev = 0",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 0\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev = 1",
      "mutated_line": "prev = 0",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 0\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev = 1",
      "mutated_line": "prev = -1",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = -1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv = [0] * N",
      "mutated_line": "inv = [0] / N",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] / N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv = [0] * N",
      "mutated_line": "inv = [0] + N",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] + N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv = [0] * N",
      "mutated_line": "inv = [0] ** N",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] ** N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) * MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) * MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) + MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) + MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 2\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 0\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 0\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = -1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while e > 0:",
      "mutated_line": "while e >= 0:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e >= 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while e > 0:",
      "mutated_line": "while e <= 0:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e <= 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while e > 0:",
      "mutated_line": "while e != 0:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e != 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return ((a - b) % MOD + MOD) % MOD",
      "mutated_line": "return ((a - b) % MOD + MOD) * MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return ((a - b) % MOD + MOD) % MOD",
      "mutated_line": "return (a - b) % MOD + MOD + MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return (a - b) % MOD + MOD + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 * 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 + 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 8\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 6\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 0\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 1\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + -7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [2]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [2]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [0]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [0]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [0]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [0]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [-1]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [-1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(2, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(0, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(0, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(-1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f = prev * i % MOD",
      "mutated_line": "f = prev * i * MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i * MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f = prev * i % MOD",
      "mutated_line": "f = prev * i + MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i + MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N + 1] = mod_inv_fact(N - 1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N + 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N * 1] = mod_inv_fact(N - 1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N * 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 1] = mod_inv_fact(N + 1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N + 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 1] = mod_inv_fact(N * 1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N * 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N + 2, -1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N + 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N * 2, -1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N * 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, +1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, +1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, -1, +1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, +1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 1) * MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) * MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 1) + MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) + MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return ways[-1]",
      "mutated_line": "return ways[+1]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[+1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] / (inv[k] * inv[n - k] % MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] / (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return (fact[n] + inv[k] * inv[n - k] % MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return (fact[n] + inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] ** (inv[k] * inv[n - k] % MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] ** (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return mod_exp(fact[n], MOD - 2, MOD)",
      "mutated_line": "return mod_exp(fact[n], MOD + 2, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD + 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return mod_exp(fact[n], MOD - 2, MOD)",
      "mutated_line": "return mod_exp(fact[n], MOD * 2, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD * 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while e > 0:",
      "mutated_line": "while e > 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 1:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while e > 0:",
      "mutated_line": "while e > -1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > -1:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while e > 0:",
      "mutated_line": "while e > 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 1:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 != 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 != 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "e >>= 1",
      "mutated_line": "e >>= 2",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 2\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "e >>= 1",
      "mutated_line": "e >>= 0",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 0\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "e >>= 1",
      "mutated_line": "e >>= 0",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 0\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "e >>= 1",
      "mutated_line": "e >>= -1",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= -1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "n = n * n % MOD",
      "mutated_line": "n = n * n * MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n * MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "n = n * n % MOD",
      "mutated_line": "n = n * n + MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n + MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return ((a - b) % MOD + MOD) % MOD",
      "mutated_line": "return ((a - b) % MOD - MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD - MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return ((a - b) % MOD + MOD) % MOD",
      "mutated_line": "return (a - b) % MOD * MOD % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return (a - b) % MOD * MOD % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 11 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 9 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 0 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 1 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = -10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 10 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 8 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 0 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 1 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** -9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f = prev * i % MOD",
      "mutated_line": "f = prev / i % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev / i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f = prev * i % MOD",
      "mutated_line": "f = (prev + i) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = (prev + i) % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f = prev * i % MOD",
      "mutated_line": "f = prev ** i % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev ** i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "inv = [0] * N",
      "mutated_line": "inv = [1] * N",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [1] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "inv = [0] * N",
      "mutated_line": "inv = [-1] * N",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [-1] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "inv = [0] * N",
      "mutated_line": "inv = [1] * N",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [1] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 2] = mod_inv_fact(N - 1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 2] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 0] = mod_inv_fact(N - 1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 0] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 0] = mod_inv_fact(N - 1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 0] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - -1] = mod_inv_fact(N - 1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - -1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 1] = mod_inv_fact(N - 2, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 2, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 1] = mod_inv_fact(N - 0, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 0, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 1] = mod_inv_fact(N - 0, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 0, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)",
      "mutated_line": "inv[N - 1] = mod_inv_fact(N - -1, fact, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - -1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 3, -1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 3, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 1, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 0, -1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 0, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 1, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - -2, -1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - -2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, -2, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -2, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, -0, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -0, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, -0, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -0, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, --1, -1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, --1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, -1, -2):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -2):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, -1, -0):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -0):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, -1, -0):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -0):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(N - 2, -1, -1):",
      "mutated_line": "for i in range(N - 2, -1, --1):",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, --1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] / (i + 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] / (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = (inv[i + 1] + (i + 1)) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = (inv[i + 1] + (i + 1)) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] ** (i + 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] ** (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if h_j <= h_i and w_j <= w_i:",
      "mutated_line": "if h_j <= h_i or w_j <= w_i:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i or w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return ways[-1]",
      "mutated_line": "return ways[-2]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-2]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return ways[-1]",
      "mutated_line": "return ways[-0]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-0]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return ways[-1]",
      "mutated_line": "return ways[-0]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-0]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return ways[-1]",
      "mutated_line": "return ways[--1]",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[--1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * (inv[k] * inv[n - k] * MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] * MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * (inv[k] * inv[n - k] + MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] + MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return mod_exp(fact[n], MOD - 2, MOD)",
      "mutated_line": "return mod_exp(fact[n], MOD - 3, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 3, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return mod_exp(fact[n], MOD - 2, MOD)",
      "mutated_line": "return mod_exp(fact[n], MOD - 1, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 1, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return mod_exp(fact[n], MOD - 2, MOD)",
      "mutated_line": "return mod_exp(fact[n], MOD - 0, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 0, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return mod_exp(fact[n], MOD - 2, MOD)",
      "mutated_line": "return mod_exp(fact[n], MOD - 1, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 1, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return mod_exp(fact[n], MOD - 2, MOD)",
      "mutated_line": "return mod_exp(fact[n], MOD - -2, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - -2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e * 2 == 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e * 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e + 2 == 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e + 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 2:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 2:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 0:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 0:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 0:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 0:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == -1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == -1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "res = res * n % MOD",
      "mutated_line": "res = res * n * MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n * MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "res = res * n % MOD",
      "mutated_line": "res = res * n + MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n + MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "n = n * n % MOD",
      "mutated_line": "n = n / n % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n / n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "n = n * n % MOD",
      "mutated_line": "n = (n + n) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = (n + n) % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "n = n * n % MOD",
      "mutated_line": "n = n ** n % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n ** n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return ((a - b) % MOD + MOD) % MOD",
      "mutated_line": "return ((a - b) * MOD + MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) * MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return ((a - b) % MOD + MOD) % MOD",
      "mutated_line": "return (a - b + MOD + MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return (a - b + MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i - 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i - 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i * 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i * 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i + 2, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i + 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C((h_i + w_i) * 2, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C((h_i + w_i) * 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 2, h_i + 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i + 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 2, h_i * 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i * 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if h_j <= h_i and w_j <= w_i:",
      "mutated_line": "if h_j < h_i and w_j <= w_i:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j < h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if h_j <= h_i and w_j <= w_i:",
      "mutated_line": "if h_j > h_i and w_j <= w_i:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j > h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if h_j <= h_i and w_j <= w_i:",
      "mutated_line": "if h_j == h_i and w_j <= w_i:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j == h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if h_j <= h_i and w_j <= w_i:",
      "mutated_line": "if h_j <= h_i and w_j < w_i:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j < w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if h_j <= h_i and w_j <= w_i:",
      "mutated_line": "if h_j <= h_i and w_j > w_i:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j > w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if h_j <= h_i and w_j <= w_i:",
      "mutated_line": "if h_j <= h_i and w_j == w_i:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j == w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * (inv[k] / inv[n - k] % MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] / inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * ((inv[k] + inv[n - k]) % MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * ((inv[k] + inv[n - k]) % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * (inv[k] ** inv[n - k] % MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] ** inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 3 == 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 3 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 1 == 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 1 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 0 == 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 0 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 1 == 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 1 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % -2 == 1:",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % -2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "res = res * n % MOD",
      "mutated_line": "res = res / n % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res / n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "res = res * n % MOD",
      "mutated_line": "res = (res + n) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = (res + n) % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "res = res * n % MOD",
      "mutated_line": "res = res ** n % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res ** n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return ((a - b) % MOD + MOD) % MOD",
      "mutated_line": "return ((a + b) % MOD + MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a + b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return ((a - b) % MOD + MOD) % MOD",
      "mutated_line": "return (a * b % MOD + MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return (a * b % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i - 1] * (i + 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i - 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i * 1] * (i + 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i * 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 2) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 2) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 0) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 0) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 0) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 0) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + -1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + -1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i - w_i - 2, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i - w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i * w_i - 2, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i * w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 3, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 3, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 1, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 1, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 0, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 0, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 1, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 1, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - -2, h_i - 1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - -2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 2, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 2, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 0, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 0, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 0, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 0, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))",
      "mutated_line": "ways.append(mod_C(h_i + w_i - 2, h_i - -1, fact, inv, MOD))",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - -1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "mutated_line": "mult = mod_C(h_i - h_j + w_i + w_j, h_i - h_j, fact, inv, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i + w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "mutated_line": "mult = mod_C((h_i - h_j + w_i) * w_j, h_i - h_j, fact, inv, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C((h_i - h_j + w_i) * w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "mutated_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i + h_j, fact, inv, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i + h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "mutated_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i * h_j, fact, inv, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i * h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)",
      "mutated_line": "ways[i] = mod_sub(ways[i], ways[j] / mult, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] / mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)",
      "mutated_line": "ways[i] = mod_sub(ways[i], ways[j] + mult, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] + mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)",
      "mutated_line": "ways[i] = mod_sub(ways[i], ways[j] ** mult, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] ** mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 2] * (i + 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 2] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 0] * (i + 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 0] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 0] * (i + 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 0] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + -1] * (i + 1) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + -1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "mutated_line": "mult = mod_C(h_i - h_j - w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j - w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "mutated_line": "mult = mod_C((h_i - h_j) * w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C((h_i - h_j) * w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * (inv[k] * inv[n + k] % MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n + k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD",
      "mutated_line": "return fact[n] * (inv[k] * inv[n * k] % MOD) % MOD",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n * k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "mutated_line": "mult = mod_C(h_i + h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i + h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mult = mod_C(h_i - h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "mutated_line": "mult = mod_C(h_i * h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)",
      "code": "def count_ways_to_win(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = 200001\n    fact = [1]\n    prev = 1\n    for i in range(1, N):\n        f = prev * i % MOD\n        fact.append(f)\n        prev = f\n    inv = [0] * N\n    inv[N - 1] = mod_inv_fact(N - 1, fact, MOD)\n    for i in range(N - 2, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    pt = sorted(black_cells)\n    pt.append((h, w))\n    ways = []\n    for i in range(len(pt)):\n        (h_i, w_i) = pt[i]\n        ways.append(mod_C(h_i + w_i - 2, h_i - 1, fact, inv, MOD))\n        for j in range(i):\n            (h_j, w_j) = pt[j]\n            if h_j <= h_i and w_j <= w_i:\n                mult = mod_C(h_i * h_j + w_i - w_j, h_i - h_j, fact, inv, MOD)\n                ways[i] = mod_sub(ways[i], ways[j] * mult, MOD)\n    return ways[-1]\n\ndef mod_C(n: int, k: int, fact: list, inv: list, MOD: int) -> int:\n    return fact[n] * (inv[k] * inv[n - k] % MOD) % MOD\n\ndef mod_inv_fact(n: int, fact: list, MOD: int) -> int:\n    return mod_exp(fact[n], MOD - 2, MOD)\n\ndef mod_exp(n: int, e: int, MOD: int) -> int:\n    res = 1\n    while e > 0:\n        if e % 2 == 1:\n            res = res * n % MOD\n        e >>= 1\n        n = n * n % MOD\n    return res\n\ndef mod_sub(a: int, b: int, MOD: int) -> int:\n    return ((a - b) % MOD + MOD) % MOD"
    }
  ]
}