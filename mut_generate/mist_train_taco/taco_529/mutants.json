{
  "task_id": "taco_529",
  "entry_point": "remove_repeats",
  "mutant_count": 120,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 121 + 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 + 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 121 * 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 * 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(1000000000.0) - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) - 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(1000000000.0) * 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) * 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] / (n + 1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] / (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] + (n + 1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] + (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] ** (n + 1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] ** (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best = 0",
      "mutated_line": "best = 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 1\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best = 0",
      "mutated_line": "best = -1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = -1\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best = 0",
      "mutated_line": "best = 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 1\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 1\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = -1\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 1\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while i < n:",
      "mutated_line": "while i <= n:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i <= n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while i < n:",
      "mutated_line": "while i >= n:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i >= n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while i < n:",
      "mutated_line": "while i != n:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i != n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i -= 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 * 121 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 * 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 + 121 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 + 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 121 - 2",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 2\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 121 - 0",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 0\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 121 - 0",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 0\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 121 - -1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - -1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(1000000000.0) + 2",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 2\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(1000000000.0) + 0",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 0\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(1000000000.0) + 0",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 0\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(1000000000.0) + -1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + -1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "powsA = [1]",
      "mutated_line": "powsA = [2]",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [2]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "powsA = [1]",
      "mutated_line": "powsA = [0]",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [0]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "powsA = [1]",
      "mutated_line": "powsA = [0]",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [0]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "powsA = [1]",
      "mutated_line": "powsA = [-1]",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [-1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n - 1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n - 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n * 1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n * 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) * MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) * MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 1] = hashes[i] * M + vals[i] + MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = hashes[i] * M + vals[i] + MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p + l] + hashes[p] * powsA[l] % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] + hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p + l] * (hashes[p] * powsA[l] % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] * (hashes[p] * powsA[l] % MOD)\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if res < 0:",
      "mutated_line": "if res <= 0:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res <= 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if res < 0:",
      "mutated_line": "if res >= 0:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res >= 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if res < 0:",
      "mutated_line": "if res != 0:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res != 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "res += MOD",
      "mutated_line": "res -= MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res -= MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 2\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 0\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 0\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += -1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 3 ** 121 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 3 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 1 ** 121 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 1 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 0 ** 121 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 0 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 1 ** 121 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 1 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = -2 ** 121 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = -2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 122 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 122 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 120 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 120 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 0 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 0 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** 1 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 1 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 2 ** 121 - 1",
      "mutated_line": "MOD = 2 ** -121 - 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** -121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(1000000001.0) + 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000001.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(999999999.0) + 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(999999999.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(0) + 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(1) + 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = int(1000000000.0) + 1",
      "mutated_line": "M = int(-1000000000.0) + 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(-1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[-1] * M * MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M * MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[-1] * M + MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M + MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [1] * (n + 1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [1] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [-1] * (n + 1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [-1] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [1] * (n + 1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [1] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n + 2)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 2)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n + 0)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 0)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n + 0)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 0)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n + -1)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + -1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i - 1] = (hashes[i] * M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i - 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i * 1] = (hashes[i] * M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i * 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 1] = (hashes[i] * M - vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M - vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 1] = hashes[i] * M * vals[i] % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = hashes[i] * M * vals[i] % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p + l] - hashes[p] * powsA[l] * MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] * MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p + l] - (hashes[p] * powsA[l] + MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - (hashes[p] * powsA[l] + MOD)\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if res < 0:",
      "mutated_line": "if res < 1:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 1:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if res < 0:",
      "mutated_line": "if res < -1:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < -1:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if res < 0:",
      "mutated_line": "if res < 1:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 1:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif res > MOD:",
      "mutated_line": "elif res >= MOD:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res >= MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif res > MOD:",
      "mutated_line": "elif res <= MOD:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res <= MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif res > MOD:",
      "mutated_line": "elif res != MOD:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res != MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "res -= MOD",
      "mutated_line": "res += MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res += MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if j <= i:",
      "mutated_line": "if j < i:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j < i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if j <= i:",
      "mutated_line": "if j > i:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j > i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if j <= i:",
      "mutated_line": "if j == i:",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j == i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l = j - i",
      "mutated_line": "l = j + i",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j + i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l = j - i",
      "mutated_line": "l = j * i",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j * i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if j + l <= n and get_hash(i, l) == get_hash(j, l):",
      "mutated_line": "if j + l <= n or get_hash(i, l) == get_hash(j, l):",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n or get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[-1] / M % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] / M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append((powsA[-1] + M) % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append((powsA[-1] + M) % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[-1] ** M % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] ** M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 2] = (hashes[i] * M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 2] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 0] = (hashes[i] * M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 0] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 0] = (hashes[i] * M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 0] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + -1] = (hashes[i] * M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + -1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 1] = (hashes[i] / M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] / M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 1] = (hashes[i] + M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] + M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD",
      "mutated_line": "hashes[i + 1] = (hashes[i] ** M + vals[i]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] ** M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p - l] - hashes[p] * powsA[l] % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p - l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p * l] - hashes[p] * powsA[l] % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p * l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p + l] - hashes[p] / powsA[l] % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] / powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p + l] - (hashes[p] + powsA[l]) % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - (hashes[p] + powsA[l]) % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = hashes[p + l] - hashes[p] * powsA[l] % MOD",
      "mutated_line": "res = hashes[p + l] - hashes[p] ** powsA[l] % MOD",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] ** powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if j + l <= n and get_hash(i, l) == get_hash(j, l):",
      "mutated_line": "if j + l < n and get_hash(i, l) == get_hash(j, l):",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l < n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if j + l <= n and get_hash(i, l) == get_hash(j, l):",
      "mutated_line": "if j + l > n and get_hash(i, l) == get_hash(j, l):",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l > n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if j + l <= n and get_hash(i, l) == get_hash(j, l):",
      "mutated_line": "if j + l == n and get_hash(i, l) == get_hash(j, l):",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l == n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if j + l <= n and get_hash(i, l) == get_hash(j, l):",
      "mutated_line": "if j + l <= n and get_hash(i, l) != get_hash(j, l):",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) != get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "i = j - 1",
      "mutated_line": "i = j + 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j + 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "i = j - 1",
      "mutated_line": "i = j * 1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j * 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if j + l <= n and get_hash(i, l) == get_hash(j, l):",
      "mutated_line": "if j - l <= n and get_hash(i, l) == get_hash(j, l):",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j - l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if j + l <= n and get_hash(i, l) == get_hash(j, l):",
      "mutated_line": "if j * l <= n and get_hash(i, l) == get_hash(j, l):",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j * l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = j - 1",
      "mutated_line": "i = j - 2",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 2\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = j - 1",
      "mutated_line": "i = j - 0",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 0\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = j - 1",
      "mutated_line": "i = j - 0",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 0\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = j - 1",
      "mutated_line": "i = j - -1",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - -1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[+1] * M % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[+1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[-2] * M % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-2] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[-0] * M % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-0] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[-0] * M % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[-0] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "powsA.append(powsA[-1] * M % MOD)",
      "mutated_line": "powsA.append(powsA[--1] * M % MOD)",
      "code": "def remove_repeats(n, vals):\n    MOD = 2 ** 121 - 1\n    M = int(1000000000.0) + 1\n    groups = dict()\n    for i in range(n):\n        groups.setdefault(vals[i], []).append(i)\n    powsA = [1]\n    for i in range(n):\n        powsA.append(powsA[--1] * M % MOD)\n    hashes = [0] * (n + 1)\n    for i in range(n):\n        hashes[i + 1] = (hashes[i] * M + vals[i]) % MOD\n\n    def get_hash(p, l):\n        res = hashes[p + l] - hashes[p] * powsA[l] % MOD\n        if res < 0:\n            res += MOD\n        elif res > MOD:\n            res -= MOD\n        return res\n    best = 0\n    i = 0\n    while i < n:\n        val = vals[i]\n        for j in groups[val]:\n            if j <= i:\n                continue\n            l = j - i\n            if j + l <= n and get_hash(i, l) == get_hash(j, l):\n                best = max(best, j)\n                i = j - 1\n                break\n        i += 1\n    res = vals[best:]\n    return (len(res), res)"
    }
  ]
}