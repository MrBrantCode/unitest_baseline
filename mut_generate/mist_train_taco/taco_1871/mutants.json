{
  "task_id": "taco_1871",
  "entry_point": "maximize_good_vertices",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 1\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = -1\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 1\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dijkstra(1)",
      "mutated_line": "dijkstra(2)",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(2)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dijkstra(1)",
      "mutated_line": "dijkstra(0)",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(0)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dijkstra(1)",
      "mutated_line": "dijkstra(0)",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(0)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dijkstra(1)",
      "mutated_line": "dijkstra(-1)",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(-1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] / (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] / (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] + (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] + (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] ** (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] ** (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] / (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] / (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] + (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] + (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] ** (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] ** (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if vis[vertex] == 1:",
      "mutated_line": "if vis[vertex] != 1:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] != 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis[vertex] = 1",
      "mutated_line": "vis[vertex] = 2",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 2\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis[vertex] = 1",
      "mutated_line": "vis[vertex] = 0",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 0\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis[vertex] = 1",
      "mutated_line": "vis[vertex] = 0",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 0\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis[vertex] = 1",
      "mutated_line": "vis[vertex] = -1",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = -1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if index != -1:",
      "mutated_line": "if index == -1:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index == -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(ans) == min(n - 1, k):",
      "mutated_line": "if len(ans) != min(n - 1, k):",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) != min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "weight += d",
      "mutated_line": "weight -= d",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight -= d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "graph[x].append((y, w, i + 1))",
      "mutated_line": "graph[x].append((y, w, i - 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i - 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "graph[x].append((y, w, i + 1))",
      "mutated_line": "graph[x].append((y, w, i * 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i * 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "graph[y].append((y, w, i + 1))",
      "mutated_line": "graph[y].append((y, w, i - 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i - 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "graph[y].append((y, w, i + 1))",
      "mutated_line": "graph[y].append((y, w, i * 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i * 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n - 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n - 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n * 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n * 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n - 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n - 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n * 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n * 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis[vertex] == 1:",
      "mutated_line": "if vis[vertex] == 2:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 2:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis[vertex] == 1:",
      "mutated_line": "if vis[vertex] == 0:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 0:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis[vertex] == 1:",
      "mutated_line": "if vis[vertex] == 0:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 0:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis[vertex] == 1:",
      "mutated_line": "if vis[vertex] == -1:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == -1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if index != -1:",
      "mutated_line": "if index != +1:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != +1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dist[child] > weight:",
      "mutated_line": "if dist[child] >= weight:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] >= weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dist[child] > weight:",
      "mutated_line": "if dist[child] <= weight:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] <= weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dist[child] > weight:",
      "mutated_line": "if dist[child] != weight:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] != weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph[x].append((y, w, i + 1))",
      "mutated_line": "graph[x].append((y, w, i + 2))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 2))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph[x].append((y, w, i + 1))",
      "mutated_line": "graph[x].append((y, w, i + 0))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 0))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph[x].append((y, w, i + 1))",
      "mutated_line": "graph[x].append((y, w, i + 0))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 0))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph[x].append((y, w, i + 1))",
      "mutated_line": "graph[x].append((y, w, i + -1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + -1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "graph[y].append((y, w, i + 1))",
      "mutated_line": "graph[y].append((y, w, i + 2))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 2))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "graph[y].append((y, w, i + 1))",
      "mutated_line": "graph[y].append((y, w, i + 0))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 0))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "graph[y].append((y, w, i + 1))",
      "mutated_line": "graph[y].append((y, w, i + 0))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 0))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "graph[y].append((y, w, i + 1))",
      "mutated_line": "graph[y].append((y, w, i + -1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + -1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(1, start, -1)], [inf] * (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(1, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(-1, start, -1)], [inf] * (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(-1, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(1, start, -1)], [inf] * (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(1, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, +1)], [inf] * (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, +1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 2), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 2), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 0), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 0), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 0), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 0), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + -1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + -1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [1] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [1] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [-1] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [-1] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [1] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [1] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 2))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 2))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 0))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 0))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 0))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 0))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + -1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + -1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if index != -1:",
      "mutated_line": "if index != -2:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -2:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if index != -1:",
      "mutated_line": "if index != -0:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -0:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if index != -1:",
      "mutated_line": "if index != -0:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -0:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if index != -1:",
      "mutated_line": "if index != --1:",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != --1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if len(ans) == min(n - 1, k):",
      "mutated_line": "if len(ans) == min(n + 1, k):",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n + 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if len(ans) == min(n - 1, k):",
      "mutated_line": "if len(ans) == min(n * 1, k):",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n * 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -2)], [inf] * (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -2)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -0)], [inf] * (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -0)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, -0)], [inf] * (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -0)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heap, dist, vis = [(0, start, -1)], [inf] * (n + 1), [0] * (n + 1)",
      "mutated_line": "(heap, dist, vis) = ([(0, start, --1)], [inf] * (n + 1), [0] * (n + 1))",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, --1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(ans) == min(n - 1, k):",
      "mutated_line": "if len(ans) == min(n - 2, k):",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 2, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(ans) == min(n - 1, k):",
      "mutated_line": "if len(ans) == min(n - 0, k):",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 0, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(ans) == min(n - 1, k):",
      "mutated_line": "if len(ans) == min(n - 0, k):",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - 0, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(ans) == min(n - 1, k):",
      "mutated_line": "if len(ans) == min(n - -1, k):",
      "code": "from collections import defaultdict\nfrom math import inf\nfrom heapq import heappop, heappush\n\ndef maximize_good_vertices(n, m, k, edges):\n    graph = defaultdict(list)\n    for i in range(m):\n        (x, y, w) = edges[i]\n        graph[x].append((y, w, i + 1))\n        graph[y].append((y, w, i + 1))\n    ans = []\n\n    def dijkstra(start):\n        (heap, dist, vis) = ([(0, start, -1)], [inf] * (n + 1), [0] * (n + 1))\n        dist[start] = 0\n        while heap:\n            (d, vertex, index) = heappop(heap)\n            if vis[vertex] == 1:\n                continue\n            vis[vertex] = 1\n            if index != -1:\n                ans.append(index)\n            if len(ans) == min(n - -1, k):\n                return ans\n            for (child, weight, index) in graph[vertex]:\n                weight += d\n                if dist[child] > weight:\n                    dist[child] = weight\n                    heappush(heap, (weight, child, index))\n        return ans\n    dijkstra(1)\n    e = len(ans)\n    remaining_edges = ans\n    return (e, remaining_edges)"
    }
  ]
}