{
  "task_id": "taco_423",
  "entry_point": "minimum_almonds_for_beko",
  "mutant_count": 233,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "m += 1",
      "mutated_line": "m -= 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m -= 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n != 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m += 1",
      "mutated_line": "m += 2",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 2\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m += 1",
      "mutated_line": "m += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 0\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m += 1",
      "mutated_line": "m += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 0\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m += 1",
      "mutated_line": "m += -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += -1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 2 / (w * h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 / (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 2 + w * h",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 + w * h\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 2 ** (w * h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 ** (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 + 2 * S",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 + 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 * (2 * S)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 * (2 * S)\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = 1",
      "mutated_line": "j = 2",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 2\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 0\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 0\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = 1",
      "mutated_line": "j = -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = -1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][2] -= 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] -= 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] -= tbl[i - 1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] -= tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if S == 0:",
      "mutated_line": "if S != 0:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S != 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if s[j] != S:",
      "mutated_line": "if s[j] == S:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] == S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j += 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j + 1 <= m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 <= m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j + 1 >= m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 >= m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j + 1 != m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 != m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j -= 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return n - ans",
      "mutated_line": "return n + ans",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n + ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return n - ans",
      "mutated_line": "return n * ans",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n * ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 1:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == -1:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 1:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 1\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return -1\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 1\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 3 * (w * h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 3 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 1 * (w * h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 1 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 0 * (w * h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 0 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 1 * (w * h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 1 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = -2 * (w * h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = -2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 2 * (w / h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w / h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 2 * (w + h)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w + h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "wh2 = 2 * (w * h)",
      "mutated_line": "wh2 = 2 * w ** h",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * w ** h\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 - 2 / S",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 / S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 - (2 + S)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - (2 + S)\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 - 2 ** S",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 ** S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "s = [0]",
      "mutated_line": "s = [1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [1]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "s = [0]",
      "mutated_line": "s = [-1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [-1]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "s = [0]",
      "mutated_line": "s = [1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [1]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, m):",
      "mutated_line": "(l, r) = lines[i - 1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(2, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, m):",
      "mutated_line": "(l, r) = lines[i - 1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(0, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, m):",
      "mutated_line": "(l, r) = lines[i - 1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(0, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, m):",
      "mutated_line": "(l, r) = lines[i - 1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(-1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while False:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][2] += 2",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 2\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][2] += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 0\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][2] += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 0\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][2] += -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += -1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(2, m):",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(2, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(0, m):",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(0, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(0, m):",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(0, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(-1, m):",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(-1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S == 0:",
      "mutated_line": "if S == 1:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 1:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S == 0:",
      "mutated_line": "if S == -1:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == -1:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S == 0:",
      "mutated_line": "if S == 1:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 1:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif S == wh2:",
      "mutated_line": "elif S != wh2:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S != wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "j = bisect_left(s, S, 0, m)",
      "mutated_line": "j = bisect_left(s, S, 1, m)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 1, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "j = bisect_left(s, S, 0, m)",
      "mutated_line": "j = bisect_left(s, S, -1, m)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, -1, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "j = bisect_left(s, S, 0, m)",
      "mutated_line": "j = bisect_left(s, S, 1, m)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 1, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 2\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 0\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 0\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= -1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][2], 2)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 2)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][2], 0)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 0)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][2], 0)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 0)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][2], -1)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], -1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j - 1 < m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j - 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j * 1 < m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j * 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 2\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 0\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 0\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += -1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "while s[j] - s[i] > S:",
      "mutated_line": "while s[j] - s[i] >= S:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] >= S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "while s[j] - s[i] > S:",
      "mutated_line": "while s[j] - s[i] <= S:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] <= S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "while s[j] - s[i] > S:",
      "mutated_line": "while s[j] - s[i] != S:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] != S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i -= 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 - 3 * S",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 3 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 - 1 * S",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 1 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 - 0 * S",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 0 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 - 1 * S",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 1 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = wh2 - 2 * S",
      "mutated_line": "S = wh2 - -2 * S",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - -2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[1, 0, 0, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[1, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[-1, 0, 0, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[-1, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[1, 0, 0, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[1, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, 1, 0, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 1, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, -1, 0, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, -1, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, 1, 0, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 1, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, 0, 1, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 1, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, 0, -1, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, -1, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, 0, 1, 0]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 1, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, 0, 0, 1]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 1]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, 0, 0, -1]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, -1]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tbl = [[0, 0, 0, 0]]",
      "mutated_line": "tbl = [[0, 0, 0, 1]]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 1]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "l, r = lines[i - 1]",
      "mutated_line": "(l, r) = lines[i + 1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i + 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "l, r = lines[i - 1]",
      "mutated_line": "(l, r) = lines[i * 1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i * 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s.append((l + r) * w)",
      "mutated_line": "s.append((l + r) / w)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) / w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s.append((l + r) * w)",
      "mutated_line": "s.append(l + r + w)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append(l + r + w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s.append((l + r) * w)",
      "mutated_line": "s.append((l + r) ** w)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) ** w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w - tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w - tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w * tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w * tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] * x / w - tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w - tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] * x / w * tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w * tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if y1 < y:",
      "mutated_line": "if y1 <= y:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 <= y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if y1 < y:",
      "mutated_line": "if y1 >= y:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 >= y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if y1 < y:",
      "mutated_line": "if y1 != y:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 != y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j -= 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j += 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][3] += 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][3] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][1] += 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][1] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][0] += 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][0] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][1] += 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][1] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tbl[j][2] += 1",
      "mutated_line": "tbl[j][-2] += 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][-2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][3] += tbl[i - 1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][3] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][1] += tbl[i - 1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][1] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][0] += tbl[i - 1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][0] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][1] += tbl[i - 1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][1] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][-2] += tbl[i - 1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][-2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - 1][3]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][3]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - 1][1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][1]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][0]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - 1][1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][1]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - 1][-2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][-2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 1\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return -1\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 1\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][3], 1)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][3], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][1], 1)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][1], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][0], 1)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][0], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][1], 1)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][1], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans, i = tbl[j][2], 1",
      "mutated_line": "(ans, i) = (tbl[j][-2], 1)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][-2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j + 2 < m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 2 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j + 0 < m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 0 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j + 0 < m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 0 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while j + 1 < m:",
      "mutated_line": "while j + -1 < m:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + -1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "while s[j] - s[i] > S:",
      "mutated_line": "while s[j] + s[i] > S:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] + s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "while s[j] - s[i] > S:",
      "mutated_line": "while s[j] * s[i] > S:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] * s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 2\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 0\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 0\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += -1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][2] + tbl[i][2])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] + tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][2] * tbl[i][2])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] * tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "l, r = lines[i - 1]",
      "mutated_line": "(l, r) = lines[i - 2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 2]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "l, r = lines[i - 1]",
      "mutated_line": "(l, r) = lines[i - 0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 0]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "l, r = lines[i - 1]",
      "mutated_line": "(l, r) = lines[i - 0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 0]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "l, r = lines[i - 1]",
      "mutated_line": "(l, r) = lines[i - -1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - -1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tbl.append([l, r, 0, r - l])",
      "mutated_line": "tbl.append([l, r, 1, r - l])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 1, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tbl.append([l, r, 0, r - l])",
      "mutated_line": "tbl.append([l, r, -1, r - l])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, -1, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tbl.append([l, r, 0, r - l])",
      "mutated_line": "tbl.append([l, r, 1, r - l])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 1, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tbl.append([l, r, 0, r - l])",
      "mutated_line": "tbl.append([l, r, 0, r + l])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r + l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tbl.append([l, r, 0, r - l])",
      "mutated_line": "tbl.append([l, r, 0, r * l])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r * l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s.append((l + r) * w)",
      "mutated_line": "s.append((l - r) * w)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l - r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s.append((l + r) * w)",
      "mutated_line": "s.append(l * r * w)",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append(l * r * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x * w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x * w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x // w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x // w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] * x * w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x * w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] * x // w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x // w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if y < y2:",
      "mutated_line": "if y <= y2:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y <= y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if y < y2:",
      "mutated_line": "if y >= y2:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y >= y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if y < y2:",
      "mutated_line": "if y != y2:",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y != y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 2\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 0\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 0\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += -1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 2\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 0\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 0\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= -1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i + 1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i + 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i * 1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i * 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] / x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] / x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = (tbl[j - 1][3] + x) / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = (tbl[j - 1][3] + x) / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] ** x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] ** x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][1]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][-1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][-1]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][1]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] / x / w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] / x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = (tbl[j][3] + x) / w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = (tbl[j][3] + x) / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] ** x / w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] ** x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] * x / w + tbl[j][1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][1]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] * x / w + tbl[j][-1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][-1]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][3] * x / w + tbl[j][1]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][1]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - 2][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 2][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - 0][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 0][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - 0][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 0][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tbl[i][2] += tbl[i - 1][2]",
      "mutated_line": "tbl[i][2] += tbl[i - -1][2]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - -1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][3] - tbl[i][2])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][3] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][1] - tbl[i][2])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][1] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][0] - tbl[i][2])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][0] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][1] - tbl[i][2])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][1] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][-2] - tbl[i][2])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][-2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][2] - tbl[i][3])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][3])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][2] - tbl[i][1])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][1])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][2] - tbl[i][0])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][0])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][2] - tbl[i][1])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][1])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = max(ans, tbl[j][2] - tbl[i][2])",
      "mutated_line": "ans = max(ans, tbl[j][2] - tbl[i][-2])",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][-2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "almonds.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "almonds.sort(key=lambda x: (x[2], x[0]))",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[2], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "almonds.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "almonds.sort(key=lambda x: (x[0], x[0]))",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[0], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "almonds.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "almonds.sort(key=lambda x: (x[0], x[0]))",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[0], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "almonds.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "almonds.sort(key=lambda x: (x[-1], x[0]))",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[-1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "almonds.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "almonds.sort(key=lambda x: (x[1], x[1]))",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[1]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "almonds.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "almonds.sort(key=lambda x: (x[1], x[-1]))",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[-1]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "almonds.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "almonds.sort(key=lambda x: (x[1], x[1]))",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[1]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j + 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j + 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j * 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j * 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][4] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][4] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][2] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][2] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][0] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][0] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][1] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][1] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][-3] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][-3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 2][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 2][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 0][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 0][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 0][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 0][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - -1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - -1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][4] * x / w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][4] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][2] * x / w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][2] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][0] * x / w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][0] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][1] * x / w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][1] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "y2 = tbl[j][3] * x / w + tbl[j][0]",
      "mutated_line": "y2 = tbl[j][-3] * x / w + tbl[j][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][-3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j + 1][3] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j + 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j * 1][3] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j * 1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 2][3] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 2][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 0][3] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 0][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - 0][3] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - 0][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "y1 = tbl[j - 1][3] * x / w + tbl[j - 1][0]",
      "mutated_line": "y1 = tbl[j - -1][3] * x / w + tbl[j - 1][0]",
      "code": "from bisect import bisect_left\n\ndef minimum_almonds_for_beko(n, m, w, h, S, lines, almonds):\n    if n == 0:\n        return 0\n    m += 1\n    wh2 = 2 * (w * h)\n    S = wh2 - 2 * S\n    tbl = [[0, 0, 0, 0]]\n    s = [0]\n    for i in range(1, m):\n        (l, r) = lines[i - 1]\n        tbl.append([l, r, 0, r - l])\n        s.append((l + r) * w)\n    almonds.sort(key=lambda x: (x[1], x[0]))\n    j = 1\n    for i in range(n):\n        (x, y) = almonds[i]\n        while True:\n            y1 = tbl[j - -1][3] * x / w + tbl[j - 1][0]\n            y2 = tbl[j][3] * x / w + tbl[j][0]\n            if y1 < y:\n                if y < y2:\n                    break\n                j += 1\n            else:\n                j -= 1\n        tbl[j][2] += 1\n    for i in range(1, m):\n        tbl[i][2] += tbl[i - 1][2]\n    if S == 0:\n        return n\n    elif S == wh2:\n        return 0\n    j = bisect_left(s, S, 0, m)\n    if s[j] != S:\n        j -= 1\n    (ans, i) = (tbl[j][2], 1)\n    while j + 1 < m:\n        j += 1\n        while s[j] - s[i] > S:\n            i += 1\n        ans = max(ans, tbl[j][2] - tbl[i][2])\n    return n - ans"
    }
  ]
}