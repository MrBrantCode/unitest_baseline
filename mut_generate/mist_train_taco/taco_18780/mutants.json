{
  "task_id": "taco_18780",
  "entry_point": "find_winning_numbers",
  "mutant_count": 20,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(2, p + 1):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(2, p + 1):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(0, p + 1):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(0, p + 1):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(0, p + 1):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(0, p + 1):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(-1, p + 1):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(-1, p + 1):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(1, p - 1):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p - 1):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(1, p * 1):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p * 1):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(1, p + 2):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 2):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(1, p + 0):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 0):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(1, p + 0):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 0):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, p + 1):",
      "mutated_line": "for j in range(1, p + -1):",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + -1):\n        winning_numbers.append((k + 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append((k + 1) / j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append((k + 1) / j)\n    return winning_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append(k + 1 + j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append(k + 1 + j)\n    return winning_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append((k + 1) ** j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append((k + 1) ** j)\n    return winning_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append((k - 1) * j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append((k - 1) * j)\n    return winning_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append(k * 1 * j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append(k * 1 * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append((k + 2) * j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append((k + 2) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append((k + 0) * j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append((k + 0) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append((k + 0) * j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append((k + 0) * j)\n    return winning_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "winning_numbers.append((k + 1) * j)",
      "mutated_line": "winning_numbers.append((k + -1) * j)",
      "code": "def find_winning_numbers(p, k):\n    \"\"\"\n    Finds the p smallest numbers that can be used as N so that Ram will always win.\n\n    Parameters:\n    p (int): The number of smallest numbers to find.\n    k (int): The maximum number that can be subtracted.\n\n    Returns:\n    list: A list of p smallest integers that can be used as N to ensure Ram's win.\n    \"\"\"\n    winning_numbers = []\n    for j in range(1, p + 1):\n        winning_numbers.append((k + -1) * j)\n    return winning_numbers"
    }
  ]
}