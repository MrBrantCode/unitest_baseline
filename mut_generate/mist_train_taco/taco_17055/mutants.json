{
  "task_id": "taco_17055",
  "entry_point": "recover_xor_sum",
  "mutant_count": 265,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 or k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 or k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 != 1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 != 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % 2 != 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 != 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return +1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "elif n % k == 0:",
      "mutated_line": "elif n % k != 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k != 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n * 2 == 1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n * 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n + 2 == 1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n + 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 2 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 2 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 0 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 0 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 0 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 0 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == -1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == -1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k * 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k * 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k + 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k + 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % 2 == 1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 1:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % 2 == -1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == -1:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % 2 == 1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 1:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -2\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -0\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -0\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return --1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "elif n % k == 0:",
      "mutated_line": "elif n * k == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n * k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "elif n % k == 0:",
      "mutated_line": "elif n + k == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n + k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "elif n % k == 0:",
      "mutated_line": "elif n % k == 1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 1:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "elif n % k == 0:",
      "mutated_line": "elif n % k == -1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == -1:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "elif n % k == 0:",
      "mutated_line": "elif n % k == 1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 1:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "xor = 0",
      "mutated_line": "xor = 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 1\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "xor = 0",
      "mutated_line": "xor = -1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = -1\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "xor = 0",
      "mutated_line": "xor = 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 1\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 2\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 0\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 0\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = -1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = -1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while curr_idx <= n:",
      "mutated_line": "while curr_idx < n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx < n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while curr_idx <= n:",
      "mutated_line": "while curr_idx > n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx > n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while curr_idx <= n:",
      "mutated_line": "while curr_idx == n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx == n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 or n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 or n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(1, n + 1) if x in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 3 == 1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 3 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 1 == 1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 1 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 0 == 1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 0 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 1 == 1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 1 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % -2 == 1 and k % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % -2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % 3 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 3 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % 1 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 1 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % 0 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 0 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % 1 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 1 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n % 2 == 1 and k % 2 == 0:",
      "mutated_line": "if n % 2 == 1 and k % -2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % -2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "next_idx = curr_idx + k",
      "mutated_line": "next_idx = curr_idx - k",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx - k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "next_idx = curr_idx + k",
      "mutated_line": "next_idx = curr_idx * k",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx * k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 == k % 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 == k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n <= 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n <= 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n >= 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n >= 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n != 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n != 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xor = 0",
      "mutated_line": "xor = 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 1\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xor = 0",
      "mutated_line": "xor = -1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = -1\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xor = 0",
      "mutated_line": "xor = 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 1\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 2\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 0\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 0\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = -1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = -1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "kk = n - k",
      "mutated_line": "kk = n + k",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n + k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "kk = n - k",
      "mutated_line": "kk = n * k",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n * k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while False:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if curr_idx < n:",
      "mutated_line": "if curr_idx <= n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx <= n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if curr_idx < n:",
      "mutated_line": "if curr_idx >= n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx >= n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if curr_idx < n:",
      "mutated_line": "if curr_idx != n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx != n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "xor = 0",
      "mutated_line": "xor = 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 1\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "xor = 0",
      "mutated_line": "xor = -1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = -1\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "xor = 0",
      "mutated_line": "xor = 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 1\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 2\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 0\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = 0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 0\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "curr_idx = 1",
      "mutated_line": "curr_idx = -1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = -1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while False:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if curr_idx < n:",
      "mutated_line": "if curr_idx <= n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx <= n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if curr_idx < n:",
      "mutated_line": "if curr_idx >= n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx >= n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if curr_idx < n:",
      "mutated_line": "if curr_idx != n:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx != n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(2, n + 1) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(2, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(0, n + 1) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(0, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(0, n + 1) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(0, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(-1, n + 1) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(-1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(1, n - 1) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n - 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(1, n * 1) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n * 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n * 2 != k % 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n * 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n + 2 != k % 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n + 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k * 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k * 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k + 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k + 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n < 2 / k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 / k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n < 2 + k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 + k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n < 2 ** k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 ** k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "next_idx = curr_idx + kk",
      "mutated_line": "next_idx = curr_idx - kk",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx - kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "next_idx = curr_idx + kk",
      "mutated_line": "next_idx = curr_idx * kk",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx * kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk or (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk or (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx - (n - curr_idx + 1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx - (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx * ((n - curr_idx + 1) // 2)",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx * ((n - curr_idx + 1) // 2)\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "curr_arr = list(range(curr_idx, next_idx)) + arr",
      "mutated_line": "curr_arr = list(range(curr_idx, next_idx)) - arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) - arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "curr_arr = list(range(curr_idx, next_idx)) + arr",
      "mutated_line": "curr_arr = list(range(curr_idx, next_idx)) * arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) * arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 1)) - arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) - arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 1)) * arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) * arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "next_idx = curr_idx + k",
      "mutated_line": "next_idx = curr_idx - k",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx - k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "next_idx = curr_idx + k",
      "mutated_line": "next_idx = curr_idx * k",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx * k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k or (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k or (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx - (n - curr_idx + 1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx - (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx * ((n - curr_idx + 1) // 2)",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx * ((n - curr_idx + 1) // 2)\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "curr_arr = list(range(curr_idx, next_idx)) + arr",
      "mutated_line": "curr_arr = list(range(curr_idx, next_idx)) - arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) - arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "curr_arr = list(range(curr_idx, next_idx)) + arr",
      "mutated_line": "curr_arr = list(range(curr_idx, next_idx)) * arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) * arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 1)) - arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) - arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 1)) * arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) * arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(1, n + 2) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 2) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(1, n + 0) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 0) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(1, n + 0) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 0) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return [x for x in range(1, n + 1) if x not in req]",
      "mutated_line": "return [x for x in range(1, n + -1) if x not in req]",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + -1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 3 != k % 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 3 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 1 != k % 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 1 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 0 != k % 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 0 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 1 != k % 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 1 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % -2 != k % 2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % -2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 3 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 3 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 1 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 1 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 0 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 0 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 1 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 1 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % -2 and n < 2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % -2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n < 3 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 3 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n < 1 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 1 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n < 0 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 0 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n < 1 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 1 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif n % 2 != k % 2 and n < 2 * k:",
      "mutated_line": "elif n % 2 != k % 2 and n < -2 * k:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < -2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 <= 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 <= 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 >= 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 >= 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 != 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 != 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 != 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 != 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) / 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) / 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) * 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) * 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 <= 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 <= 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 >= 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 >= 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 != 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 != 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 != 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 != 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) / 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) / 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) * 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) * 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx - 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx - 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if (n - curr_idx) * 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if (n - curr_idx) * 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 / kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 / kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 + kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 + kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 ** kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 ** kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) * 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) * 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and n - curr_idx + 1 + 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and n - curr_idx + 1 + 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 1:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == -1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == -1:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 1:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(2, kk + 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(2, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(0, kk + 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(0, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(0, kk + 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(0, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(-1, kk + 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(-1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(1, kk - 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk - 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(1, kk * 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk * 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx - 1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx - 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx) * 1 // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx) * 1 // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // 3",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 3\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 1\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // 0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 0\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 1\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // -2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // -2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx - 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx - 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if (n - curr_idx) * 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if (n - curr_idx) * 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 / k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 / k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 + k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 + k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 ** k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 ** k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) * 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) * 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and n - curr_idx + 1 + 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and n - curr_idx + 1 + 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 1:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == -1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == -1:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 1:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 1:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(2, k + 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(2, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(0, k + 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(0, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(0, k + 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(0, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(-1, k + 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(-1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(1, k - 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k - 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(1, k * 1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k * 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx - 1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx - 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx) * 1 // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx) * 1 // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // 3",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 3\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 1\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // 0",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 0\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // 1",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 1\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 1) // -2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // -2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n + curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n + curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n * curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n * curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 2 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 2 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 0 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 0 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 0 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 0 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + -1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + -1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 3 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 3 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 1 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 1 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 0 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 0 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 1 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 1 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < -2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < -2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx - 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx - 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx) * 1 % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx) * 1 % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 3 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 3 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 1 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 1 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 0 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 0 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 1 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 1 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % -2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % -2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(1, kk + 2))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 2))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(1, kk + 0))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 0))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(1, kk + 0))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 0))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "arr = list(range(1, kk + 1))",
      "mutated_line": "arr = list(range(1, kk + -1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + -1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n + curr_idx + 1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n + curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n * curr_idx + 1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n * curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 2) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 2) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 0) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 0) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 0) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 0) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + -1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + -1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n - 1)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n - 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n * 1)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n * 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n + curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n + curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n * curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n * curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 2 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 2 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 0 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 0 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 0 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 0 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + -1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + -1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 3 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 3 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 1 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 1 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 0 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 0 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 1 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 1 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < -2 * k and (n - curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < -2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx - 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx - 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx) * 1 % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx) * 1 % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 3 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 3 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 1 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 1 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 0 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 0 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 1 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 1 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % -2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % -2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(1, k + 2))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 2))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(1, k + 0))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 0))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(1, k + 0))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 0))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "arr = list(range(1, k + 1))",
      "mutated_line": "arr = list(range(1, k + -1))",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + -1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n + curr_idx + 1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n + curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n * curr_idx + 1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n * curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 2) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 2) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 0) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 0) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + 0) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 0) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "next_idx = curr_idx + (n - curr_idx + 1) // 2",
      "mutated_line": "next_idx = curr_idx + (n - curr_idx + -1) // 2",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + -1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n - 1)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n - 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n * 1)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n * 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n + curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n + curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n * curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n * curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 2) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 2) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 0) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 0) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 0) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 0) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * kk and (n - curr_idx + -1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + -1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 2)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 2)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 0)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 0)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 0)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 0)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + -1)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + -1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n + curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n + curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n * curr_idx + 1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n * curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 2) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 2) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 0) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 0) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 0) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 0) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:",
      "mutated_line": "if n - curr_idx + 1 < 2 * k and (n - curr_idx + -1) % 2 == 0:",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + -1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 2)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 2)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 0)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 0)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + 0)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + 0)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "curr_arr = list(range(next_idx, n + 1)) + arr",
      "mutated_line": "curr_arr = list(range(next_idx, n + -1)) + arr",
      "code": "def recover_xor_sum(n, k, query_function):\n    if n % 2 == 1 and k % 2 == 0:\n        return -1\n    elif n % k == 0:\n        xor = 0\n        curr_idx = 1\n        while curr_idx <= n:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n        return xor\n    elif n % 2 != k % 2 and n < 2 * k:\n        xor = 0\n        curr_idx = 1\n        kk = n - k\n        while True:\n            next_idx = curr_idx + kk\n            curr_arr = reverse(n, set(range(curr_idx, next_idx)))\n            xor ^= query_function(curr_arr)\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * kk and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, kk + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n            curr_arr = list(range(next_idx, n + 1)) + arr\n            curr_arr = reverse(n, set(curr_arr[:kk]))\n            xor ^= query_function(curr_arr)\n        return xor\n    else:\n        xor = 0\n        curr_idx = 1\n        while True:\n            next_idx = curr_idx + k\n            xor ^= query_function(list(range(curr_idx, next_idx)))\n            curr_idx = next_idx\n            if n - curr_idx + 1 < 2 * k and (n - curr_idx + 1) % 2 == 0:\n                break\n        if curr_idx < n:\n            arr = list(range(1, k + 1))\n            next_idx = curr_idx + (n - curr_idx + 1) // 2\n            curr_arr = list(range(curr_idx, next_idx)) + arr\n            xor ^= query_function(curr_arr[:k])\n            curr_arr = list(range(next_idx, n + -1)) + arr\n            xor ^= query_function(curr_arr[:k])\n        return xor\n\ndef reverse(n, req):\n    return [x for x in range(1, n + 1) if x not in req]"
    }
  ]
}