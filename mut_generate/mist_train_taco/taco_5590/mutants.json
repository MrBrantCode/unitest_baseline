{
  "task_id": "taco_5590",
  "entry_point": "sieve",
  "mutant_count": 53,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "PRIMES = sieve(100000)",
      "mutated_line": "PRIMES = sieve(100001)",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100001)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "PRIMES = sieve(100000)",
      "mutated_line": "PRIMES = sieve(99999)",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(99999)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "PRIMES = sieve(100000)",
      "mutated_line": "PRIMES = sieve(0)",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(0)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "PRIMES = sieve(100000)",
      "mutated_line": "PRIMES = sieve(1)",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(1)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "PRIMES = sieve(100000)",
      "mutated_line": "PRIMES = sieve(-100000)",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(-100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] / (n + 1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] / (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] + (n + 1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] + (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] ** (n + 1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] ** (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(3, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(1, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(0, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(1, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(-2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n - 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n * 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "mutated_line": "divs = [p * q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p * q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "mutated_line": "divs = [p // q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p // q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] * (n - 1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n - 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] * (n * 1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n * 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 2):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 0):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 0):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + -1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([1] * (n + 1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([1] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([-1] * (n + 1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([-1] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([1] * (n + 1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([1] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] * (n + 2), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 2), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] * (n + 0), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 0), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] * (n + 0), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 0), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(sieve, primes) = ([0] * (n + 1), [])",
      "mutated_line": "(sieve, primes) = ([0] * (n + -1), [])",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + -1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i * 2, n + 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i * 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i + 2, n + 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i + 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 2, n - 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n - 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 2, n * 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n * 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[j] = 1",
      "mutated_line": "sieve[j] = 2",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 2\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[j] = 1",
      "mutated_line": "sieve[j] = 0",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 0\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[j] = 1",
      "mutated_line": "sieve[j] = 0",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 0\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[j] = 1",
      "mutated_line": "sieve[j] = -1",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = -1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 3, n + 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 3, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 1, n + 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 1, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 0, n + 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 0, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 1, n + 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 1, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** -2, n + 1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** -2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 2, n + 2, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 2, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 2, n + 0, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 0, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 2, n + 0, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 0, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(i ** 2, n + 1, i):",
      "mutated_line": "for j in range(i ** 2, n + -1, i):",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + -1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "mutated_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i - 1:]]",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i - 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "mutated_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i * 1:]]",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i * 1:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "mutated_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 2:]]",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 2:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "mutated_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 0:]]",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 0:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "mutated_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 0:]]",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 0:]]\n    return (len(divs), int(sum(divs)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + 1:]]",
      "mutated_line": "divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + -1:]]",
      "code": "from bisect import bisect_left\n\ndef sieve(n):\n    (sieve, primes) = ([0] * (n + 1), [])\n    for i in range(2, n + 1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i ** 2, n + 1, i):\n                sieve[j] = 1\n    return primes\nPRIMES = sieve(100000)\n\ndef count_prime_primes_and_sum(N):\n    lst = PRIMES[:bisect_left(PRIMES, N)]\n    divs = [p / q for (i, p) in enumerate(lst) for q in lst[i + -1:]]\n    return (len(divs), int(sum(divs)))"
    }
  ]
}