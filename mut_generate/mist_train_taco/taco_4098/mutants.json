{
  "task_id": "taco_4098",
  "entry_point": "max_mean_and_ways",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "max_mean = sum(values[:A]) / A",
      "mutated_line": "max_mean = sum(values[:A]) * A",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) * A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "max_mean = sum(values[:A]) / A",
      "mutated_line": "max_mean = sum(values[:A]) // A",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) // A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[0] == values[A - 1]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] == values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "a = 1",
      "mutated_line": "a = 2",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 2\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "a = 1",
      "mutated_line": "a = 0",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 0\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "a = 1",
      "mutated_line": "a = 0",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 0\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "a = 1",
      "mutated_line": "a = -1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = -1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = 1",
      "mutated_line": "b = 2",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 2\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = 1",
      "mutated_line": "b = 0",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 0\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = 1",
      "mutated_line": "b = 0",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 0\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = 1",
      "mutated_line": "b = -1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = -1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a /= n - i + 1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a /= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "b *= i",
      "mutated_line": "b /= i",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b /= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return a // b",
      "mutated_line": "return a / b",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a / b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return a // b",
      "mutated_line": "return a * b",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a * b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "num_ways = 0",
      "mutated_line": "num_ways = 1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 1\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "num_ways = 0",
      "mutated_line": "num_ways = -1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = -1\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "num_ways = 0",
      "mutated_line": "num_ways = 1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 1\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "num_ways += combination(c, i)",
      "mutated_line": "num_ways -= combination(c, i)",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways -= combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "values.sort(reverse=True)",
      "mutated_line": "values.sort(reverse=False)",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=False)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "c = values.count(values[A - 1])",
      "mutated_line": "c = values.count(values[A + 1])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A + 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "c = values.count(values[A - 1])",
      "mutated_line": "c = values.count(values[A * 1])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A * 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "d = values[:A].count(values[A - 1])",
      "mutated_line": "d = values[:A].count(values[A + 1])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A + 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "d = values[:A].count(values[A - 1])",
      "mutated_line": "d = values[:A].count(values[A * 1])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A * 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(2, r + 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(2, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(0, r + 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(0, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(0, r + 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(0, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(-1, r + 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(-1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(1, r - 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r - 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(1, r * 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r * 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a *= n - i - 1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i - 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a *= (n - i) * 1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= (n - i) * 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[1] != values[A - 1]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[1] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[-1] != values[A - 1]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[-1] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[1] != values[A - 1]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[1] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[0] != values[A + 1]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A + 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[0] != values[A * 1]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A * 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B - A + d) - 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) - 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B - A + d) * 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) * 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = values.count(values[A - 1])",
      "mutated_line": "c = values.count(values[A - 2])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 2])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = values.count(values[A - 1])",
      "mutated_line": "c = values.count(values[A - 0])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 0])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = values.count(values[A - 1])",
      "mutated_line": "c = values.count(values[A - 0])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 0])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = values.count(values[A - 1])",
      "mutated_line": "c = values.count(values[A - -1])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - -1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d = values[:A].count(values[A - 1])",
      "mutated_line": "d = values[:A].count(values[A - 2])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 2])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d = values[:A].count(values[A - 1])",
      "mutated_line": "d = values[:A].count(values[A - 0])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 0])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d = values[:A].count(values[A - 1])",
      "mutated_line": "d = values[:A].count(values[A - 0])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 0])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d = values[:A].count(values[A - 1])",
      "mutated_line": "d = values[:A].count(values[A - -1])",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - -1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(1, r + 2):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 2):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(1, r + 0):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 0):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(1, r + 0):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 0):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, r + 1):",
      "mutated_line": "for i in range(1, r + -1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + -1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a *= n + i + 1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n + i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a *= n * i + 1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n * i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a *= n - i + 2",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 2\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a *= n - i + 0",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 0\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a *= n - i + 0",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 0\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a *= n - i + 1",
      "mutated_line": "a *= n - i + -1",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + -1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[0] != values[A - 2]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 2]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[0] != values[A - 0]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 0]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[0] != values[A - 0]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 0]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if values[0] != values[A - 1]:",
      "mutated_line": "if values[0] != values[A - -1]:",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - -1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B - A + d) + 2):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 2):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B - A + d) + 0):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 0):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B - A + d) + 0):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + 0):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B - A + d) + -1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A + d) + -1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B - A - d) + 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B - A - d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, (B - A) * d) + 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, (B - A) * d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B + A + d) + 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B + A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(d, min(c, B - A + d) + 1):",
      "mutated_line": "for i in range(d, min(c, B * A + d) + 1):",
      "code": "def max_mean_and_ways(N, A, B, values):\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    c = values.count(values[A - 1])\n    d = values[:A].count(values[A - 1])\n\n    def combination(n, r):\n        a = 1\n        b = 1\n        for i in range(1, r + 1):\n            a *= n - i + 1\n            b *= i\n        return a // b\n    if values[0] != values[A - 1]:\n        num_ways = combination(c, d)\n    else:\n        num_ways = 0\n        for i in range(d, min(c, B * A + d) + 1):\n            num_ways += combination(c, i)\n    return (max_mean, num_ways)"
    }
  ]
}