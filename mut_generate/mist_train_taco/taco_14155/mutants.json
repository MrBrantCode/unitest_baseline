{
  "task_id": "taco_14155",
  "entry_point": "max_orbs_without_exploding",
  "mutant_count": 133,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][1] = [grid[0][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][1] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][-1] = [grid[0][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][-1] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][1] = [grid[0][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][1] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, M):",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(2, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, M):",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(0, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, M):",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(0, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, M):",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(-1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, N):",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(2, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, N):",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(0, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, N):",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(0, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, N):",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(-1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(2, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(0, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(0, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(-1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 1][M + 1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M + 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 1][M * 1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M * 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if max(ans) > K:",
      "mutated_line": "if max(ans) >= K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) >= K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if max(ans) > K:",
      "mutated_line": "if max(ans) <= K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) <= K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if max(ans) > K:",
      "mutated_line": "if max(ans) != K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) != K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return +1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[1][0] = [grid[0][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[1][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[-1][0] = [grid[0][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[-1][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[1][0] = [grid[0][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[1][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][0] = [grid[0][1]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][1]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][0] = [grid[0][-1]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][-1]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][0] = [grid[0][1]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][1]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] - grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] - grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] * grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] * grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][1] = [table[i - 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][1] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][-1] = [table[i - 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][-1] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][1] = [table[i - 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][1] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] - grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] - grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] * grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] * grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(1, M):",
      "mutated_line": "for j in range(2, M):",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(2, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(1, M):",
      "mutated_line": "for j in range(0, M):",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(0, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(1, M):",
      "mutated_line": "for j in range(0, M):",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(0, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(1, M):",
      "mutated_line": "for j in range(-1, M):",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(-1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N + 1][M - 1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N + 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N * 1][M - 1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N * 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 1][M - 2]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 2]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 1][M - 0]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 0]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 1][M - 0]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 0]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 1][M - -1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - -1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return +1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return --1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][0] = [grid[1][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[1][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][0] = [grid[-1][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[-1][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "table[0][0] = [grid[0][0]]",
      "mutated_line": "table[0][0] = [grid[1][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[1][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[1][j] = [table[0][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[1][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[-1][j] = [table[0][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[-1][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[1][j] = [table[0][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[1][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for v in table[i][j-1]:",
      "mutated_line": "for v in table[i][j + 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j + 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for v in table[i][j-1]:",
      "mutated_line": "for v in table[i][j * 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j * 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tmp = val + v",
      "mutated_line": "tmp = val + v",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val - v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tmp = val + v",
      "mutated_line": "tmp = val + v",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val * v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp <= K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp < K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp <= K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp > K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp <= K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp == K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "tmp = val + v",
      "mutated_line": "tmp = val + v",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val - v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "tmp = val + v",
      "mutated_line": "tmp = val + v",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val * v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp <= K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp < K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp <= K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp > K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp <= K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp == K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 1][j + 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j + 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 1][j * 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j * 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = val + v",
      "mutated_line": "tmp = val - v",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val - v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = val + v",
      "mutated_line": "tmp = val * v",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val * v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp < K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp < K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp > K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp > K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if tmp <= K:",
      "mutated_line": "if tmp == K:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp == K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 2][M - 1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 2][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 0][M - 1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 0][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - 0][M - 1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 0][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = table[N-1][M-1]",
      "mutated_line": "ans = table[N - -1][M - 1]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - -1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -2\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -0\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -0\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return --1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 1][1] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][1] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 1][-1] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][-1] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 1][1] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][1] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][0][1] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][1] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][0][-1] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][-1] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][0][1] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][1] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] + grid[i][1]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][1]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] + grid[i][-1]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][-1]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][0][0] + grid[i][1]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][1]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for v in table[i][j-1]:",
      "mutated_line": "for v in table[i][j - 2]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 2]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for v in table[i][j-1]:",
      "mutated_line": "for v in table[i][j - 0]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 0]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for v in table[i][j-1]:",
      "mutated_line": "for v in table[i][j - 0]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 0]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for v in table[i][j-1]:",
      "mutated_line": "for v in table[i][j - -1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - -1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for v in table[i-1][j]:",
      "mutated_line": "for v in table[i + 1][j]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i + 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for v in table[i-1][j]:",
      "mutated_line": "for v in table[i * 1][j]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i * 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i + 1][j - 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i + 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i * 1][j - 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i * 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 1][j - 2]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 2]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 1][j - 0]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 0]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 1][j - 0]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 0]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 1][j - -1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - -1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j + 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j + 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j * 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j * 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] + grid[1][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[1][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] + grid[-1][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[-1][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 1][0] + grid[1][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[1][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][1][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][1][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][-1][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][-1][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 1][1][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][1][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in table[i-1][j]:",
      "mutated_line": "for v in table[i - 2][j]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 2][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in table[i-1][j]:",
      "mutated_line": "for v in table[i - 0][j]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 0][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in table[i-1][j]:",
      "mutated_line": "for v in table[i - 0][j]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 0][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in table[i-1][j]:",
      "mutated_line": "for v in table[i - -1][j]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - -1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 2][j - 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 2][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 0][j - 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 0][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - 0][j - 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 0][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for v in table[i-1][j-1]:",
      "mutated_line": "for v in table[i - -1][j - 1]:",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - -1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[1][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[1][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[-1][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[-1][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[1][j - 1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[1][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 2][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 2][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 0][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 0][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - 0][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 0][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "table[0][j] = [table[0][j-1][0] + grid[0][j]]",
      "mutated_line": "table[0][j] = [table[0][j - -1][0] + grid[0][j]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - -1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i + 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i + 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i * 1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i * 1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 2][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 2][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 0][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 0][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - 0][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - 0][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "table[i][0] = [table[i-1][0][0] + grid[i][0]]",
      "mutated_line": "table[i][0] = [table[i - -1][0][0] + grid[i][0]]",
      "code": "def max_orbs_without_exploding(N, M, K, grid):\n    \"\"\"\n    Calculate the maximum number of orbs Gudi can absorb without exploding.\n\n    Parameters:\n    - N (int): Number of rows in the grid.\n    - M (int): Number of columns in the grid.\n    - K (int): Maximum number of orbs Gudi can absorb without exploding.\n    - grid (list of lists): The grid containing the number of orbs in each cell.\n\n    Returns:\n    - int: The maximum number of orbs Gudi can absorb without exploding, or -1 if no such path exists.\n    \"\"\"\n    table = [[[] for _ in range(M)] for _ in range(N)]\n    table[0][0] = [grid[0][0]]\n    for j in range(1, M):\n        table[0][j] = [table[0][j - 1][0] + grid[0][j]]\n    for i in range(1, N):\n        table[i][0] = [table[i - -1][0][0] + grid[i][0]]\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = set()\n            val = grid[i][j]\n            for v in table[i][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            for v in table[i - 1][j - 1]:\n                tmp = val + v\n                if tmp <= K:\n                    ans.add(tmp)\n            table[i][j] = sorted(ans)\n    ans = table[N - 1][M - 1]\n    if ans:\n        if max(ans) > K:\n            return -1\n        else:\n            return max(ans)\n    else:\n        return -1"
    }
  ]
}