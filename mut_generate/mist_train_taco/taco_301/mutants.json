{
  "task_id": "taco_301",
  "entry_point": "find_shortest_path",
  "mutant_count": 60,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] - [[[i - 1, 0]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] - [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] * [[[i - 1, 0]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] * [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] / (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] / (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] + (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] + (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] ** (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] ** (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "inf = float('inf')",
      "mutated_line": "inf = float('')",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] * (N - 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N - 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] * (N * 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N * 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if flag[x] != inf:",
      "mutated_line": "if flag[x] == inf:",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] == inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if flag[N] != inf:",
      "mutated_line": "if flag[N] == inf:",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] == inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "return flag[N] if flag[N] != inf else -1",
      "mutated_line": "return flag[N] if flag[N] == inf else -1",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] == inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "return flag[N] if flag[N] != inf else -1",
      "mutated_line": "return flag[N] if flag[N] != inf else +1",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else +1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[0, 1]]",
      "mutated_line": "dist = [[1, 1]]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[1, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[0, 1]]",
      "mutated_line": "dist = [[-1, 1]]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[-1, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[0, 1]]",
      "mutated_line": "dist = [[1, 1]]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[1, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[0, 1]]",
      "mutated_line": "dist = [[0, 2]]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 2]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[0, 1]]",
      "mutated_line": "dist = [[0, 0]]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 0]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[0, 1]]",
      "mutated_line": "dist = [[0, 0]]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 0]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[0, 1]]",
      "mutated_line": "dist = [[0, -1]]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, -1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] * (N + 2)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 2)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 0)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 0)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flag = [inf] * (N + 1)",
      "mutated_line": "flag = [inf] * (N + -1)",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + -1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if flag[u[0]] == inf:",
      "mutated_line": "if flag[u[0]] != inf:",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] != inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return flag[N] if flag[N] != inf else -1",
      "mutated_line": "return flag[N] if flag[N] != inf else -2",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return flag[N] if flag[N] != inf else -1",
      "mutated_line": "return flag[N] if flag[N] != inf else -0",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return flag[N] if flag[N] != inf else -1",
      "mutated_line": "return flag[N] if flag[N] != inf else -0",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return flag[N] if flag[N] != inf else -1",
      "mutated_line": "return flag[N] if flag[N] != inf else --1",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else --1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i + 1, 0]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i + 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i * 1, 0]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i * 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 1]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 1]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, -1]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, -1]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 1]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 1]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(3, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(3, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(1, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(1, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(0, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(0, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(1, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(1, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(-2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(-2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N - 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N - 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N * 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N * 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 2, 0]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 2, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 0, 0]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 0, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 0, 0]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 0, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - -1, 0]] for i in range(2, N + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - -1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 2)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 2)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 0)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 0)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 0)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 0)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]",
      "mutated_line": "data = [[], []] + [[[i - 1, 0]] for i in range(2, N + -1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + -1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if flag[u[0]] == inf:",
      "mutated_line": "if flag[u[1]] == inf:",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[1]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if flag[u[0]] == inf:",
      "mutated_line": "if flag[u[-1]] == inf:",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[-1]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if flag[u[0]] == inf:",
      "mutated_line": "if flag[u[1]] == inf:",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[1]] == inf:\n                heappush(dist, [y + u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y - u[1], u[0]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y - u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y * u[1], u[0]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y * u[1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y + u[1], u[1]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[1]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y + u[1], u[-1]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[-1]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y + u[1], u[1]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[1], u[1]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y + u[2], u[0]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[2], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y + u[0], u[0]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[0], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y + u[0], u[0]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[0], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "heappush(dist, [y + u[1], u[0]])",
      "mutated_line": "heappush(dist, [y + u[-1], u[0]])",
      "code": "from heapq import heappush, heappop\n\ndef find_shortest_path(N, M, LRC):\n    data = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\n    for (L, R, C) in LRC:\n        data[L].append([R, C])\n    dist = [[0, 1]]\n    inf = float('inf')\n    flag = [inf] * (N + 1)\n    while dist:\n        (y, x) = heappop(dist)\n        if flag[x] != inf:\n            continue\n        flag[x] = y\n        for u in data[x]:\n            if flag[u[0]] == inf:\n                heappush(dist, [y + u[-1], u[0]])\n        if flag[N] != inf:\n            break\n    return flag[N] if flag[N] != inf else -1"
    }
  ]
}