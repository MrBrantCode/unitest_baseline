{
  "task_id": "taco_2286",
  "entry_point": "calculate_max_profit",
  "mutant_count": 263,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 * N - 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N - 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 * N * 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N * 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "start = 3 * N",
      "mutated_line": "start = 3 / N",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 / N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "start = 3 * N",
      "mutated_line": "start = 3 + N",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 + N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "start = 3 * N",
      "mutated_line": "start = 3 ** N",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 ** N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 * N - 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N - 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 * N * 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N * 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x += 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y += 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y += 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ANS = 0",
      "mutated_line": "ANS = 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 1\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ANS = 0",
      "mutated_line": "ANS = -1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = -1\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ANS = 0",
      "mutated_line": "ANS = 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 1\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while False:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "ANS += cost",
      "mutated_line": "ANS -= cost",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS -= cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "return -(ANS - (N << 30))",
      "mutated_line": "return +(ANS - (N << 30))",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return +(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 / N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 / N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 + N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 + N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 ** N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 ** N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 * N + 3",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 3\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 * N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 1\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 * N + 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 0\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 * N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 1\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 3 * N + -2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + -2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "start = 3 * N",
      "mutated_line": "start = 4 * N",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 4 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "start = 3 * N",
      "mutated_line": "start = 2 * N",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 2 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "start = 3 * N",
      "mutated_line": "start = 0 * N",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 0 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "start = 3 * N",
      "mutated_line": "start = 1 * N",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 1 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "start = 3 * N",
      "mutated_line": "start = -3 * N",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = -3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 / N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 / N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 + N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 + N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 ** N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 ** N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 * N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 2\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 * N + 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 0\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 * N + 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 0\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 3 * N + -1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + -1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] - (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] - (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] * (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] * (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] - (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] - (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] * (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] * (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] - (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] - (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] * (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] * (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 2\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 0\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 0\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= -1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y -= 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 2\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 0\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 0\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y -= -1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= -1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "USED = [0] * V",
      "mutated_line": "USED = [0] / V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] / V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "USED = [0] * V",
      "mutated_line": "USED = [0] + V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] + V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "USED = [0] * V",
      "mutated_line": "USED = [0] ** V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] ** V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ROUTE = [-1] * V",
      "mutated_line": "ROUTE = [-1] / V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] / V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ROUTE = [-1] * V",
      "mutated_line": "ROUTE = [-1] + V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] + V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ROUTE = [-1] * V",
      "mutated_line": "ROUTE = [-1] ** V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] ** V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i != start:",
      "mutated_line": "while i == start:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i == start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "EDGE[j][i] -= cost",
      "mutated_line": "EDGE[j][i] += cost",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] += cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return -(ANS - (N << 30))",
      "mutated_line": "return -(ANS + (N << 30))",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS + (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return -(ANS - (N << 30))",
      "mutated_line": "return -(ANS * (N << 30))",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS * (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 4 * N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 4 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 2 * N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 2 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 0 * N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 0 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = 1 * N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 1 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "V = 3 * N + 2",
      "mutated_line": "V = -3 * N + 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = -3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 4 * N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 4 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 2 * N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 2 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 0 * N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 0 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = 1 * N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 1 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "goal = 3 * N + 1",
      "mutated_line": "goal = -3 * N + 1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = -3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 / i] = -B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 / i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 + i] = -B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 + i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 ** i] = -B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 ** i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = +B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = +B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i - 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i - 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i * 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i * 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i - 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i - 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i * 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i * 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 * i + 2][goal] = float('')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][3 / y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 / y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][3 + y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 + y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][3 ** y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 ** y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][3 * y] = float('')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][3 / x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 / x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][3 + x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 + x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][3 ** x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 ** x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][3 * x] = float('')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if NOW == goal:",
      "mutated_line": "if NOW != goal:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW != goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if j in EDGE[i]:",
      "mutated_line": "if j not in EDGE[i]:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j not in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "EDGE[i][j] += cost",
      "mutated_line": "EDGE[i][j] -= cost",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] -= cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 * N - 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N - 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 * N * 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N * 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][4 * i] = -B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][4 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][2 * i] = -B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][2 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][0 * i] = -B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][0 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][1 * i] = -B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][1 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][-3 * i] = -B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][-3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (2 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (2 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (0 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (0 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (0 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (0 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (-1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (-1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (1 << 31)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 31)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (1 << 29)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 29)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (1 << 0)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 0)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (1 << 1)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 1)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGE[start][3 * i] = -B[i] + (1 << 30)",
      "mutated_line": "EDGE[start][3 * i] = -B[i] + (1 << -30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << -30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 / i][3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 / i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 + i][3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 + i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 ** i][3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 ** i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 / i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 / i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 + i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 + i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 ** i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 ** i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 2] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 2] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 0] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 0] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 0] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 0] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + -1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + -1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (2 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (2 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (0 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (0 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (0 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (0 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (-1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (-1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 31)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 31)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 29)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 29)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 0)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 0)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 1)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 1)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << -30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << -30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i - 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i - 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i * 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i * 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 / i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 / i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 + i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 + i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 ** i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 ** i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 3] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 3] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 1] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 1] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 0] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 0] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 1] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 1] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + -2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + -2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (2 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (2 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (0 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (0 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (0 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (0 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (-1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (-1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 31)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 31)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 29)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 29)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 0)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 0)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 1)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 1)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << -30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << -30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 * i - 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i - 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 * i * 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i * 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x - 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x - 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x * 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x * 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][4 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][4 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][2 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][2 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][0 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][0 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][1 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][1 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 1][-3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][-3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y - 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y - 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y * 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y * 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][4 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][4 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][2 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][2 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][0 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][0 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][1 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][1 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 1][-3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][-3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "USED = [0] * V",
      "mutated_line": "USED = [1] * V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [1] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "USED = [0] * V",
      "mutated_line": "USED = [-1] * V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [-1] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "USED = [0] * V",
      "mutated_line": "USED = [1] * V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [1] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "ROUTE = [-1] * V",
      "mutated_line": "ROUTE = [+1] * V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [+1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] == 0 or EDGE[NOW][to] != 0:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 or EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -(ANS - (N << 30))",
      "mutated_line": "return -(ANS - (N << 31))",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 31))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -(ANS - (N << 30))",
      "mutated_line": "return -(ANS - (N << 29))",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 29))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -(ANS - (N << 30))",
      "mutated_line": "return -(ANS - (N << 0))",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 0))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -(ANS - (N << 30))",
      "mutated_line": "return -(ANS - (N << 1))",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 1))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -(ANS - (N << 30))",
      "mutated_line": "return -(ANS - (N << -30))",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << -30))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 / N + 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 / N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 + N + 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 + N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 ** N + 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 ** N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 * N + 3)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 3)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 * N + 1)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 1)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 * N + 0)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 0)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 * N + 1)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 1)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(3 * N + -2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + -2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[4 * i][3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[4 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[2 * i][3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[2 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[0 * i][3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[0 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[1 * i][3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[1 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[-3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[-3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][4 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][4 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][2 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][2 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][0 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][0 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][1 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][1 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i][-3 * i + 1] = A[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][-3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 / i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 / i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 + i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 + i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 ** i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 ** i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 2][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 2][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 0][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 0][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 0][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 0][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + -1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + -1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][4 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][4 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][2 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][2 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][0 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][0 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][1 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][1 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[3 * i + 1][-3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][-3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 / i + 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 / i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 + i + 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 + i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 ** i + 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 ** i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 * i + 3][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 3][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 * i + 1][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 1][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 * i + 0][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 0][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 * i + 1][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 1][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[3 * i + -2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + -2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 / x + 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 / x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 + x + 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 + x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 ** x + 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 ** x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 2][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 2][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 0][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 0][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + 0][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 0][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[3 * x + -1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + -1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 / y + 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 / y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 + y + 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 + y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 ** y + 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 ** y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 2][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 2][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 0][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 0][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + 0][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 0][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[3 * y + -1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + -1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ROUTE = [-1] * V",
      "mutated_line": "ROUTE = [-2] * V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-2] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ROUTE = [-1] * V",
      "mutated_line": "ROUTE = [-0] * V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-0] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ROUTE = [-1] * V",
      "mutated_line": "ROUTE = [-0] * V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-0] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ROUTE = [-1] * V",
      "mutated_line": "ROUTE = [--1] * V",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [--1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "Q = [(start, float('inf'))]",
      "mutated_line": "Q = [(start, float(''))]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float(''))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] != 0 and EDGE[NOW][to] != 0:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] != 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] == 0 and EDGE[NOW][to] == 0:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] == 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "USED[to] = 1",
      "mutated_line": "USED[to] = 2",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 2\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "USED[to] = 1",
      "mutated_line": "USED[to] = 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 0\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "USED[to] = 1",
      "mutated_line": "USED[to] = 0",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 0\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "USED[to] = 1",
      "mutated_line": "USED[to] = -1",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = -1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(4 * N + 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(4 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(2 * N + 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(2 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(0 * N + 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(0 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(1 * N + 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(1 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EDGE = [dict() for _ in range(3 * N + 2)]",
      "mutated_line": "EDGE = [dict() for _ in range(-3 * N + 2)]",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(-3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[4 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[4 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[2 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[2 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[0 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[0 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[1 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[1 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "mutated_line": "EDGE[-3 * i + 1][3 * i + 2] = B[i] + (1 << 30)",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[-3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[4 * i + 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[4 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[2 * i + 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[2 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[0 * i + 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[0 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[1 * i + 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[1 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "EDGE[3 * i + 2][goal] = float('inf')",
      "mutated_line": "EDGE[-3 * i + 2][goal] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[-3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[4 * x + 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[4 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[2 * x + 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[2 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[0 * x + 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[0 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[1 * x + 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[1 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "EDGE[3 * x + 1][3 * y] = float('inf')",
      "mutated_line": "EDGE[-3 * x + 1][3 * y] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[-3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[4 * y + 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[4 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[2 * y + 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[2 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[0 * y + 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[0 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[1 * y + 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[1 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "EDGE[3 * y + 1][3 * x] = float('inf')",
      "mutated_line": "EDGE[-3 * y + 1][3 * x] = float('inf')",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[-3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] == 1 and EDGE[NOW][to] != 0:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 1 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] == -1 and EDGE[NOW][to] != 0:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == -1 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] == 1 and EDGE[NOW][to] != 0:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 1 and EDGE[NOW][to] != 0:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] == 0 and EDGE[NOW][to] != 1:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 1:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] == 0 and EDGE[NOW][to] != -1:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != -1:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if USED[to] == 0 and EDGE[NOW][to] != 0:",
      "mutated_line": "if USED[to] == 0 and EDGE[NOW][to] != 1:",
      "code": "def calculate_max_profit(N, M, A, B, edges):\n    EDGE = [dict() for _ in range(3 * N + 2)]\n    V = 3 * N + 2\n    start = 3 * N\n    goal = 3 * N + 1\n    for i in range(N):\n        EDGE[start][3 * i] = -B[i] + (1 << 30)\n        EDGE[3 * i][3 * i + 1] = A[i] + (1 << 30)\n        EDGE[3 * i + 1][3 * i + 2] = B[i] + (1 << 30)\n        EDGE[3 * i + 2][goal] = float('inf')\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        EDGE[3 * x + 1][3 * y] = float('inf')\n        EDGE[3 * y + 1][3 * x] = float('inf')\n    ANS = 0\n    while True:\n        USED = [0] * V\n        ROUTE = [-1] * V\n        Q = [(start, float('inf'))]\n        while Q:\n            (NOW, cost) = Q.pop()\n            if NOW == goal:\n                break\n            for to in EDGE[NOW]:\n                if USED[to] == 0 and EDGE[NOW][to] != 1:\n                    ROUTE[to] = NOW\n                    USED[to] = 1\n                    Q.append((to, min(cost, EDGE[NOW][to])))\n        else:\n            break\n        ANS += cost\n        i = goal\n        while i != start:\n            j = ROUTE[i]\n            EDGE[j][i] -= cost\n            if j in EDGE[i]:\n                EDGE[i][j] += cost\n            else:\n                EDGE[i][j] = cost\n            i = j\n    return -(ANS - (N << 30))"
    }
  ]
}