{
  "task_id": "taco_18387",
  "entry_point": "minimum_cost_to_transform_sequence",
  "mutant_count": 77,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = True\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 1\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = -1\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 1\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "ans += 2 ** s",
      "mutated_line": "ans -= 2 ** s",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans -= 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] / (M + 1)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] / (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] + (M + 1)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] + (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] ** (M + 1)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] ** (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return True\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if a < b:",
      "mutated_line": "if a <= b:",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a <= b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if a < b:",
      "mutated_line": "if a >= b:",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a >= b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if a < b:",
      "mutated_line": "if a != b:",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a != b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(M, 0, -1):",
      "mutated_line": "for i in range(M, 1, -1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 1, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(M, 0, -1):",
      "mutated_line": "for i in range(M, -1, -1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, -1, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(M, 0, -1):",
      "mutated_line": "for i in range(M, 1, -1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 1, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for i in range(M, 0, -1):",
      "mutated_line": "for i in range(M, 0, +1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, +1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans += 2 ** s",
      "mutated_line": "ans += 2 * s",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 * s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans += 2 ** s",
      "mutated_line": "ans += 2 + s",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 + s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return +1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] * (M - 1)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M - 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] * (M * 1)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M * 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return +1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(M, 0, -1):",
      "mutated_line": "for i in range(M, 0, -2):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -2):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(M, 0, -1):",
      "mutated_line": "for i in range(M, 0, -0):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -0):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(M, 0, -1):",
      "mutated_line": "for i in range(M, 0, -0):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -0):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(M, 0, -1):",
      "mutated_line": "for i in range(M, 0, --1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, --1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(2, M + 1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(2, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(0, M + 1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(0, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(0, M + 1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(0, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(-1, M + 1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(-1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M - 1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M - 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M * 1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M * 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if a == b:",
      "mutated_line": "if a != b:",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a != b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = False\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans += 2 ** s",
      "mutated_line": "ans += 3 ** s",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 3 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans += 2 ** s",
      "mutated_line": "ans += 1 ** s",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 1 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans += 2 ** s",
      "mutated_line": "ans += 0 ** s",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 0 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans += 2 ** s",
      "mutated_line": "ans += 1 ** s",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 1 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans += 2 ** s",
      "mutated_line": "ans += -2 ** s",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += -2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [True] * (M + 1)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [True] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] * (M + 2)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 2)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] * (M + 0)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 0)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] * (M + 0)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 0)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False] * (M + 1)",
      "mutated_line": "visited = [False] * (M + -1)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + -1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited[p] = True",
      "mutated_line": "visited[p] = False",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = False\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -2\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -0\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -0\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return --1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(2, M + 1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(2, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(0, M + 1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(0, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(0, M + 1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(0, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(-1, M + 1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(-1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(1, M - 1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M - 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(1, M * 1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M * 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 2):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 2):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 0):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 0):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 0):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 0):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + -1):",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + -1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if q == b:",
      "mutated_line": "if q != b:",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q != b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(1, M + 2)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 2)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(1, M + 0)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 0)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(1, M + 0)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 0)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "S = [i for i in range(1, M + 1)]",
      "mutated_line": "S = [i for i in range(1, M + -1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + -1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "G = [set() for _ in range(M + 1)]",
      "mutated_line": "G = [set() for _ in range(M - 1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M - 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "G = [set() for _ in range(M + 1)]",
      "mutated_line": "G = [set() for _ in range(M * 1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M * 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "G[j].add(j % s)",
      "mutated_line": "G[j].add(j * s)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j * s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "G[j].add(j % s)",
      "mutated_line": "G[j].add(j + s)",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j + s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return False\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "G = [set() for _ in range(M + 1)]",
      "mutated_line": "G = [set() for _ in range(M + 2)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 2)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "G = [set() for _ in range(M + 1)]",
      "mutated_line": "G = [set() for _ in range(M + 0)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 0)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "G = [set() for _ in range(M + 1)]",
      "mutated_line": "G = [set() for _ in range(M + 0)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + 0)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "G = [set() for _ in range(M + 1)]",
      "mutated_line": "G = [set() for _ in range(M + -1)]",
      "code": "def minimum_cost_to_transform_sequence(N, A, B):\n\n    def inpl(seq):\n        return tuple(map(int, seq.split()))\n\n    def dfs(a, b, G):\n        visited = [False] * (M + 1)\n        Q = [a]\n        while Q:\n            p = Q.pop()\n            if visited[p]:\n                continue\n            else:\n                visited[p] = True\n                for q in G[p]:\n                    if q == b:\n                        return True\n                    if not visited[q]:\n                        Q.append(q)\n        return False\n    for (a, b) in zip(A, B):\n        if a < b:\n            return -1\n    M = max(max(A), max(B))\n    S = [i for i in range(1, M + 1)]\n    T = len(S)\n    found = False\n    for i in range(M, 0, -1):\n        del S[S.index(i)]\n        G = [set() for _ in range(M + -1)]\n        for j in range(1, M + 1):\n            for s in S:\n                G[j].add(j % s)\n        for (a, b) in zip(A, B):\n            if a == b:\n                continue\n            if not dfs(a, b, G):\n                S.append(i)\n                break\n        else:\n            found = True\n    ans = 0\n    for s in S:\n        ans += 2 ** s\n    if found:\n        return ans\n    else:\n        return -1"
    }
  ]
}