{
  "task_id": "taco_14031",
  "entry_point": "calculate_max_stable_tower",
  "mutant_count": 278,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if i != 0:",
      "mutated_line": "if i == 0:",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i == 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i != 0:",
      "mutated_line": "if i != 1:",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 1:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i != 0:",
      "mutated_line": "if i != -1:",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != -1:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i != 0:",
      "mutated_line": "if i != 1:",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 1:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][2]) * 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) * 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][2]) + 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) + 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m -= abs(bricks[j][0] - bricks[j][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m -= abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if z != n:",
      "mutated_line": "if z == n:",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z == n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) * 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) * 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) // 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) // 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) * 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) * 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) // 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) // 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 4",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 4\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 2",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 2\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 0",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 0\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 1",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 1\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][2]) ** -3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** -3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i + 1, -1, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i + 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i * 1, -1, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i * 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, +1, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, +1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, -1, +1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, +1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] - ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] - ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] * (((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3)))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] * (((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3)))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] - ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] - ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] * (((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3)))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] * (((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3)))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][2]) * 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) * 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][2]) + 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) + 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] - bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] - bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [bricks[i][0] * bricks[i][2] / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [bricks[i][0] * bricks[i][2] / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 3, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 3, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 1, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 1, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 0, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 0, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 1, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 1, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / -2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / -2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] - bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] - bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, bricks[i][1] * bricks[i][3] / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, bricks[i][1] * bricks[i][3] / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 3]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 3]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 1]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 1]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 0]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 0]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 1]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 1]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / -2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / -2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] + bricks[i][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] + bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] * bricks[i][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] * bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 2, -1, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 2, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 0, -1, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 0, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 0, -1, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 0, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - -1, -1, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - -1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, -2, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -2, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, -0, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -0, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, -0, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -0, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, --1, -1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, --1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, -1, -2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -2):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, -1, -0):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -0):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, -1, -0):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -0):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i - 1, -1, -1):",
      "mutated_line": "for j in range(i - 1, -1, --1):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, --1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[0] <= x2 or y1 <= c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 or y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) / (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) / (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0] + abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0] + abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) ** (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) ** (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) / (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) / (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1] + abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1] + abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) ** (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) ** (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 4",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 4\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 2",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 2\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 0",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 0\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 1",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 1\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][2]) ** -3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** -3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 < c[0] <= x2 and y1 <= c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 < c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 > c[0] <= x2 and y1 <= c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 > c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 == c[0] <= x2 and y1 <= c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 == c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[0] <= x2 and y1 < c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 < c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[0] <= x2 and y1 > c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 > c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[0] <= x2 and y1 == c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 == c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[1] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[1] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[-1] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[-1] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[1] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[1] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 + c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 + c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + (bricks[j][0] + bricks[j][2]) / 2 * c[0] * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + (bricks[j][0] + bricks[j][2]) / 2 * c[0] * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 * (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 * (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 // (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 // (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[2] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[2] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[0] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[0] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[0] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[0] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[-1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[-1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 + c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 + c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + (bricks[j][1] + bricks[j][3]) / 2 * c[1] * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + (bricks[j][1] + bricks[j][3]) / 2 * c[1] * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 * (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 * (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 // (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 // (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] + bricks[j][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] + bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] * bricks[j][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] * bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][1] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][1] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][-1] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][-1] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][1] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][1] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][3]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][3]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][1]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][1]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][0]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][0]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][1]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][1]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][-2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][-2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][2] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][2] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][0] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][0] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][0] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][0] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][-1] + bricks[i][3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][-1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][4]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][4]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][2]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][2]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][0]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][0]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][1]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][1]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]",
      "mutated_line": "c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][-3]) / 2]",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][-3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][1] - bricks[i][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][1] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][-1] - bricks[i][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][-1] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][1] - bricks[i][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][1] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][3]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][3]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][1]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][1]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][0]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][0]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][1]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][1]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = abs(bricks[i][0] - bricks[i][2]) ** 3",
      "mutated_line": "m = abs(bricks[i][0] - bricks[i][-2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][-2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][1], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][1], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][-1], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][-1], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][1], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][1], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][3]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][3]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][1]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][1]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][0]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][0]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][1]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][1]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][-2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][-2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][2], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][2], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][0], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][0], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][0], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][0], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][-1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][-1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][4]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][4]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][2]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][2]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][0]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][0]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][1]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][1]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][-3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][-3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][1], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][1], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][-1], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][-1], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][1], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][1], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][3]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][3]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][1]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][1]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][0]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][0]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][1]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][1]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][-2]), max(bricks[j][1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][-2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][2], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][2], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][0], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][0], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][0], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][0], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][-1], bricks[j][3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][-1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][4]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][4]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][2]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][2]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][0]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][0]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][1]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][1]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))",
      "mutated_line": "(x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][-3]))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][-3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) * 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) * 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) // 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) // 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) * 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) * 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * ((abs(bricks[j][0] - bricks[j][2]) + 3) / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * ((abs(bricks[j][0] - bricks[j][2]) + 3) / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m - abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m - abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m * abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m * abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) * 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) * 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) // 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) // 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) * 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) * 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * ((abs(bricks[j][0] - bricks[j][2]) + 3) / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * ((abs(bricks[j][0] - bricks[j][2]) + 3) / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m - abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m - abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m * abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m * abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[1] <= x2 and y1 <= c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[1] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[-1] <= x2 and y1 <= c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[-1] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[1] <= x2 and y1 <= c[1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[1] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[0] <= x2 and y1 <= c[2] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[2] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[0] <= x2 and y1 <= c[0] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[0] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[0] <= x2 and y1 <= c[0] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[0] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):",
      "mutated_line": "if not (x1 <= c[0] <= x2 and y1 <= c[-1] <= y2):",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[-1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] - bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] - bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + (bricks[j][0] * bricks[j][2] / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + (bricks[j][0] * bricks[j][2] / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 3 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 3 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 1 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 1 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 0 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 0 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 1 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 1 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / -2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / -2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[-1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[-1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 4 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 4 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 2 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 2 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 0 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 0 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 1 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 1 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** -3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** -3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) * 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) * 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + (abs(bricks[j][0] - bricks[j][2]) + 3)))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + (abs(bricks[j][0] - bricks[j][2]) + 3)))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] - bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] - bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + (bricks[j][1] * bricks[j][3] / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + (bricks[j][1] * bricks[j][3] / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 3 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 3 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 1 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 1 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 0 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 0 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 1 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 1 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / -2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / -2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[2]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[2]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[-1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[-1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 4 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 4 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 2 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 2 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 0 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 0 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 1 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 1 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** -3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** -3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) * 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) * 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + (abs(bricks[j][0] - bricks[j][2]) + 3)))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + (abs(bricks[j][0] - bricks[j][2]) + 3)))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][1] - bricks[j][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][1] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][-1] - bricks[j][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][-1] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][1] - bricks[j][2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][1] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][3]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][3]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][1]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][1]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][0]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][0]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][1]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][1]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m += abs(bricks[j][0] - bricks[j][2]) ** 3",
      "mutated_line": "m += abs(bricks[j][0] - bricks[j][-2]) ** 3",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][-2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] + bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] + bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] * bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] * bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 4))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 4))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 2))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 2))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 0))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 0))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 1))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 1))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** -3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** -3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] + bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] + bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] * bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] * bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 4))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 4))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 2))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 2))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 0))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 0))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 1))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 1))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** -3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** -3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][1] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][1] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][-1] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][-1] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][1] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][1] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][3]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][3]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][1]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][1]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][0]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][0]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][1]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][1]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][-2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][-2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] + bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] + bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] * bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] * bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][2] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][2] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][0] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][0] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][0] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][0] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][-1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][-1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][4]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][4]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][2]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][2]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][0]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][0]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][1]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][1]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][-3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][-3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] + bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] + bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] * bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] * bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][-1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][-1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][3]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][3]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][1]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][1]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][0]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][0]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][1]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][1]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][-2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][-2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][-1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][-1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][1] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][3]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][3]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][1]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][1]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][0]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][0]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][1]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][1]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][-2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][-2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][1] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][1] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][-1] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][-1] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][1] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][1] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][3]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][3]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][1]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][1]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][0]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][0]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][1]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][1]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][-2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][-2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][1] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][1] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][-1] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][-1] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][1] - bricks[j][2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][1] - bricks[j][2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][3]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][3]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][1]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][1]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][0]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][0]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][1]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][1]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))",
      "mutated_line": "y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][-2]) ** 3))",
      "code": "def calculate_max_stable_tower(bricks):\n    n = len(bricks)\n    z = n\n    for i in range(n):\n        if i != 0:\n            c = [(bricks[i][0] + bricks[i][2]) / 2, (bricks[i][1] + bricks[i][3]) / 2]\n            m = abs(bricks[i][0] - bricks[i][2]) ** 3\n            for j in range(i - 1, -1, -1):\n                (x1, y1, x2, y2) = (min(bricks[j][0], bricks[j][2]), min(bricks[j][1], bricks[j][3]), max(bricks[j][0], bricks[j][2]), max(bricks[j][1], bricks[j][3]))\n                if not (x1 <= c[0] <= x2 and y1 <= c[1] <= y2):\n                    z = i\n                    break\n                x = c[0] + ((bricks[j][0] + bricks[j][2]) / 2 - c[0]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][2]) ** 3))\n                y = c[1] + ((bricks[j][1] + bricks[j][3]) / 2 - c[1]) * (abs(bricks[j][0] - bricks[j][2]) ** 3 / (m + abs(bricks[j][0] - bricks[j][-2]) ** 3))\n                c = [x, y]\n                m += abs(bricks[j][0] - bricks[j][2]) ** 3\n            if z != n:\n                break\n    return z"
    }
  ]
}