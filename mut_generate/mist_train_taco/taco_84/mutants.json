{
  "task_id": "taco_84",
  "entry_point": "eval",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nbToChange = 0",
      "mutated_line": "nbToChange = 1",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 1\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nbToChange = 0",
      "mutated_line": "nbToChange = -1",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = -1\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nbToChange = 0",
      "mutated_line": "nbToChange = 1",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 1\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "newVal += r",
      "mutated_line": "newVal -= r",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal -= r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "newVal -= r",
      "mutated_line": "newVal += r",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal += r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-1], len(A) + 1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) + 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-1], len(A) * 1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) * 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if newVal != A[iR + 1]:",
      "mutated_line": "if newVal == A[iR + 1]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal == A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange -= 1",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange -= 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[0], 1, -1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 1, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[0], -1, -1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], -1, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[0], 1, -1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 1, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[0], 0, +1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, +1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if newVal != A[iR - 1]:",
      "mutated_line": "if newVal == A[iR - 1]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal == A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange -= 1",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange -= 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, len(A)):",
      "mutated_line": "for i in range(2, len(A)):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(2, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, len(A)):",
      "mutated_line": "for i in range(0, len(A)):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(0, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, len(A)):",
      "mutated_line": "for i in range(0, len(A)):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(0, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, len(A)):",
      "mutated_line": "for i in range(-1, len(A)):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(-1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "r = A[i] - A[i - 1]",
      "mutated_line": "r = A[i] + A[i - 1]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] + A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "r = A[i] - A[i - 1]",
      "mutated_line": "r = A[i] * A[i - 1]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] * A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(a0, r, an, _) = possibles[0]",
      "mutated_line": "(a0, r, an, _) = possibles[1]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[1]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(a0, r, an, _) = possibles[0]",
      "mutated_line": "(a0, r, an, _) = possibles[-1]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[-1]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(a0, r, an, _) = possibles[0]",
      "mutated_line": "(a0, r, an, _) = possibles[1]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[1]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "newVal = A[l[-1]]",
      "mutated_line": "newVal = A[l[+1]]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[+1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[+1], len(A) - 1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[+1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-1], len(A) - 2):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 2):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-1], len(A) - 0):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 0):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-1], len(A) - 0):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 0):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-1], len(A) - -1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - -1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange += 2",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 2\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange += 0",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 0\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange += 0",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 0\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange += -1",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += -1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "newVal = A[l[0]]",
      "mutated_line": "newVal = A[l[1]]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[1]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "newVal = A[l[0]]",
      "mutated_line": "newVal = A[l[-1]]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[-1]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "newVal = A[l[0]]",
      "mutated_line": "newVal = A[l[1]]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[1]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[1], 0, -1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[1], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[-1], 0, -1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[-1], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[1], 0, -1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[1], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[0], 0, -2):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -2):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[0], 0, -0):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -0):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[0], 0, -0):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -0):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for iR in range(l[0], 0, -1):",
      "mutated_line": "for iR in range(l[0], 0, --1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, --1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange += 2",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 2\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange += 0",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 0\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange += 0",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 0\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nbToChange += 1",
      "mutated_line": "nbToChange += -1",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += -1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]",
      "mutated_line": "rMaxEff = [key for key in dictR if len(dictR[key]) != maxEff]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) != maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "possibles = [t for t in results if t[3] <= K]",
      "mutated_line": "possibles = [t for t in results if t[3] < K]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] < K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "possibles = [t for t in results if t[3] <= K]",
      "mutated_line": "possibles = [t for t in results if t[3] > K]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] > K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "possibles = [t for t in results if t[3] <= K]",
      "mutated_line": "possibles = [t for t in results if t[3] == K]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] == K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)",
      "mutated_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=True)",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=True)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ' '.join(list(map(str, range(a0, an + 1, r))))",
      "mutated_line": "return ''.join(list(map(str, range(a0, an + 1, r))))",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ''.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "newVal = A[l[-1]]",
      "mutated_line": "newVal = A[l[-2]]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-2]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "newVal = A[l[-1]]",
      "mutated_line": "newVal = A[l[-0]]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-0]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "newVal = A[l[-1]]",
      "mutated_line": "newVal = A[l[-0]]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-0]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "newVal = A[l[-1]]",
      "mutated_line": "newVal = A[l[--1]]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[--1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-2], len(A) - 1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-2], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-0], len(A) - 1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-0], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[-0], len(A) - 1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-0], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for iR in range(l[-1], len(A) - 1):",
      "mutated_line": "for iR in range(l[--1], len(A) - 1):",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[--1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if newVal != A[iR + 1]:",
      "mutated_line": "if newVal != A[iR - 1]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if newVal != A[iR + 1]:",
      "mutated_line": "if newVal != A[iR * 1]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR * 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if newVal != A[iR - 1]:",
      "mutated_line": "if newVal != A[iR + 1]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if newVal != A[iR - 1]:",
      "mutated_line": "if newVal != A[iR * 1]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR * 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "r = A[i] - A[i - 1]",
      "mutated_line": "r = A[i] - A[i + 1]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i + 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "r = A[i] - A[i - 1]",
      "mutated_line": "r = A[i] - A[i * 1]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i * 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if newVal != A[iR + 1]:",
      "mutated_line": "if newVal != A[iR + 2]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 2]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if newVal != A[iR + 1]:",
      "mutated_line": "if newVal != A[iR + 0]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 0]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if newVal != A[iR + 1]:",
      "mutated_line": "if newVal != A[iR + 0]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 0]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if newVal != A[iR + 1]:",
      "mutated_line": "if newVal != A[iR + -1]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + -1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if newVal != A[iR - 1]:",
      "mutated_line": "if newVal != A[iR - 2]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 2]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if newVal != A[iR - 1]:",
      "mutated_line": "if newVal != A[iR - 0]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 0]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if newVal != A[iR - 1]:",
      "mutated_line": "if newVal != A[iR - 0]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 0]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if newVal != A[iR - 1]:",
      "mutated_line": "if newVal != A[iR - -1]:",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - -1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "r = A[i] - A[i - 1]",
      "mutated_line": "r = A[i] - A[i - 2]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 2]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "r = A[i] - A[i - 1]",
      "mutated_line": "r = A[i] - A[i - 0]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 0]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "r = A[i] - A[i - 1]",
      "mutated_line": "r = A[i] - A[i - 0]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 0]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "r = A[i] - A[i - 1]",
      "mutated_line": "r = A[i] - A[i - -1]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - -1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "possibles = [t for t in results if t[3] <= K]",
      "mutated_line": "possibles = [t for t in results if t[4] <= K]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[4] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "possibles = [t for t in results if t[3] <= K]",
      "mutated_line": "possibles = [t for t in results if t[2] <= K]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[2] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "possibles = [t for t in results if t[3] <= K]",
      "mutated_line": "possibles = [t for t in results if t[0] <= K]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[0] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "possibles = [t for t in results if t[3] <= K]",
      "mutated_line": "possibles = [t for t in results if t[1] <= K]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[1] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "possibles = [t for t in results if t[3] <= K]",
      "mutated_line": "possibles = [t for t in results if t[-3] <= K]",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[-3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return ' '.join(list(map(str, range(a0, an + 1, r))))",
      "mutated_line": "return ' '.join(list(map(str, range(a0, an - 1, r))))",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an - 1, r))))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return ' '.join(list(map(str, range(a0, an + 1, r))))",
      "mutated_line": "return ' '.join(list(map(str, range(a0, an * 1, r))))",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an * 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)",
      "mutated_line": "possibles.sort(key=lambda x: (x[1], x[1]), reverse=False)",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[1], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)",
      "mutated_line": "possibles.sort(key=lambda x: (x[-1], x[1]), reverse=False)",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[-1], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)",
      "mutated_line": "possibles.sort(key=lambda x: (x[1], x[1]), reverse=False)",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[1], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)",
      "mutated_line": "possibles.sort(key=lambda x: (x[0], x[2]), reverse=False)",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[2]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)",
      "mutated_line": "possibles.sort(key=lambda x: (x[0], x[0]), reverse=False)",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[0]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)",
      "mutated_line": "possibles.sort(key=lambda x: (x[0], x[0]), reverse=False)",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[0]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)",
      "mutated_line": "possibles.sort(key=lambda x: (x[0], x[-1]), reverse=False)",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[-1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ' '.join(list(map(str, range(a0, an + 1, r))))",
      "mutated_line": "return ' '.join(list(map(str, range(a0, an + 2, r))))",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 2, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ' '.join(list(map(str, range(a0, an + 1, r))))",
      "mutated_line": "return ' '.join(list(map(str, range(a0, an + 0, r))))",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 0, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ' '.join(list(map(str, range(a0, an + 1, r))))",
      "mutated_line": "return ' '.join(list(map(str, range(a0, an + 0, r))))",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 0, r))))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ' '.join(list(map(str, range(a0, an + 1, r))))",
      "mutated_line": "return ' '.join(list(map(str, range(a0, an + -1, r))))",
      "code": "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef find_most_beautiful_arithmetic_progression(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + -1, r))))"
    }
  ]
}