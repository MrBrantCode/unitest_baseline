{
  "task_id": "taco_8002",
  "entry_point": "calculate_max_probability",
  "mutant_count": 85,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][n] = 1",
      "mutated_line": "dp[0][n] = 2",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 2\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][n] = 1",
      "mutated_line": "dp[0][n] = 0",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 0\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][n] = 1",
      "mutated_line": "dp[0][n] = 0",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 0\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][n] = 1",
      "mutated_line": "dp[0][n] = -1",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = -1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = 1 << m",
      "mutated_line": "M2 = 2 << m",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 2 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = 1 << m",
      "mutated_line": "M2 = 0 << m",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 0 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = 1 << m",
      "mutated_line": "M2 = 0 << m",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 0 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = 1 << m",
      "mutated_line": "M2 = -1 << m",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = -1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] / (n + 1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] / (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] + (n + 1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] + (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] ** (n + 1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] ** (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for state in range(1, M2):",
      "mutated_line": "for state in range(2, M2):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(2, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for state in range(1, M2):",
      "mutated_line": "for state in range(0, M2):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(0, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for state in range(1, M2):",
      "mutated_line": "for state in range(0, M2):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(0, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for state in range(1, M2):",
      "mutated_line": "for state in range(-1, M2):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(-1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 - 1][1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 - 1][-1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 - 1][1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] * (n - 1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n - 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] * (n * 1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n * 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][n] = 1",
      "mutated_line": "dp[1][n] = 1",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[1][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][n] = 1",
      "mutated_line": "dp[-1][n] = 1",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[-1][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][n] = 1",
      "mutated_line": "dp[1][n] = 1",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[1][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state & 1 << k != 0:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k != 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "pk = probabilities[k] + [0]",
      "mutated_line": "pk = probabilities[k] - [0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] - [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "pk = probabilities[k] + [0]",
      "mutated_line": "pk = probabilities[k] * [0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] * [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 1\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = -1\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 1\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s -= dpk[i] * (1 - pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s -= dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "s *= pk[i - 1]",
      "mutated_line": "s /= pk[i - 1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s /= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 + 1][0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 + 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 * 1][0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 * 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[1] * (n + 1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[1] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[-1] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[1] * (n + 1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[1] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] * (n + 2) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 2) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] * (n + 0) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 0) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] * (n + 0) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 0) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * (n + 1) for _ in range(M2)]",
      "mutated_line": "dp = [[0] * (n + -1) for _ in range(M2)]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + -1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state | 1 << k == 0:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state | 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state & 1 << k == 1:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 1:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state & 1 << k == -1:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == -1:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state & 1 << k == 1:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 1:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dpk = dp[state ^ 1 << k]",
      "mutated_line": "dpk = dp[state | 1 << k]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state | 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, +1, -1):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, +1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, +1):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, +1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] / (1 - pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] / (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] + (1 - pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] + (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] ** (1 - pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] ** (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 - 2][0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 2][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 - 0][0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 - 0][0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp[M2 - 1][0]",
      "mutated_line": "return dp[M2 - -1][0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - -1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pk = probabilities[k] + [0]",
      "mutated_line": "pk = probabilities[k] + [1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [1]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pk = probabilities[k] + [0]",
      "mutated_line": "pk = probabilities[k] + [-1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [-1]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pk = probabilities[k] + [0]",
      "mutated_line": "pk = probabilities[k] + [1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [1]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -2, -1):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -2, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -0, -1):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -0, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -0, -1):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -0, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, --1, -1):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, --1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, -2):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -2):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, -0):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -0):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, -0):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -0):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, --1):",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, --1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] * (1 + pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 + pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] * (1 * pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 * pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s *= pk[i - 1]",
      "mutated_line": "s *= pk[i + 1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i + 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s *= pk[i - 1]",
      "mutated_line": "s *= pk[i * 1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i * 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state & 2 << k == 0:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 2 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state & 0 << k == 0:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 0 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state & 0 << k == 0:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 0 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if state & 1 << k == 0:",
      "mutated_line": "if state & -1 << k == 0:",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & -1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dpk = dp[state ^ 1 << k]",
      "mutated_line": "dpk = dp[state ^ 2 << k]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 2 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dpk = dp[state ^ 1 << k]",
      "mutated_line": "dpk = dp[state ^ 0 << k]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 0 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dpk = dp[state ^ 1 << k]",
      "mutated_line": "dpk = dp[state ^ 0 << k]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 0 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dpk = dp[state ^ 1 << k]",
      "mutated_line": "dpk = dp[state ^ -1 << k]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ -1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] * (2 - pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (2 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] * (0 - pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (0 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] * (0 - pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (0 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "s += dpk[i] * (1 - pk[i])",
      "mutated_line": "s += dpk[i] * (-1 - pk[i])",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (-1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 1]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s *= pk[i - 1]",
      "mutated_line": "s *= pk[i - 2]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 2]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s *= pk[i - 1]",
      "mutated_line": "s *= pk[i - 0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 0]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s *= pk[i - 1]",
      "mutated_line": "s *= pk[i - 0]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - 0]\n    return dp[M2 - 1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s *= pk[i - 1]",
      "mutated_line": "s *= pk[i - -1]",
      "code": "def calculate_max_probability(m: int, n: int, probabilities: list[list[float]]) -> float:\n    M2 = 1 << m\n    dp = [[0] * (n + 1) for _ in range(M2)]\n    dp[0][n] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(m):\n            if state & 1 << k == 0:\n                continue\n            pk = probabilities[k] + [0]\n            dpk = dp[state ^ 1 << k]\n            s = 0\n            for i in range(n, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i - -1]\n    return dp[M2 - 1][0]"
    }
  ]
}