{
  "task_id": "taco_17843",
  "entry_point": "plan_reachable_vertices",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "k = 1",
      "mutated_line": "k = 2",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 2\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 0\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 0\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "k = 1",
      "mutated_line": "k = -1",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = -1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m = k - 1",
      "mutated_line": "m = k + 1",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k + 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m = k - 1",
      "mutated_line": "m = k * 1",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k * 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "def dfs(x, flag=1):",
      "mutated_line": "",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=2):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "def dfs(x, flag=1):",
      "mutated_line": "",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=0):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "def dfs(x, flag=1):",
      "mutated_line": "",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=0):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "def dfs(x, flag=1):",
      "mutated_line": "",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=-1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis[x] = 1",
      "mutated_line": "vis[x] = 2",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 2\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis[x] = 1",
      "mutated_line": "vis[x] = 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 0\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis[x] = 1",
      "mutated_line": "vis[x] = 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 0\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis[x] = 1",
      "mutated_line": "vis[x] = -1",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = -1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if z == 1:",
      "mutated_line": "if z != 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z != 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k -= 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = k - 1",
      "mutated_line": "m = k - 2",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 2\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = k - 1",
      "mutated_line": "m = k - 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 0\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = k - 1",
      "mutated_line": "m = k - 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 0\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = k - 1",
      "mutated_line": "m = k - -1",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - -1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s + 1, 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s + 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s * 1, 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s * 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s - 1, 2)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 2)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s - 1, 0)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 0)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s - 1, 0)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 0)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s - 1, -1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, -1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s + 1, -1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s + 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s * 1, -1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s * 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - 1, +1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, +1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [0] / n, ['+'] * m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] / n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [0] + n, ['+'] * m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] + n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [0] ** n, ['+'] * m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] ** n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [0] * n, ['+'] / m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] / m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [0] * n, ['+'] + m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] + m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [0] * n, ['+'] ** m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] ** m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x + 1, y - 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x + 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x * 1, y - 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x * 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 1, y + 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y + 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 1, y * 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y * 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if z == 1:",
      "mutated_line": "if z == 2:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 2:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if z == 1:",
      "mutated_line": "if z == 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 0:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if z == 1:",
      "mutated_line": "if z == 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 0:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if z == 1:",
      "mutated_line": "if z == -1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == -1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 2\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 0\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 0\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += -1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s - 2, 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 2, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s - 0, 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 0, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s - 0, 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 0, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_plan = dfs(s - 1, 1)",
      "mutated_line": "max_plan = dfs(s - -1, 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - -1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - 2, -1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 2, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - 0, -1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 0, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - 0, -1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 0, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - -1, -1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - -1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - 1, -2)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -2)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - 1, -0)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -0)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - 1, -0)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -0)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_plan = dfs(s - 1, -1)",
      "mutated_line": "min_plan = dfs(s - 1, --1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, --1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if vis[j] == 0:",
      "mutated_line": "if vis[j] != 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] != 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 2, y - 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 2, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 0, y - 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 0, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 0, y - 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 0, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - -1, y - 1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - -1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 1, y - 2)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 2)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 1, y - 0)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 0)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 1, y - 0)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 0)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y = x - 1, y - 1",
      "mutated_line": "(x, y) = (x - 1, y - -1)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - -1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [1] * n, ['+'] * m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [1] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [-1] * n, ['+'] * m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [-1] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [1] * n, ['+'] * m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [1] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s, vis, ans = [x], [0] * n, ['+'] * m",
      "mutated_line": "(s, vis, ans) = ([x], [0] * n, [''] * m)",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, [''] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if vis[j] == 0:",
      "mutated_line": "if vis[j] == 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 1:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if vis[j] == 0:",
      "mutated_line": "if vis[j] == -1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == -1:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if vis[j] == 0:",
      "mutated_line": "if vis[j] == 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 1:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k * flag <= 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag <= 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k * flag >= 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag >= 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k * flag != 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag != 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == 1 and k == 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 and k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return ''.join(ans), sum(vis)",
      "mutated_line": "return ('MUTATED'.join(ans), sum(vis))",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return ('MUTATED'.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "graph[x].append((y, 0))",
      "mutated_line": "graph[x].append((y, 1))",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 1))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "graph[x].append((y, 0))",
      "mutated_line": "graph[x].append((y, -1))",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, -1))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "graph[x].append((y, 0))",
      "mutated_line": "graph[x].append((y, 1))",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 1))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "graph[y].append((x, -k))",
      "mutated_line": "graph[y].append((x, +k))",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, +k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k / flag < 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k / flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k + flag < 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k + flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k ** flag < 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k ** flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k * flag < 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 1:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k * flag < -1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < -1:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if k * flag < 0:",
      "mutated_line": "if k * flag < 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 1:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans[abs(k) - 1] = '-'",
      "mutated_line": "ans[abs(k) - 1] = ''",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = ''\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k * flag >= 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag >= 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k * flag <= 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag <= 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k * flag != 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag != 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag != 1 or k == 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag != 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == 1 or k != 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k != 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "vis[j] = 1",
      "mutated_line": "vis[j] = 2",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 2\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "vis[j] = 1",
      "mutated_line": "vis[j] = 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 0\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "vis[j] = 1",
      "mutated_line": "vis[j] = 0",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 0\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "vis[j] = 1",
      "mutated_line": "vis[j] = -1",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = -1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans[abs(k) - 1] = '-'",
      "mutated_line": "ans[abs(k) + 1] = '-'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) + 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans[abs(k) - 1] = '-'",
      "mutated_line": "ans[abs(k) * 1] = '-'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) * 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k / flag > 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k / flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k + flag > 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k + flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k ** flag > 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k ** flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k * flag > 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 1:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k * flag > -1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > -1:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif k * flag > 0:",
      "mutated_line": "elif k * flag > 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 1:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans[abs(k) - 1] = '+'",
      "mutated_line": "ans[abs(k) - 1] = ''",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = ''\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == 2 or k == 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 2 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == 0 or k == 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 0 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == 0 or k == 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 0 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == -1 or k == 0:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == -1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == 1 or k == 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 1:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == 1 or k == -1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == -1:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if flag == 1 or k == 0:",
      "mutated_line": "if flag == 1 or k == 1:",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 1:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans[abs(k) - 1] = '-'",
      "mutated_line": "ans[abs(k) - 2] = '-'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 2] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans[abs(k) - 1] = '-'",
      "mutated_line": "ans[abs(k) - 0] = '-'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 0] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans[abs(k) - 1] = '-'",
      "mutated_line": "ans[abs(k) - 0] = '-'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 0] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans[abs(k) - 1] = '-'",
      "mutated_line": "ans[abs(k) - -1] = '-'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - -1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "ans[abs(k) - 1] = '+'",
      "mutated_line": "ans[abs(k) + 1] = '+'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) + 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "ans[abs(k) - 1] = '+'",
      "mutated_line": "ans[abs(k) * 1] = '+'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) * 1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans[abs(k) - 1] = '+'",
      "mutated_line": "ans[abs(k) - 2] = '+'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 2] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans[abs(k) - 1] = '+'",
      "mutated_line": "ans[abs(k) - 0] = '+'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 0] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans[abs(k) - 1] = '+'",
      "mutated_line": "ans[abs(k) - 0] = '+'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - 0] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans[abs(k) - 1] = '+'",
      "mutated_line": "ans[abs(k) - -1] = '+'",
      "code": "def plan_reachable_vertices(n, m, s, edges):\n\n    def dfs(x, flag=1):\n        (s, vis, ans) = ([x], [0] * n, ['+'] * m)\n        vis[x] = 1\n        while s:\n            i = s.pop()\n            for (j, k) in graph[i]:\n                if vis[j] == 0:\n                    if k * flag < 0:\n                        ans[abs(k) - 1] = '-'\n                    elif k * flag > 0:\n                        ans[abs(k) - -1] = '+'\n                    if flag == 1 or k == 0:\n                        s.append(j)\n                        vis[j] = 1\n        return (''.join(ans), sum(vis))\n    graph = [[] for _ in range(n)]\n    k = 1\n    for (z, x, y) in edges:\n        (x, y) = (x - 1, y - 1)\n        if z == 1:\n            graph[x].append((y, 0))\n        else:\n            graph[x].append((y, k))\n            graph[y].append((x, -k))\n            k += 1\n    m = k - 1\n    max_plan = dfs(s - 1, 1)\n    min_plan = dfs(s - 1, -1)\n    return (max_plan, min_plan)"
    }
  ]
}