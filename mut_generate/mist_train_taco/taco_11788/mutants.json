{
  "task_id": "taco_11788",
  "entry_point": "max_crab_vertices",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "C_MAX = 1000",
      "mutated_line": "C_MAX = 1001",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1001\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "C_MAX = 1000",
      "mutated_line": "C_MAX = 999",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 999\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "C_MAX = 1000",
      "mutated_line": "C_MAX = 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 0\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "C_MAX = 1000",
      "mutated_line": "C_MAX = 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "C_MAX = 1000",
      "mutated_line": "C_MAX = -1000",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = -1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "f -= 1",
      "mutated_line": "f += 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f += 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "t -= 1",
      "mutated_line": "t += 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t += 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 1\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = -1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = -1\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 1\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while False:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "max_flow += min_cap",
      "mutated_line": "max_flow -= min_cap",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow -= min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 1) - 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) - 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 1) * 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) * 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 1) - 3",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) - 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 1) * 3",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) * 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f -= 1",
      "mutated_line": "f -= 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 2\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f -= 1",
      "mutated_line": "f -= 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 0\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f -= 1",
      "mutated_line": "f -= 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 0\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f -= 1",
      "mutated_line": "f -= -1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= -1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t -= 1",
      "mutated_line": "t -= 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 2\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t -= 1",
      "mutated_line": "t -= 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 0\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t -= 1",
      "mutated_line": "t -= 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 0\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t -= 1",
      "mutated_line": "t -= -1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= -1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.adj_mtx[self.map_odd(i)][1] = 1",
      "mutated_line": "self.adj_mtx[self.map_odd(i)][1] = 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 2\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.adj_mtx[self.map_odd(i)][1] = 1",
      "mutated_line": "self.adj_mtx[self.map_odd(i)][1] = 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 0\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.adj_mtx[self.map_odd(i)][1] = 1",
      "mutated_line": "self.adj_mtx[self.map_odd(i)][1] = 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 0\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.adj_mtx[self.map_odd(i)][1] = 1",
      "mutated_line": "self.adj_mtx[self.map_odd(i)][1] = -1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = -1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "v = 1",
      "mutated_line": "v = 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 2\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "v = 1",
      "mutated_line": "v = 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 0\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "v = 1",
      "mutated_line": "v = 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 0\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "v = 1",
      "mutated_line": "v = -1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = -1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while v != 0:",
      "mutated_line": "while v == 0:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v == 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "self.flow_mtx[u][v] += min_cap",
      "mutated_line": "self.flow_mtx[u][v] -= min_cap",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] -= min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "self.flow_mtx[v][u] -= min_cap",
      "mutated_line": "self.flow_mtx[v][u] += min_cap",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] += min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "mins = {0: Solution.C_MAX * Solution.C_MAX}",
      "mutated_line": "mins = {1: Solution.C_MAX * Solution.C_MAX}",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {1: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "mins = {0: Solution.C_MAX * Solution.C_MAX}",
      "mutated_line": "mins = {-1: Solution.C_MAX * Solution.C_MAX}",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {-1: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "mins = {0: Solution.C_MAX * Solution.C_MAX}",
      "mutated_line": "mins = {1: Solution.C_MAX * Solution.C_MAX}",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {1: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "mins = {0: Solution.C_MAX * Solution.C_MAX}",
      "mutated_line": "mins = {0: Solution.C_MAX / Solution.C_MAX}",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX / Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "mins = {0: Solution.C_MAX * Solution.C_MAX}",
      "mutated_line": "mins = {0: Solution.C_MAX + Solution.C_MAX}",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX + Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "mins = {0: Solution.C_MAX * Solution.C_MAX}",
      "mutated_line": "mins = {0: Solution.C_MAX ** Solution.C_MAX}",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX ** Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "queue = [0]",
      "mutated_line": "queue = [1]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [1]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "queue = [0]",
      "mutated_line": "queue = [-1]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [-1]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "queue = [0]",
      "mutated_line": "queue = [1]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [1]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return (0, path)",
      "mutated_line": "return (1, path)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (1, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return (0, path)",
      "mutated_line": "return (-1, path)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (-1, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return (0, path)",
      "mutated_line": "return (1, path)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (1, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 1) + 3",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 3\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 1) + 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 1\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 1) + 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 0\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 1) + 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 1\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 1) + -2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + -2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 1) + 4",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 4\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 1) + 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 2\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 1) + 0",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 0\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 1) + 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 1\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 1) + -3",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + -3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]",
      "mutated_line": "self.adj_mtx = [[1 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[1 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]",
      "mutated_line": "self.adj_mtx = [[-1 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[-1 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]",
      "mutated_line": "self.adj_mtx = [[1 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[1 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.adj_mtx[self.map_odd(i)][1] = 1",
      "mutated_line": "self.adj_mtx[self.map_odd(i)][2] = 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][2] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.adj_mtx[self.map_odd(i)][1] = 1",
      "mutated_line": "self.adj_mtx[self.map_odd(i)][0] = 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][0] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.adj_mtx[self.map_odd(i)][1] = 1",
      "mutated_line": "self.adj_mtx[self.map_odd(i)][0] = 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][0] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.adj_mtx[self.map_odd(i)][1] = 1",
      "mutated_line": "self.adj_mtx[self.map_odd(i)][-1] = 1",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][-1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[1 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[1 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[-1 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[-1 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[1 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[1 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while v != 0:",
      "mutated_line": "while v != 1:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 1:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while v != 0:",
      "mutated_line": "while v != -1:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != -1:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while v != 0:",
      "mutated_line": "while v != 1:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 1:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "u = queue.pop(0)",
      "mutated_line": "u = queue.pop(1)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(1)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "u = queue.pop(0)",
      "mutated_line": "u = queue.pop(-1)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(-1)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "u = queue.pop(0)",
      "mutated_line": "u = queue.pop(1)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(1)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c - self.flow_mtx[u][v] > 0 or v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 or v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 2) + 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 2) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 0) + 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 0) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << 0) + 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 0) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (a << 1) + 2",
      "mutated_line": "return (a << -1) + 2",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << -1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 2) + 3",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 2) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 0) + 3",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 0) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << 0) + 3",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 0) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return (a << 1) + 3",
      "mutated_line": "return (a << -1) + 3",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << -1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.adj_mtx[0][self.map_even(i)] = T",
      "mutated_line": "self.adj_mtx[1][self.map_even(i)] = T",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[1][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.adj_mtx[0][self.map_even(i)] = T",
      "mutated_line": "self.adj_mtx[-1][self.map_even(i)] = T",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[-1][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.adj_mtx[0][self.map_even(i)] = T",
      "mutated_line": "self.adj_mtx[1][self.map_even(i)] = T",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[1][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) - 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) - 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) * 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) * 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c - self.flow_mtx[u][v] >= 0 and v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] >= 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c - self.flow_mtx[u][v] <= 0 and v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] <= 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c - self.flow_mtx[u][v] != 0 and v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] != 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c - self.flow_mtx[u][v] > 0 and v in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if v == 1:",
      "mutated_line": "if v != 1:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v != 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) - 1)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) - 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) * 1)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) * 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 2)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 2)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 0)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 0)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 0)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 0)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + -1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + -1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c + self.flow_mtx[u][v] > 0 and v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c + self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c * self.flow_mtx[u][v] > 0 and v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c * self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c - self.flow_mtx[u][v] > 1 and v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 1 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c - self.flow_mtx[u][v] > -1 and v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > -1 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if c - self.flow_mtx[u][v] > 0 and v not in path:",
      "mutated_line": "if c - self.flow_mtx[u][v] > 1 and v not in path:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 1 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "mins[v] = min(mins[u], c - self.flow_mtx[u][v])",
      "mutated_line": "mins[v] = min(mins[u], c + self.flow_mtx[u][v])",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c + self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "mins[v] = min(mins[u], c - self.flow_mtx[u][v])",
      "mutated_line": "mins[v] = min(mins[u], c * self.flow_mtx[u][v])",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c * self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if v == 1:",
      "mutated_line": "if v == 2:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 2:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if v == 1:",
      "mutated_line": "if v == 0:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 0:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if v == 1:",
      "mutated_line": "if v == 0:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 0:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if v == 1:",
      "mutated_line": "if v == -1:",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == -1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 2)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 2)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 0)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 0)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 0)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 0)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]",
      "mutated_line": "self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + -1)] for i in range(self.map_odd(self.N) + 1)]",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + -1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (mins[1], path)",
      "mutated_line": "return (mins[2], path)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[2], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (mins[1], path)",
      "mutated_line": "return (mins[0], path)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[0], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (mins[1], path)",
      "mutated_line": "return (mins[0], path)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[0], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (mins[1], path)",
      "mutated_line": "return (mins[-1], path)",
      "code": "def max_crab_vertices(N, T, M, edges):\n\n    class Solution:\n        C_MAX = 1000\n\n        def __init__(self, N, T, edges):\n            self.N = N\n            self.T = T\n            self.adj_mtx = [[0 for j in range(self.map_odd(N))] for i in range(self.map_odd(N))]\n            for (f, t) in edges:\n                f -= 1\n                t -= 1\n                self.adj_mtx[self.map_even(f)][self.map_odd(t)] = Solution.C_MAX\n                self.adj_mtx[self.map_even(t)][self.map_odd(f)] = Solution.C_MAX\n            for i in range(N):\n                self.adj_mtx[0][self.map_even(i)] = T\n                self.adj_mtx[self.map_odd(i)][1] = 1\n\n        def max_vertices_covered(self):\n            self.flow_mtx = [[0 for j in range(self.map_odd(self.N) + 1)] for i in range(self.map_odd(self.N) + 1)]\n            max_flow = 0\n            while True:\n                (min_cap, path) = self.bfs()\n                if not min_cap:\n                    break\n                max_flow += min_cap\n                v = 1\n                while v != 0:\n                    u = path[v]\n                    self.flow_mtx[u][v] += min_cap\n                    self.flow_mtx[v][u] -= min_cap\n                    v = u\n            return max_flow\n\n        def bfs(self):\n            path = dict()\n            mins = {0: Solution.C_MAX * Solution.C_MAX}\n            queue = [0]\n            while len(queue):\n                u = queue.pop(0)\n                for (v, c) in enumerate(self.adj_mtx[u]):\n                    if c - self.flow_mtx[u][v] > 0 and v not in path:\n                        path[v] = u\n                        mins[v] = min(mins[u], c - self.flow_mtx[u][v])\n                        if v == 1:\n                            return (mins[-1], path)\n                        else:\n                            queue.append(v)\n            return (0, path)\n\n        @staticmethod\n        def map_even(a):\n            return (a << 1) + 2\n\n        @staticmethod\n        def map_odd(a):\n            return (a << 1) + 3\n    s = Solution(N, T, edges)\n    return s.max_vertices_covered()"
    }
  ]
}