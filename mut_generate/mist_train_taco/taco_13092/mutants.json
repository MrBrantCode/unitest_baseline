{
  "task_id": "taco_13092",
  "entry_point": "count_beautiful_permutations",
  "mutant_count": 161,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000008\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000006\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 0\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = -1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) / 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) / 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) * 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) * 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "retv = 0",
      "mutated_line": "retv = 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 1\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "retv = 0",
      "mutated_line": "retv = -1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = -1\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "retv = 0",
      "mutated_line": "retv = 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 1\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "twoinvpow = 1",
      "mutated_line": "twoinvpow = 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 2\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "twoinvpow = 1",
      "mutated_line": "twoinvpow = 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 0\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "twoinvpow = 1",
      "mutated_line": "twoinvpow = 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 0\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "twoinvpow = 1",
      "mutated_line": "twoinvpow = -1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = -1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv -= v if cp % 2 == 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv -= v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return retv % MOD",
      "mutated_line": "return retv * MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return retv % MOD",
      "mutated_line": "return retv + MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD - 1) // 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD - 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = MOD * 1 // 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = MOD * 1 // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // 3",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 3\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 1\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 0\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 1\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // -2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // -2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if x in {0, 1}:",
      "mutated_line": "if x not in {0, 1}:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x not in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x in _factorials:",
      "mutated_line": "if x not in _factorials:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x not in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x * factorial(x - 1) * MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) * MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x * factorial(x - 1) + MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) + MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if k == n or k == 0:",
      "mutated_line": "if k == n and k == 0:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n and k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 0 and k > n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 and k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (n, k) in _bin:",
      "mutated_line": "if (n, k) not in _bin:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) not in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) * MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) * MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = binomial(n - 1, k) + binomial(n - 1, k - 1) + MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = binomial(n - 1, k) + binomial(n - 1, k - 1) + MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, 0) - 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) - 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, 0) * 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) * 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for i in range(npairs + 1):",
      "mutated_line": "for i in range(npairs - 1):",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs - 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for i in range(npairs + 1):",
      "mutated_line": "for i in range(npairs * 1):",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs * 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "cp = npairs - i",
      "mutated_line": "cp = npairs + i",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs + i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "cp = npairs - i",
      "mutated_line": "cp = npairs * i",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs * i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)",
      "mutated_line": "v = factorial(ntot - cp) * twoinvpow / binomial(npairs, cp)",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow / binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)",
      "mutated_line": "v = factorial(ntot - cp) * twoinvpow + binomial(npairs, cp)",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow + binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)",
      "mutated_line": "v = (factorial(ntot - cp) * twoinvpow) ** binomial(npairs, cp)",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = (factorial(ntot - cp) * twoinvpow) ** binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "twoinvpow = twoinvpow * INV2 % MOD",
      "mutated_line": "twoinvpow = twoinvpow * INV2 * MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 * MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "twoinvpow = twoinvpow * INV2 % MOD",
      "mutated_line": "twoinvpow = twoinvpow * INV2 + MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 + MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 2) // 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 2) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 0) // 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 0) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 0) // 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 0) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + -1) // 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + -1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 2\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 0\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 0\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return -1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x / factorial(x - 1) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x / factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = (x + factorial(x - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = (x + factorial(x - 1)) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x ** factorial(x - 1) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x ** factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if k == n or k == 0:",
      "mutated_line": "if k != n or k == 0:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k != n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if k == n or k == 0:",
      "mutated_line": "if k == n or k != 0:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k != 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 2\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 0\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 0\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return -1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k <= 0 or k > n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k <= 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k >= 0 or k > n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k >= 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k != 0 or k > n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k != 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 0 or k >= n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k >= n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 0 or k <= n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k <= n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 0 or k != n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k != n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 1\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return -1\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 1\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) - binomial(n - 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) - binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = binomial(n - 1, k) * binomial(n - 1, k - 1) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = binomial(n - 1, k) * binomial(n - 1, k - 1) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, 0) + 2",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 2\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, 0) + 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 0\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, 0) + 0",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 0\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, 0) + -1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + -1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((2 for v in mults.values() if v == 2))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((2 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((0 for v in mults.values() if v == 2))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((0 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((0 for v in mults.values() if v == 2))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((0 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((-1 for v in mults.values() if v == 2))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((-1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((2 for v in mults.values() if v == 1))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((2 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((0 for v in mults.values() if v == 1))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((0 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((0 for v in mults.values() if v == 1))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((0 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((-1 for v in mults.values() if v == 1))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((-1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(npairs + 1):",
      "mutated_line": "for i in range(npairs + 2):",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 2):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(npairs + 1):",
      "mutated_line": "for i in range(npairs + 0):",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 0):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(npairs + 1):",
      "mutated_line": "for i in range(npairs + 0):",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 0):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(npairs + 1):",
      "mutated_line": "for i in range(npairs + -1):",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + -1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)",
      "mutated_line": "v = factorial(ntot - cp) / twoinvpow * binomial(npairs, cp)",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) / twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)",
      "mutated_line": "v = (factorial(ntot - cp) + twoinvpow) * binomial(npairs, cp)",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = (factorial(ntot - cp) + twoinvpow) * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)",
      "mutated_line": "v = factorial(ntot - cp) ** twoinvpow * binomial(npairs, cp)",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) ** twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "twoinvpow = twoinvpow * INV2 % MOD",
      "mutated_line": "twoinvpow = twoinvpow / INV2 % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow / INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "twoinvpow = twoinvpow * INV2 % MOD",
      "mutated_line": "twoinvpow = (twoinvpow + INV2) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = (twoinvpow + INV2) % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "twoinvpow = twoinvpow * INV2 % MOD",
      "mutated_line": "twoinvpow = twoinvpow ** INV2 % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow ** INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 2 != 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 != 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 2 == 0 else MOD + v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD + v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 2 == 0 else MOD * v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD * v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x in {0, 1}:",
      "mutated_line": "if x in {1, 1}:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {1, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x in {0, 1}:",
      "mutated_line": "if x in {-1, 1}:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {-1, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x in {0, 1}:",
      "mutated_line": "if x in {1, 1}:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {1, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x in {0, 1}:",
      "mutated_line": "if x in {0, 2}:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 2}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x in {0, 1}:",
      "mutated_line": "if x in {0, 0}:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 0}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x in {0, 1}:",
      "mutated_line": "if x in {0, 0}:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 0}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if x in {0, 1}:",
      "mutated_line": "if x in {0, -1}:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, -1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if k == n or k == 0:",
      "mutated_line": "if k == n or k == 1:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 1:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if k == n or k == 0:",
      "mutated_line": "if k == n or k == -1:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == -1:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if k == n or k == 0:",
      "mutated_line": "if k == n or k == 1:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 1:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 1 or k > n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 1 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < -1 or k > n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < -1 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 1 or k > n:",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 1 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, 1) + 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 1) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, -1) + 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, -1) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "mults[x] = mults.get(x, 0) + 1",
      "mutated_line": "mults[x] = mults.get(x, 1) + 1",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 1) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((1 for v in mults.values() if v != 2))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v != 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((1 for v in mults.values() if v != 1))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v != 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp * 2 == 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp * 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp + 2 == 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp + 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 2 == 1 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 1 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 2 == -1 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == -1 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 2 == 1 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 1 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x * factorial(x + 1) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x + 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x * factorial(x * 1) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x * 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n + 1, k) + binomial(n - 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n + 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n * 1, k) + binomial(n - 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n * 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n + 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n + 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n * 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n * 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k + 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k + 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k * 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k * 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((1 for v in mults.values() if v == 3))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 3))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((1 for v in mults.values() if v == 1))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 1))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((1 for v in mults.values() if v == 0))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 0))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((1 for v in mults.values() if v == 1))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 1))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "npairs = sum((1 for v in mults.values() if v == 2))",
      "mutated_line": "npairs = sum((1 for v in mults.values() if v == -2))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == -2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((1 for v in mults.values() if v == 2))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 2))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((1 for v in mults.values() if v == 0))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 0))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((1 for v in mults.values() if v == 0))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 0))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nsingles = sum((1 for v in mults.values() if v == 1))",
      "mutated_line": "nsingles = sum((1 for v in mults.values() if v == -1))",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == -1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)",
      "mutated_line": "v = factorial(ntot + cp) * twoinvpow * binomial(npairs, cp)",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot + cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)",
      "mutated_line": "v = factorial(ntot * cp) * twoinvpow * binomial(npairs, cp)",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot * cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 3 == 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 3 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 1 == 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 1 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 0 == 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 0 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % 1 == 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 1 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "retv += v if cp % 2 == 0 else MOD - v",
      "mutated_line": "retv += v if cp % -2 == 0 else MOD - v",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % -2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x * factorial(x - 2) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 2) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x * factorial(x - 0) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 0) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x * factorial(x - 0) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 0) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "retv = x * factorial(x - 1) % MOD",
      "mutated_line": "retv = x * factorial(x - -1) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - -1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 2, k) + binomial(n - 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 2, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 0, k) + binomial(n - 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 0, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 0, k) + binomial(n - 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 0, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - -1, k) + binomial(n - 1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - -1, k) + binomial(n - 1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 2, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 2, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 0, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 0, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 0, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 0, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - -1, k - 1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - -1, k - 1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 2)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 2)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 0)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 0)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 0)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - 0)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - 1)) % MOD",
      "mutated_line": "retv = (binomial(n - 1, k) + binomial(n - 1, k - -1)) % MOD",
      "code": "def count_beautiful_permutations(A: list) -> int:\n    \"\"\"\n    Counts the number of beautiful permutations of the array A modulo 10^9 + 7.\n\n    A beautiful permutation is defined as a permutation where no two adjacent elements are the same.\n\n    Parameters:\n    A (list): The input array of integers where each integer occurs at most twice.\n\n    Returns:\n    int: The number of beautiful permutations modulo 10^9 + 7.\n    \"\"\"\n    MOD = 1000000007\n    INV2 = (MOD + 1) // 2\n    _factorials = {}\n\n    def factorial(x):\n        if x in {0, 1}:\n            return 1\n        if x in _factorials:\n            return _factorials[x]\n        retv = x * factorial(x - 1) % MOD\n        _factorials[x] = retv\n        return retv\n    _bin = {}\n\n    def binomial(n, k):\n        if k == n or k == 0:\n            return 1\n        if k < 0 or k > n:\n            return 0\n        if (n, k) in _bin:\n            return _bin[n, k]\n        retv = (binomial(n - 1, k) + binomial(n - 1, k - -1)) % MOD\n        _bin[n, k] = retv\n        return retv\n    mults = {}\n    for x in A:\n        mults[x] = mults.get(x, 0) + 1\n    npairs = sum((1 for v in mults.values() if v == 2))\n    nsingles = sum((1 for v in mults.values() if v == 1))\n    ntot = len(A)\n    retv = 0\n    twoinvpow = 1\n    for i in range(npairs + 1):\n        cp = npairs - i\n        v = factorial(ntot - cp) * twoinvpow * binomial(npairs, cp)\n        twoinvpow = twoinvpow * INV2 % MOD\n        retv += v if cp % 2 == 0 else MOD - v\n    return retv % MOD"
    }
  ]
}