{
  "task_id": "taco_1861",
  "entry_point": "count_possible_words",
  "mutant_count": 183,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 8 - 7):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 - 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 8 * 7):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 * 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "v[i] += v[i + 1]",
      "mutated_line": "v[i] -= v[i + 1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] -= v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] - [0] * (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] - [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] * ([0] * (len(c) - 1))",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] * ([0] * (len(c) - 1))\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 * 8 + 7):",
      "code": "def count_possible_words(n, m, mod=10 * 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 + 8 + 7):",
      "code": "def count_possible_words(n, m, mod=10 + 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 8 + 8):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 8):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 8 + 6):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 6):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 8 + 0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 0):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 8 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 1):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 8 + -7):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + -7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i >= n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i >= n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i <= n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i <= n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i != n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i != n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n + 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n * 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, +1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, +1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while v[1]:",
      "mutated_line": "while v[2]:",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[2]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while v[1]:",
      "mutated_line": "while v[0]:",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[0]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while v[1]:",
      "mutated_line": "while v[0]:",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[0]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while v[1]:",
      "mutated_line": "while v[-1]:",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[-1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [0] / (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] / (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + ([0] + (len(c) - 1))",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + ([0] + (len(c) - 1))\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [0] ** (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] ** (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(2, m + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(2, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(0, m + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(0, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(0, m + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(0, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(-1, m + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(-1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(1, m - 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m - 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(1, m * 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m * 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] - f[:-1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] - f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] * f[:-1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] * f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return f[0]",
      "mutated_line": "return f[1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return f[0]",
      "mutated_line": "return f[-1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return f[0]",
      "mutated_line": "return f[1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[1]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=11 ** 8 + 7):",
      "code": "def count_possible_words(n, m, mod=11 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=9 ** 8 + 7):",
      "code": "def count_possible_words(n, m, mod=9 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=0 ** 8 + 7):",
      "code": "def count_possible_words(n, m, mod=0 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=1 ** 8 + 7):",
      "code": "def count_possible_words(n, m, mod=1 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=-10 ** 8 + 7):",
      "code": "def count_possible_words(n, m, mod=-10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 9 + 7):",
      "code": "def count_possible_words(n, m, mod=10 ** 9 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 7 + 7):",
      "code": "def count_possible_words(n, m, mod=10 ** 7 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 0 + 7):",
      "code": "def count_possible_words(n, m, mod=10 ** 0 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** 1 + 7):",
      "code": "def count_possible_words(n, m, mod=10 ** 1 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_possible_words(n, m, mod=10**8 + 7):",
      "mutated_line": "def count_possible_words(n, m, mod=10 ** -8 + 7):",
      "code": "def count_possible_words(n, m, mod=10 ** -8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 / i > n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 / i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 + i > n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 + i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 ** i > n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 ** i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 2, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 0, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 0, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - -1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -2, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -0, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -0, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, --1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -2):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -0):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -0):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, --1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "v[i] += v[i + 1]",
      "mutated_line": "v[i] += v[i - 1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i - 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "v[i] += v[i + 1]",
      "mutated_line": "v[i] += v[i * 1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i * 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(2, n // 2 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(2, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(0, n // 2 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(0, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(0, n // 2 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(0, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(-1, n // 2 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(-1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 2 - 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 - 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 2 * 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 * 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 - 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 - 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 * 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 * 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 1, n - 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n - 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 1, n * 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n * 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v[i] = 0",
      "mutated_line": "v[i] = 1",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 1\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v[i] = 0",
      "mutated_line": "v[i] = -1",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = -1\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v[i] = 0",
      "mutated_line": "v[i] = 1",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 1\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n + 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n * 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, +1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, +1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = (v[i] + v[i + 1]) * mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) * mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = v[i] + v[i + 1] + mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = v[i] + v[i + 1] + mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [2] + [0] * (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [2] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [0] + [0] * (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [0] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [0] + [0] * (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [0] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [-1] + [0] * (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [-1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [0] * (len(c) + 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) + 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [0] * (len(c) * 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) * 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(1, m + 2):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 2):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(1, m + 0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 0):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(1, m + 0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 0):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for k in range(1, m + 1):",
      "mutated_line": "for k in range(1, m + -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + -1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [3 * i > n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [3 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [1 * i > n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [1 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [0 * i > n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [0 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [1 * i > n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [1 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [-2 * i > n for i in range(n + 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [-2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i > n for i in range(n - 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n - 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i > n for i in range(n * 1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n * 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "v[i] += v[i + 1]",
      "mutated_line": "v[i] += v[i + 2]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 2]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "v[i] += v[i + 1]",
      "mutated_line": "v[i] += v[i + 0]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 0]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "v[i] += v[i + 1]",
      "mutated_line": "v[i] += v[i + 0]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 0]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "v[i] += v[i + 1]",
      "mutated_line": "v[i] += v[i + -1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + -1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c.append(v[1])",
      "mutated_line": "c.append(v[2])",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[2])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c.append(v[1])",
      "mutated_line": "c.append(v[0])",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[0])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c.append(v[1])",
      "mutated_line": "c.append(v[0])",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[0])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c.append(v[1])",
      "mutated_line": "c.append(v[-1])",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[-1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n / 2 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n / 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n * 2 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n * 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 2 + 2):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 2):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 2 + 0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 0):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 2 + 0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 0):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 2 + -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + -1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "v[i] = v[2 * i]",
      "mutated_line": "v[i] = v[2 / i]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 / i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "v[i] = v[2 * i]",
      "mutated_line": "v[i] = v[2 + i]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 + i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "v[i] = v[2 * i]",
      "mutated_line": "v[i] = v[2 ** i]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 ** i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n / 2 + 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n / 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n * 2 + 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n * 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 2, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 2, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 0, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 0, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 0, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 0, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + -1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + -1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 1, n + 2):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 2):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 1, n + 0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 0):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 1, n + 0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 0):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 2 + 1, n + -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + -1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 2, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 0, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 0, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - -1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -2, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -0, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -0, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, --1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -2):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -0):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -0):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, --1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = (v[i] - v[i + 1]) % mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] - v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = v[i] * v[i + 1] % mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = v[i] * v[i + 1] % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [1] * (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [1] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [-1] * (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [-1] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [1] * (len(c) - 1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [1] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [0] * (len(c) - 2)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 2)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [0] * (len(c) - 0)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 0)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [0] * (len(c) - 0)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 0)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = [1] + [0] * (len(c) - 1)",
      "mutated_line": "f = [1] + [0] * (len(c) - -1)",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - -1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) * mod] + f[:-1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) * mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) + mod] + f[:-1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) + mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i > n for i in range(n + 2)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 2)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i > n for i in range(n + 0)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 0)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i > n for i in range(n + 0)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 0)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [2 * i > n for i in range(n + 1)]",
      "mutated_line": "v = [2 * i > n for i in range(n + -1)]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + -1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 3 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 3 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 1 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 1 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 0 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 0 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // 1 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 1 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, n // 2 + 1):",
      "mutated_line": "for i in range(1, n // -2 + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // -2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v[i] = v[2 * i]",
      "mutated_line": "v[i] = v[3 * i]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[3 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v[i] = v[2 * i]",
      "mutated_line": "v[i] = v[1 * i]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[1 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v[i] = v[2 * i]",
      "mutated_line": "v[i] = v[0 * i]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[0 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v[i] = v[2 * i]",
      "mutated_line": "v[i] = v[1 * i]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[1 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v[i] = v[2 * i]",
      "mutated_line": "v[i] = v[-2 * i]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[-2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 3 + 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 3 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 1 + 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 1 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 0 + 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 0 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // 1 + 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 1 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n // 2 + 1, n + 1):",
      "mutated_line": "for i in range(n // -2 + 1, n + 1):",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // -2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:+1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:+1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = (v[i] + v[i - 1]) % mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i - 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = (v[i] + v[i * 1]) % mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i * 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-2]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-2]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-0]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-0]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-0]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-0]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:--1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:--1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = (v[i] + v[i + 2]) % mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 2]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = (v[i] + v[i + 0]) % mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 0]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = (v[i] + v[i + 0]) % mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 0]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v[i] = (v[i] + v[i + 1]) % mod",
      "mutated_line": "v[i] = (v[i] + v[i + -1]) % mod",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + -1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F / C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F / C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F + C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F + C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f = [sum((F * C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "mutated_line": "f = [sum((F ** C for (F, C) in zip(f, c))) % mod] + f[:-1]",
      "code": "def count_possible_words(n, m, mod=10 ** 8 + 7):\n    v = [2 * i > n for i in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        v[i] += v[i + 1]\n    c = []\n    while v[1]:\n        c.append(v[1])\n        for i in range(1, n // 2 + 1):\n            v[i] = v[2 * i]\n        for i in range(n // 2 + 1, n + 1):\n            v[i] = 0\n        for i in range(n - 1, -1, -1):\n            v[i] = (v[i] + v[i + 1]) % mod\n    f = [1] + [0] * (len(c) - 1)\n    for k in range(1, m + 1):\n        f = [sum((F ** C for (F, C) in zip(f, c))) % mod] + f[:-1]\n    return f[0]"
    }
  ]
}