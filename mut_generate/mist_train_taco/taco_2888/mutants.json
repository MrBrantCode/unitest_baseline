{
  "task_id": "taco_2888",
  "entry_point": "find_shortest_cycle_length",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "min_cycle = float('+inf')",
      "mutated_line": "min_cycle = float('')",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle <= float('+inf') else -1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle <= float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle >= float('+inf') else -1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle >= float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle != float('+inf') else -1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle != float('+inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle < float('+inf') else +1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else +1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if digit == '1':",
      "mutated_line": "if digit != '1':",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit != '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(d[j]) == 3:",
      "mutated_line": "if len(d[j]) != 3:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) != 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle < float('+inf') else -2",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -2"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle < float('+inf') else -0",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle < float('+inf') else -0",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle < float('+inf') else --1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else --1"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "b = '{0:b}'.format(el)[::-1]",
      "mutated_line": "for (j, digit) in enumerate(b):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::+1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if digit == '1':",
      "mutated_line": "if digit == '':",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(d[j]) == 3:",
      "mutated_line": "if len(d[j]) == 4:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 4:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(d[j]) == 3:",
      "mutated_line": "if len(d[j]) == 2:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 2:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(d[j]) == 3:",
      "mutated_line": "if len(d[j]) == 0:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 0:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(d[j]) == 3:",
      "mutated_line": "if len(d[j]) == 1:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 1:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(d[j]) == 3:",
      "mutated_line": "if len(d[j]) == -3:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == -3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 3",
      "mutated_line": "return 4",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 4\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 3",
      "mutated_line": "return 2",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 2\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 3",
      "mutated_line": "return 0",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 0\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 3",
      "mutated_line": "return 1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 1\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 3",
      "mutated_line": "return -3",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return -3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "colors[t] = way + [t]",
      "mutated_line": "colors[t] = way - [t]",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way - [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "colors[t] = way + [t]",
      "mutated_line": "colors[t] = way * [t]",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way * [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return min_cycle if min_cycle < float('+inf') else -1",
      "mutated_line": "return min_cycle if min_cycle < float('') else -1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = '{0:b}'.format(el)[::-1]",
      "mutated_line": "for (j, digit) in enumerate(b):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = ''.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = '{0:b}'.format(el)[::-1]",
      "mutated_line": "for (j, digit) in enumerate(b):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-2]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = '{0:b}'.format(el)[::-1]",
      "mutated_line": "for (j, digit) in enumerate(b):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-0]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = '{0:b}'.format(el)[::-1]",
      "mutated_line": "for (j, digit) in enumerate(b):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-0]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = '{0:b}'.format(el)[::-1]",
      "mutated_line": "for (j, digit) in enumerate(b):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::--1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 1\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = -1\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 1\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "mutated_line": "while len(way) > c or len(colors[t]) > c or way[c] == colors[t][c]:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c or len(colors[t]) > c or way[c] == colors[t][c]:\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c -= 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way or k != way[-1]) or (k, colors[t]) not in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) or (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "mutated_line": "while len(way) >= c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) >= c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "mutated_line": "while len(way) <= c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) <= c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "mutated_line": "while len(way) != c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) != c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "mutated_line": "while len(way) > c and len(colors[t]) >= c and (way[c] == colors[t][c]):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) >= c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "mutated_line": "while len(way) > c and len(colors[t]) <= c and (way[c] == colors[t][c]):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) <= c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "mutated_line": "while len(way) > c and len(colors[t]) != c and (way[c] == colors[t][c]):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) != c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):",
      "mutated_line": "while len(way) > c and len(colors[t]) > c and (way[c] != colors[t][c]):",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] != colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 2\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 0\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 0\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += -1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c - 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c - 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min((len(colors[t]) + len(way) - 2 * c) * 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min((len(colors[t]) + len(way) - 2 * c) * 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way and k != way[-1]) and (k, colors[t]) not in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way and k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way or k != way[-1]) and (k, colors[t]) in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) + 2 * c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) + 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min((len(colors[t]) + len(way)) * (2 * c) + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min((len(colors[t]) + len(way)) * (2 * c) + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 2, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 2, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 0, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 0, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 0, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 0, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + -1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + -1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way or k == way[-1]) and (k, colors[t]) not in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k == way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) - len(way) - 2 * c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) - len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) * len(way) - 2 * c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) * len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 2 / c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 / c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - (2 + c) + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - (2 + c) + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 2 ** c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 ** c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 3 * c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 3 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 1 * c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 1 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 0 * c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 0 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - 1 * c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 1 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)",
      "mutated_line": "min_cycle = min(len(colors[t]) + len(way) - -2 * c + 1, min_cycle)",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - -2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way or k != way[+1]) and (k, colors[t]) not in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[+1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way or k != way[-2]) and (k, colors[t]) not in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-2]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way or k != way[-0]) and (k, colors[t]) not in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-0]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way or k != way[-0]) and (k, colors[t]) not in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[-0]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:",
      "mutated_line": "if (not way or k != way[--1]) and (k, colors[t]) not in next_tier:",
      "code": "from collections import defaultdict\n\ndef find_shortest_cycle_length(n, arr):\n    d = defaultdict(list)\n    dd = defaultdict(list)\n    for (i, el) in enumerate(arr):\n        b = '{0:b}'.format(el)[::-1]\n        for (j, digit) in enumerate(b):\n            if digit == '1':\n                for i2 in d[j]:\n                    dd[i].append(i2)\n                    dd[i2].append(i)\n                d[j].append(i)\n            if len(d[j]) == 3:\n                return 3\n    colors = {i: [] for i in range(len(arr))}\n    min_cycle = float('+inf')\n    for i in range(len(arr)):\n        if colors[i]:\n            continue\n        tier = [(i, [])]\n        next_tier = []\n        while tier:\n            for (t, way) in tier:\n                if colors[t]:\n                    c = 0\n                    while len(way) > c and len(colors[t]) > c and (way[c] == colors[t][c]):\n                        c += 1\n                    min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1, min_cycle)\n                    continue\n                colors[t] = way + [t]\n                for k in dd[t]:\n                    if (not way or k != way[--1]) and (k, colors[t]) not in next_tier:\n                        next_tier.append((k, colors[t]))\n            tier = next_tier\n            next_tier = []\n    return min_cycle if min_cycle < float('+inf') else -1"
    }
  ]
}