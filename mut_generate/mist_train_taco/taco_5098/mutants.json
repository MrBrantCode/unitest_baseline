{
  "task_id": "taco_5098",
  "entry_point": "inv",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "MOD = 998244354\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "MOD = 998244352\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "MOD = -998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD - 2, MOD) * MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) * MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD - 2, MOD) + MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) + MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "self.currentProb += diceProbs[depth] * baseProb",
      "mutated_line": "self.currentProb -= diceProbs[depth] * baseProb",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb -= diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.currentProb = 0",
      "mutated_line": "self.currentProb = 1",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 1\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.currentProb = 0",
      "mutated_line": "self.currentProb = -1",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = -1\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.currentProb = 0",
      "mutated_line": "self.currentProb = 1",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 1\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def update(self, diceProbs, depth=0, baseProb=None):",
      "mutated_line": "def update(self, diceProbs, depth=1, baseProb=None):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=1, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def update(self, diceProbs, depth=0, baseProb=None):",
      "mutated_line": "def update(self, diceProbs, depth=-1, baseProb=None):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=-1, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "def update(self, diceProbs, depth=0, baseProb=None):",
      "mutated_line": "def update(self, diceProbs, depth=1, baseProb=None):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=1, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if baseProb is None:",
      "mutated_line": "if baseProb is not None:",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is not None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if baseProb == 0 or depth >= len(diceProbs):",
      "mutated_line": "if baseProb == 0 and depth >= len(diceProbs):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 and depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "self.currentProb += diceProbs[depth] * baseProb",
      "mutated_line": "self.currentProb += diceProbs[depth] / baseProb",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] / baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "self.currentProb += diceProbs[depth] * baseProb",
      "mutated_line": "self.currentProb += diceProbs[depth] + baseProb",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] + baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "self.currentProb += diceProbs[depth] * baseProb",
      "mutated_line": "self.currentProb += diceProbs[depth] ** baseProb",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] ** baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(2, k + 1):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(2, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(0, k + 1):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(0, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(0, k + 1):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(0, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(-1, k + 1):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(-1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(1, k - 1):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k - 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(1, k * 1):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k * 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v * MOD, MOD - 2, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v * MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v + MOD, MOD - 2, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v + MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD + 2, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD + 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD * 2, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD * 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(self.lastProb, self.currentProb) = (self.currentProb, 0)",
      "mutated_line": "(self.lastProb, self.currentProb) = (self.currentProb, 1)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 1)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(self.lastProb, self.currentProb) = (self.currentProb, 0)",
      "mutated_line": "(self.lastProb, self.currentProb) = (self.currentProb, -1)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, -1)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(self.lastProb, self.currentProb) = (self.currentProb, 0)",
      "mutated_line": "(self.lastProb, self.currentProb) = (self.currentProb, 1)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 1)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if baseProb == 0 or depth >= len(diceProbs):",
      "mutated_line": "if baseProb != 0 or depth >= len(diceProbs):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb != 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if baseProb == 0 or depth >= len(diceProbs):",
      "mutated_line": "if baseProb == 0 or depth > len(diceProbs):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth > len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if baseProb == 0 or depth >= len(diceProbs):",
      "mutated_line": "if baseProb == 0 or depth < len(diceProbs):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth < len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if baseProb == 0 or depth >= len(diceProbs):",
      "mutated_line": "if baseProb == 0 or depth == len(diceProbs):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth == len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "self.child.update(diceProbs, depth + 1, baseProb)",
      "mutated_line": "self.child.update(diceProbs, depth - 1, baseProb)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth - 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "self.child.update(diceProbs, depth + 1, baseProb)",
      "mutated_line": "self.child.update(diceProbs, depth * 1, baseProb)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth * 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(1, k + 2):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 2):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(1, k + 0):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 0):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(1, k + 0):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 0):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for r in range(1, k + 1):",
      "mutated_line": "for r in range(1, k + -1):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + -1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD - 3, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 3, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD - 1, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 1, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD - 0, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 0, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD - 1, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 1, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(v % MOD, MOD - 2, MOD) % MOD",
      "mutated_line": "return pow(v % MOD, MOD - -2, MOD) % MOD",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - -2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if baseProb == 0 or depth >= len(diceProbs):",
      "mutated_line": "if baseProb == 1 or depth >= len(diceProbs):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 1 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if baseProb == 0 or depth >= len(diceProbs):",
      "mutated_line": "if baseProb == -1 or depth >= len(diceProbs):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == -1 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if baseProb == 0 or depth >= len(diceProbs):",
      "mutated_line": "if baseProb == 1 or depth >= len(diceProbs):",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 1 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.child.update(diceProbs, depth + 1, baseProb)",
      "mutated_line": "self.child.update(diceProbs, depth + 2, baseProb)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 2, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.child.update(diceProbs, depth + 1, baseProb)",
      "mutated_line": "self.child.update(diceProbs, depth + 0, baseProb)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 0, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.child.update(diceProbs, depth + 1, baseProb)",
      "mutated_line": "self.child.update(diceProbs, depth + 0, baseProb)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + 0, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.child.update(diceProbs, depth + 1, baseProb)",
      "mutated_line": "self.child.update(diceProbs, depth + -1, baseProb)",
      "code": "MOD = 998244353\n\ndef inv(v):\n    return pow(v % MOD, MOD - 2, MOD) % MOD\n\nclass Node(object):\n\n    def __init__(self, i, p0, rolls):\n        self.child = None\n        self.parents = []\n        self.lastProb = p0\n        self.currentProb = 0\n        self.index = i\n\n    def clear(self):\n        (self.lastProb, self.currentProb) = (self.currentProb, 0)\n\n    def update(self, diceProbs, depth=0, baseProb=None):\n        if baseProb is None:\n            baseProb = self.lastProb\n        if baseProb == 0 or depth >= len(diceProbs):\n            return\n        self.currentProb += diceProbs[depth] * baseProb\n        self.currentProb %= MOD\n        self.child.update(diceProbs, depth + -1, baseProb)\n\ndef calculate_final_probabilities(n, m, k, next_positions, die_probabilities):\n    p0 = inv(n)\n    nodes = [Node(i, p0, k) for i in range(n)]\n    for (i, c) in enumerate(next_positions):\n        nodes[i].child = nodes[c]\n        nodes[c].parents.append(nodes[i])\n    for r in range(1, k + 1):\n        for n in nodes:\n            n.update(die_probabilities)\n        for n in nodes:\n            n.clear()\n    return [n.lastProb for n in nodes]"
    }
  ]
}