{
  "task_id": "taco_15104",
  "entry_point": "find_minimum_time",
  "mutant_count": 155,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "prv = -1",
      "mutated_line": "prv = +1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = +1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 1\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "left = 0",
      "mutated_line": "left = -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = -1\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 1\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 1 <= right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 <= right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 1 >= right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 >= right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 1 != right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 != right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if right == T:",
      "mutated_line": "if right != T:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right != T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "prv = -1",
      "mutated_line": "prv = -2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -2\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "prv = -1",
      "mutated_line": "prv = -0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -0\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "prv = -1",
      "mutated_line": "prv = -0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -0\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "prv = -1",
      "mutated_line": "prv = --1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = --1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "K = [[0] * R for _ in range(P)]",
      "mutated_line": "K = [[0] / R for _ in range(P)]",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] / R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "K = [[0] * R for _ in range(P)]",
      "mutated_line": "K = [[0] + R for _ in range(P)]",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] + R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "K = [[0] * R for _ in range(P)]",
      "mutated_line": "K = [[0] ** R for _ in range(P)]",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] ** R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if prv < t:",
      "mutated_line": "if prv <= t:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv <= t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if prv < t:",
      "mutated_line": "if prv >= t:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv >= t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if prv < t:",
      "mutated_line": "if prv != t:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv != t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "U = [0] * P",
      "mutated_line": "U = [0] / P",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] / P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "U = [0] * P",
      "mutated_line": "U = [0] + P",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] + P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "U = [0] * P",
      "mutated_line": "U = [0] ** P",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] ** P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "updated = 1",
      "mutated_line": "updated = 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 2\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "updated = 1",
      "mutated_line": "updated = 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 0\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "updated = 1",
      "mutated_line": "updated = 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 0\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "updated = 1",
      "mutated_line": "updated = -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = -1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "return sum(U) == P",
      "mutated_line": "return sum(U) != P",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) != P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left - 1 < right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left - 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left * 1 < right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left * 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return +1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return right + 1",
      "mutated_line": "return right - 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right - 1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return right + 1",
      "mutated_line": "return right * 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right * 1"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] += 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] -= 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "updated = 0",
      "mutated_line": "updated = 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 1\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "updated = 0",
      "mutated_line": "updated = -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = -1\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "updated = 0",
      "mutated_line": "updated = 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 1\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 2 < right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 2 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 0 < right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 0 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + 0 < right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 0 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while left + 1 < right:",
      "mutated_line": "while left + -1 < right:",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + -1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "mid = (left + right) >> 1",
      "mutated_line": "mid = left - right >> 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left - right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "mid = (left + right) >> 1",
      "mutated_line": "mid = left * right >> 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left * right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (left + right) >> 1",
      "mutated_line": "mid = left + right >> 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 2\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (left + right) >> 1",
      "mutated_line": "mid = left + right >> 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 0\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (left + right) >> 1",
      "mutated_line": "mid = left + right >> 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 0\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (left + right) >> 1",
      "mutated_line": "mid = left + right >> -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> -1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -2\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -0\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -0\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return --1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return right + 1",
      "mutated_line": "return right + 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 2"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return right + 1",
      "mutated_line": "return right + 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 0"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return right + 1",
      "mutated_line": "return right + 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 0"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return right + 1",
      "mutated_line": "return right + -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "K = [[0] * R for _ in range(P)]",
      "mutated_line": "K = [[1] * R for _ in range(P)]",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[1] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "K = [[0] * R for _ in range(P)]",
      "mutated_line": "K = [[-1] * R for _ in range(P)]",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[-1] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "K = [[0] * R for _ in range(P)]",
      "mutated_line": "K = [[1] * R for _ in range(P)]",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[1] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv - 1, t + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv - 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv * 1, t + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv * 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 1, t - 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t - 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 1, t * 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t * 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - 1] += 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 2\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - 1] += 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 0\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - 1] += 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 0\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - 1] += -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += -1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - 1] -= 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 2\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - 1] -= 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 0\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - 1] -= 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 0\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - 1] -= -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= -1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t - 1, prv + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t - 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t * 1, prv + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t * 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 1, prv - 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv - 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 1, prv * 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv * 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - 1] -= 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 2\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - 1] -= 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 0\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - 1] -= 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 0\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - 1] -= -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= -1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - 1] += 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 2\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - 1] += 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 0\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - 1] += 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 0\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - 1] += -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += -1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "U = [0] * P",
      "mutated_line": "U = [1] * P",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [1] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "U = [0] * P",
      "mutated_line": "U = [-1] * P",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [-1] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "U = [0] * P",
      "mutated_line": "U = [1] * P",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [1] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 2, t + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 2, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 0, t + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 0, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 0, t + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 0, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + -1, t + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + -1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 1, t + 2):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 2):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 1, t + 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 0):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 1, t + 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 0):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(prv + 1, t + 1):",
      "mutated_line": "for i in range(prv + 1, t + -1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + -1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r + 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r + 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r * 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r * 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r + 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r + 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r * 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r * 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 2, prv + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 2, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 0, prv + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 0, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 0, prv + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 0, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + -1, prv + 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + -1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 1, prv + 2):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 2):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 1, prv + 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 0):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 1, prv + 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 0):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(t + 1, prv + 1):",
      "mutated_line": "for i in range(t + 1, prv + -1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + -1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r + 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r + 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r * 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r * 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r + 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r + 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r * 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r * 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if RS[i][j] - K[i][j] > max(S[j], 0):",
      "mutated_line": "if RS[i][j] - K[i][j] >= max(S[j], 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] >= max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if RS[i][j] - K[i][j] > max(S[j], 0):",
      "mutated_line": "if RS[i][j] - K[i][j] <= max(S[j], 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] <= max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if RS[i][j] - K[i][j] > max(S[j], 0):",
      "mutated_line": "if RS[i][j] - K[i][j] != max(S[j], 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] != max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "U[i] = 1",
      "mutated_line": "U[i] = 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 2\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "U[i] = 1",
      "mutated_line": "U[i] = 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 0\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "U[i] = 1",
      "mutated_line": "U[i] = 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 0\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "U[i] = 1",
      "mutated_line": "U[i] = -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = -1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "S[j] += K[i][j]",
      "mutated_line": "S[j] -= K[i][j]",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] -= K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "updated = 1",
      "mutated_line": "updated = 2",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 2\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "updated = 1",
      "mutated_line": "updated = 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 0\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "updated = 1",
      "mutated_line": "updated = 0",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 0\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "updated = 1",
      "mutated_line": "updated = -1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = -1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p + 1][r - 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p + 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p * 1][r - 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p * 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - 2] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 2] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - 0] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 0] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - 0] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 0] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 1][r - -1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - -1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - 2] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 2] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - 0] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 0] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - 0] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 0] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "L[r - 1] -= 1",
      "mutated_line": "L[r - -1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - -1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p + 1][r - 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p + 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p * 1][r - 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p * 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - 2] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 2] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - 0] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 0] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - 0] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 0] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 1][r - -1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - -1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - 2] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 2] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - 0] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 0] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - 0] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 0] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "L[r - 1] += 1",
      "mutated_line": "L[r - -1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - -1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if RS[i][j] - K[i][j] > max(S[j], 0):",
      "mutated_line": "if RS[i][j] + K[i][j] > max(S[j], 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] + K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if RS[i][j] - K[i][j] > max(S[j], 0):",
      "mutated_line": "if RS[i][j] * K[i][j] > max(S[j], 0):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] * K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 2][r - 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 2][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 0][r - 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 0][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - 0][r - 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 0][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "K[p - 1][r - 1] += 1",
      "mutated_line": "K[p - -1][r - 1] += 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - -1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 2][r - 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 2][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 0][r - 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 0][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - 0][r - 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 0][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "K[p - 1][r - 1] -= 1",
      "mutated_line": "K[p - -1][r - 1] -= 1",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - -1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if RS[i][j] - K[i][j] > max(S[j], 0):",
      "mutated_line": "if RS[i][j] - K[i][j] > max(S[j], 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 1):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if RS[i][j] - K[i][j] > max(S[j], 0):",
      "mutated_line": "if RS[i][j] - K[i][j] > max(S[j], -1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], -1):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if RS[i][j] - K[i][j] > max(S[j], 0):",
      "mutated_line": "if RS[i][j] - K[i][j] > max(S[j], 1):",
      "code": "def find_minimum_time(P, R, T, L, RS, LG):\n    prv = -1\n    K = [[0] * R for _ in range(P)]\n\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv + 1, t + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] += 1\n                L[r - 1] -= 1\n        else:\n            for i in range(t + 1, prv + 1):\n                (p, r) = LG[i]\n                K[p - 1][r - 1] -= 1\n                L[r - 1] += 1\n        S = L[:]\n        U = [0] * P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 1):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n    left = 0\n    right = T\n    while left + 1 < right:\n        mid = left + right >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        return -1\n    else:\n        return right + 1"
    }
  ]
}