{
  "task_id": "taco_15216",
  "entry_point": "calculate_possible_strings",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 - 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 * 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m != 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled -= min(l, subsequence[i] - subsequence[i - 1])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled -= min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 * 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 + 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 8\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 6\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 0\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 1\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + -7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "pi = [0] * le",
      "mutated_line": "pi = [0] / le",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] / le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "pi = [0] * le",
      "mutated_line": "pi = [0] + le",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] + le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "pi = [0] * le",
      "mutated_line": "pi = [0] ** le",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] ** le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i = le - 1",
      "mutated_line": "i = le + 1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le + 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i = le - 1",
      "mutated_line": "i = le * 1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le * 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while pi[i] != 0:",
      "mutated_line": "while pi[i] == 0:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] == 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 1:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == -1:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 1:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(2, m):",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(2, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(0, m):",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(0, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(0, m):",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(0, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(-1, m):",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(-1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l or subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l or subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return pow(26, n - filled, MOD)",
      "mutated_line": "return pow(27, n - filled, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(27, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return pow(26, n - filled, MOD)",
      "mutated_line": "return pow(25, n - filled, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(25, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return pow(26, n - filled, MOD)",
      "mutated_line": "return pow(0, n - filled, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(0, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return pow(26, n - filled, MOD)",
      "mutated_line": "return pow(1, n - filled, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(1, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return pow(26, n - filled, MOD)",
      "mutated_line": "return pow(-26, n - filled, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(-26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return pow(26, n - filled, MOD)",
      "mutated_line": "return pow(26, n + filled, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n + filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return pow(26, n - filled, MOD)",
      "mutated_line": "return pow(26, n * filled, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n * filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 11 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 9 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 0 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 1 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = -10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 10 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 8 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 0 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 1 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** -9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, le):",
      "mutated_line": "for i in range(2, le):",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(2, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, le):",
      "mutated_line": "for i in range(0, le):",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(0, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, le):",
      "mutated_line": "for i in range(0, le):",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(0, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, le):",
      "mutated_line": "for i in range(-1, le):",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(-1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "while j > 0 and s[i] != s[j]:",
      "mutated_line": "while j > 0 or s[i] != s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 or s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if s[i] == s[j]:",
      "mutated_line": "if s[i] != s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] != s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j -= 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = le - 1",
      "mutated_line": "i = le - 2",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 2\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = le - 1",
      "mutated_line": "i = le - 0",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 0\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = le - 1",
      "mutated_line": "i = le - 0",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 0\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = le - 1",
      "mutated_line": "i = le - -1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - -1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while pi[i] != 0:",
      "mutated_line": "while pi[i] != 1:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 1:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while pi[i] != 0:",
      "mutated_line": "while pi[i] != -1:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != -1:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while pi[i] != 0:",
      "mutated_line": "while pi[i] != 1:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 1:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "i = pi[i] - 1",
      "mutated_line": "i = pi[i] + 1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] + 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "i = pi[i] - 1",
      "mutated_line": "i = pi[i] * 1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] * 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return pow(26, n, MOD)",
      "mutated_line": "return pow(27, n, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(27, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return pow(26, n, MOD)",
      "mutated_line": "return pow(25, n, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(25, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return pow(26, n, MOD)",
      "mutated_line": "return pow(0, n, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(0, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return pow(26, n, MOD)",
      "mutated_line": "return pow(1, n, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(1, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return pow(26, n, MOD)",
      "mutated_line": "return pow(-26, n, MOD)",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(-26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] <= l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] <= l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] >= l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] >= l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] != l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] != l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 1\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return -1\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 1\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled += min(l, subsequence[i] + subsequence[i - 1])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] + subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled += min(l, subsequence[i] * subsequence[i - 1])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] * subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pi = [0] * le",
      "mutated_line": "pi = [1] * le",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [1] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pi = [0] * le",
      "mutated_line": "pi = [-1] * le",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [-1] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pi = [0] * le",
      "mutated_line": "pi = [1] * le",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [1] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "j = pi[i - 1]",
      "mutated_line": "j = pi[i + 1]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i + 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "j = pi[i - 1]",
      "mutated_line": "j = pi[i * 1]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i * 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while j > 0 and s[i] != s[j]:",
      "mutated_line": "while j >= 0 and s[i] != s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j >= 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while j > 0 and s[i] != s[j]:",
      "mutated_line": "while j <= 0 and s[i] != s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j <= 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while j > 0 and s[i] != s[j]:",
      "mutated_line": "while j != 0 and s[i] != s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j != 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while j > 0 and s[i] != s[j]:",
      "mutated_line": "while j > 0 and s[i] == s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] == s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 2\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 0\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 0\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += -1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "w.add(le - pi[i])",
      "mutated_line": "w.add(le + pi[i])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le + pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "w.add(le - pi[i])",
      "mutated_line": "w.add(le * pi[i])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le * pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i = pi[i] - 1",
      "mutated_line": "i = pi[i] - 2",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 2\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i = pi[i] - 1",
      "mutated_line": "i = pi[i] - 0",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 0\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i = pi[i] - 1",
      "mutated_line": "i = pi[i] - 0",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 0\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i = pi[i] - 1",
      "mutated_line": "i = pi[i] - -1",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - -1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] + subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] + subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] * subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] * subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] + subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] + subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] * subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] * subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "j = pi[i - 1]",
      "mutated_line": "j = pi[i - 2]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 2]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "j = pi[i - 1]",
      "mutated_line": "j = pi[i - 0]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 0]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "j = pi[i - 1]",
      "mutated_line": "j = pi[i - 0]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 0]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "j = pi[i - 1]",
      "mutated_line": "j = pi[i - -1]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - -1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while j > 0 and s[i] != s[j]:",
      "mutated_line": "while j > 1 and s[i] != s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 1 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while j > 0 and s[i] != s[j]:",
      "mutated_line": "while j > -1 and s[i] != s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > -1 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while j > 0 and s[i] != s[j]:",
      "mutated_line": "while j > 1 and s[i] != s[j]:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 1 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "j = pi[j - 1]",
      "mutated_line": "j = pi[j + 1]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j + 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "j = pi[j - 1]",
      "mutated_line": "j = pi[j * 1]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j * 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled += min(l, subsequence[i] - subsequence[i + 1])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i + 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled += min(l, subsequence[i] - subsequence[i * 1])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i * 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = pi[j - 1]",
      "mutated_line": "j = pi[j - 2]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 2]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = pi[j - 1]",
      "mutated_line": "j = pi[j - 0]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 0]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = pi[j - 1]",
      "mutated_line": "j = pi[j - 0]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 0]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = pi[j - 1]",
      "mutated_line": "j = pi[j - -1]",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - -1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i + 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i + 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i * 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i * 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i + 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i + 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i * 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i * 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled += min(l, subsequence[i] - subsequence[i - 2])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 2])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled += min(l, subsequence[i] - subsequence[i - 0])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 0])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled += min(l, subsequence[i] - subsequence[i - 0])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 0])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "filled += min(l, subsequence[i] - subsequence[i - 1])",
      "mutated_line": "filled += min(l, subsequence[i] - subsequence[i - -1])",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - -1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 2] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 2] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 0] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 0] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 0] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 0] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - -1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - -1] < l and subsequence[i] - subsequence[i - 1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 2] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 2] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 0] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 0] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 0] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 0] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - 1] not in pre:",
      "mutated_line": "if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - -1] not in pre:",
      "code": "def calculate_possible_strings(n, m, p, subsequence):\n    MOD = 10 ** 9 + 7\n\n    def matching(s):\n        le = len(s)\n        pi = [0] * le\n        for i in range(1, le):\n            j = pi[i - 1]\n            while j > 0 and s[i] != s[j]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        w = set()\n        i = le - 1\n        while pi[i] != 0:\n            w.add(le - pi[i])\n            i = pi[i] - 1\n        return w\n    if m == 0:\n        return pow(26, n, MOD)\n    l = len(p)\n    pre = matching(p)\n    filled = l\n    for i in range(1, m):\n        if subsequence[i] - subsequence[i - 1] < l and subsequence[i] - subsequence[i - -1] not in pre:\n            return 0\n        filled += min(l, subsequence[i] - subsequence[i - 1])\n    return pow(26, n - filled, MOD)"
    }
  ]
}