{
  "task_id": "taco_691",
  "entry_point": "max_manhattan_distance",
  "mutant_count": 233,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] / (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] / (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] + (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] + (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] ** (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] ** (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] / (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] / (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] + (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] + (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] ** (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] ** (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "lr_dp1[0] += i",
      "mutated_line": "lr_dp1[0] -= i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] -= i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "lr_dp2[0] += i",
      "mutated_line": "lr_dp2[0] -= i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] -= i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] / (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] / (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] + (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] + (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] ** (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] ** (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] / (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] / (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] + (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] + (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] ** (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] ** (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "ud_dp1[0] += i",
      "mutated_line": "ud_dp1[0] -= i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] -= i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "ud_dp2[0] += i",
      "mutated_line": "ud_dp2[0] -= i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] -= i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 1\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = -1\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 1\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if c == 'R':",
      "mutated_line": "if c != 'R':",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c != 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] * (lr_length - 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length - 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] * (lr_length * 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length * 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] * (lr_length - 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length - 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] * (lr_length * 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length * 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] * (ud_length - 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length - 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] * (ud_length * 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length * 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] * (ud_length - 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length - 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] * (ud_length * 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length * 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(2, lr_length + 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(2, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(0, lr_length + 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(0, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(0, lr_length + 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(0, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(-1, lr_length + 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(-1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(1, lr_length - 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length - 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(1, lr_length * 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length * 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(2, ud_length + 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(2, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(0, ud_length + 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(0, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(0, ud_length + 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(0, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(-1, ud_length + 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(-1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(1, ud_length - 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length - 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(1, ud_length * 1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length * 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if c == 'R':",
      "mutated_line": "if c == '':",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == '':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif c == 'L':",
      "mutated_line": "elif c != 'L':",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c != 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [1] * (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [1] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [-1] * (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [-1] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [1] * (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [1] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] * (lr_length + 2)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 2)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] * (lr_length + 0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 0)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] * (lr_length + 0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 0)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lr_dp1 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp1 = [0] * (lr_length + -1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + -1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [1] * (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [1] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [-1] * (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [-1] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [1] * (lr_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [1] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] * (lr_length + 2)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 2)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] * (lr_length + 0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 0)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] * (lr_length + 0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 0)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lr_dp2 = [0] * (lr_length + 1)",
      "mutated_line": "lr_dp2 = [0] * (lr_length + -1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + -1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(lr_length, 0, -1):",
      "mutated_line": "for j in range(lr_length, 1, -1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 1, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(lr_length, 0, -1):",
      "mutated_line": "for j in range(lr_length, -1, -1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, -1, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(lr_length, 0, -1):",
      "mutated_line": "for j in range(lr_length, 1, -1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 1, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "for j in range(lr_length, 0, -1):",
      "mutated_line": "for j in range(lr_length, 0, +1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, +1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) - i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) - i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) * (i * (-1) ** j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) * (i * (-1) ** j)\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) - i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) - i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) * (i * (-1) ** j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) * (i * (-1) ** j)\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "lr_dp1[0] += i",
      "mutated_line": "lr_dp1[1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[1] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "lr_dp1[0] += i",
      "mutated_line": "lr_dp1[-1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[-1] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "lr_dp1[0] += i",
      "mutated_line": "lr_dp1[1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[1] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lr_dp2[0] += i",
      "mutated_line": "lr_dp2[1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[1] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lr_dp2[0] += i",
      "mutated_line": "lr_dp2[-1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[-1] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lr_dp2[0] += i",
      "mutated_line": "lr_dp2[1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[1] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [1] * (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [1] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [-1] * (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [-1] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [1] * (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [1] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] * (ud_length + 2)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 2)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] * (ud_length + 0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 0)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] * (ud_length + 0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 0)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ud_dp1 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp1 = [0] * (ud_length + -1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + -1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [1] * (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [1] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [-1] * (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [-1] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [1] * (ud_length + 1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [1] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] * (ud_length + 2)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 2)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] * (ud_length + 0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 0)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] * (ud_length + 0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 0)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ud_dp2 = [0] * (ud_length + 1)",
      "mutated_line": "ud_dp2 = [0] * (ud_length + -1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + -1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(ud_length, 0, -1):",
      "mutated_line": "for j in range(ud_length, 1, -1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 1, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(ud_length, 0, -1):",
      "mutated_line": "for j in range(ud_length, -1, -1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, -1, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(ud_length, 0, -1):",
      "mutated_line": "for j in range(ud_length, 1, -1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 1, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "for j in range(ud_length, 0, -1):",
      "mutated_line": "for j in range(ud_length, 0, +1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, +1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) - i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) - i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) * (i * (-1) ** j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) * (i * (-1) ** j)\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) - i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) - i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) * (i * (-1) ** j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) * (i * (-1) ** j)\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ud_dp1[0] += i",
      "mutated_line": "ud_dp1[1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[1] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ud_dp1[0] += i",
      "mutated_line": "ud_dp1[-1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[-1] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ud_dp1[0] += i",
      "mutated_line": "ud_dp1[1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[1] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ud_dp2[0] += i",
      "mutated_line": "ud_dp2[1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[1] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ud_dp2[0] += i",
      "mutated_line": "ud_dp2[-1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[-1] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ud_dp2[0] += i",
      "mutated_line": "ud_dp2[1] += i",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[1] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(1, lr_length + 2):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 2):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(1, lr_length + 0):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 0):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(1, lr_length + 0):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 0):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(1, lr_length + 1):",
      "mutated_line": "for i in range(1, lr_length + -1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + -1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(1, ud_length + 2):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 2):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(1, ud_length + 0):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 0):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(1, ud_length + 0):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 0):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, ud_length + 1):",
      "mutated_line": "for i in range(1, ud_length + -1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + -1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K - 1, lr_length + 1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K - 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K * 1, lr_length + 1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K * 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 1, lr_length - 1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length - 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 1, lr_length * 1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length * 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])",
      "mutated_line": "ans = max(ans, lr_acc[i] - ud_acc[min(K - i, ud_length)])",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] - ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])",
      "mutated_line": "ans = max(ans, lr_acc[i] * ud_acc[min(K - i, ud_length)])",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] * ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrs.append(1)",
      "mutated_line": "lrs.append(2)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(2)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrs.append(1)",
      "mutated_line": "lrs.append(0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(0)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrs.append(1)",
      "mutated_line": "lrs.append(0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(0)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lrs.append(1)",
      "mutated_line": "lrs.append(-1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(-1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif c == 'L':",
      "mutated_line": "elif c == '':",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == '':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif c == 'U':",
      "mutated_line": "elif c != 'U':",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c != 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(lr_length, 0, -1):",
      "mutated_line": "for j in range(lr_length, 0, -2):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -2):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(lr_length, 0, -1):",
      "mutated_line": "for j in range(lr_length, 0, -0):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -0):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(lr_length, 0, -1):",
      "mutated_line": "for j in range(lr_length, 0, -0):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -0):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for j in range(lr_length, 0, -1):",
      "mutated_line": "for j in range(lr_length, 0, --1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, --1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i / (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i / (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + (i + (-1) ** j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + (i + (-1) ** j)\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i ** (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i ** (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i / (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i / (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + (i + (-1) ** j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + (i + (-1) ** j)\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i ** (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i ** (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(ud_length, 0, -1):",
      "mutated_line": "for j in range(ud_length, 0, -2):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -2):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(ud_length, 0, -1):",
      "mutated_line": "for j in range(ud_length, 0, -0):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -0):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(ud_length, 0, -1):",
      "mutated_line": "for j in range(ud_length, 0, -0):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -0):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(ud_length, 0, -1):",
      "mutated_line": "for j in range(ud_length, 0, --1):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, --1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i / (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i / (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + (i + (-1) ** j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + (i + (-1) ** j)\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i ** (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i ** (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i / (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i / (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + (i + (-1) ** j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + (i + (-1) ** j)\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i ** (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i ** (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "lr_acc = [abs(lr_dp1[0])]",
      "mutated_line": "lr_acc = [abs(lr_dp1[1])]",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[1])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "lr_acc = [abs(lr_dp1[0])]",
      "mutated_line": "lr_acc = [abs(lr_dp1[-1])]",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[-1])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "lr_acc = [abs(lr_dp1[0])]",
      "mutated_line": "lr_acc = [abs(lr_dp1[1])]",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[1])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ud_acc = [abs(ud_dp1[0])]",
      "mutated_line": "ud_acc = [abs(ud_dp1[1])]",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[1])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ud_acc = [abs(ud_dp1[0])]",
      "mutated_line": "ud_acc = [abs(ud_dp1[-1])]",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[-1])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ud_acc = [abs(ud_dp1[0])]",
      "mutated_line": "ud_acc = [abs(ud_dp1[1])]",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[1])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 2, lr_length + 1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 2, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 0, lr_length + 1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 0, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 0, lr_length + 1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 0, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + -1, lr_length + 1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + -1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 1, lr_length + 2)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 2)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 1, lr_length + 0)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 0)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 1, lr_length + 0)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 0)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(min(K + 1, lr_length + 1)):",
      "mutated_line": "for i in range(min(K + 1, lr_length + -1)):",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + -1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "lrs.append(-1)",
      "mutated_line": "lrs.append(+1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(+1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif c == 'U':",
      "mutated_line": "elif c == '':",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == '':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif c == 'D':",
      "mutated_line": "elif c != 'D':",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c != 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1 * j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1 * j)\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1 + j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1 + j)\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1 * j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1 * j)\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1 + j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1 + j)\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1 * j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1 * j)\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1 + j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1 + j)\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1 * j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1 * j)\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1 + j)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1 + j)\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "mutated_line": "lr_acc.append(max(lr_acc[+1], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[+1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "mutated_line": "ud_acc.append(max(ud_acc[+1], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[+1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "lrs.append(-1)",
      "mutated_line": "lrs.append(-2)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-2)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "lrs.append(-1)",
      "mutated_line": "lrs.append(-0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-0)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "lrs.append(-1)",
      "mutated_line": "lrs.append(-0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-0)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "lrs.append(-1)",
      "mutated_line": "lrs.append(--1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(--1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "uds.append(-1)",
      "mutated_line": "uds.append(+1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(+1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif c == 'D':",
      "mutated_line": "elif c == '':",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == '':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j + 1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j + 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j * 1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j * 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (+1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (+1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j + 1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j + 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j * 1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j * 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (+1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (+1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j + 1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j + 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j * 1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j * 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (+1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (+1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j + 1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j + 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j * 1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j * 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (+1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (+1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "mutated_line": "lr_acc.append(max(lr_acc[-2], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-2], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "mutated_line": "lr_acc.append(max(lr_acc[-0], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-0], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "mutated_line": "lr_acc.append(max(lr_acc[-0], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-0], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "mutated_line": "lr_acc.append(max(lr_acc[--1], abs(lr_dp1[i]), abs(lr_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[--1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "mutated_line": "ud_acc.append(max(ud_acc[-2], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-2], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "mutated_line": "ud_acc.append(max(ud_acc[-0], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-0], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "mutated_line": "ud_acc.append(max(ud_acc[-0], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-0], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "mutated_line": "ud_acc.append(max(ud_acc[--1], abs(ud_dp1[i]), abs(ud_dp2[i])))",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[--1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])",
      "mutated_line": "ans = max(ans, lr_acc[i] + ud_acc[min(K + i, ud_length)])",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K + i, ud_length)])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])",
      "mutated_line": "ans = max(ans, lr_acc[i] + ud_acc[min(K * i, ud_length)])",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K * i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "uds.append(-1)",
      "mutated_line": "uds.append(-2)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-2)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "uds.append(-1)",
      "mutated_line": "uds.append(-0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-0)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "uds.append(-1)",
      "mutated_line": "uds.append(-0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-0)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "uds.append(-1)",
      "mutated_line": "uds.append(--1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(--1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "uds.append(1)",
      "mutated_line": "uds.append(2)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(2)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "uds.append(1)",
      "mutated_line": "uds.append(0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(0)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "uds.append(1)",
      "mutated_line": "uds.append(0)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(0)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "uds.append(1)",
      "mutated_line": "uds.append(-1)",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(-1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 2]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 2]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 0]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 0]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 0]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 0]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - -1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - -1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-2) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-2) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-0) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-0) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-0) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-0) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (--1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (--1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 2]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 2]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 0]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 0]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 0]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 0]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - -1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - -1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-2) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-2) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-0) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-0) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-0) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-0) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (--1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (--1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 2]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 2]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 0]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 0]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 0]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 0]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - -1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - -1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-2) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-2) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-0) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-0) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-0) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-0) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (--1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (--1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 2]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 2]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 0]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 0]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 0]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 0]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - -1]) + i * (-1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - -1]) + i * (-1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-2) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-2) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-0) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-0) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-0) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-0) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j",
      "mutated_line": "ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (--1) ** j",
      "code": "def max_manhattan_distance(S: str, K: int) -> int:\n    lrs = []\n    uds = []\n    for c in S:\n        if c == 'R':\n            lrs.append(1)\n        elif c == 'L':\n            lrs.append(-1)\n        elif c == 'U':\n            uds.append(-1)\n        elif c == 'D':\n            uds.append(1)\n    lr_length = len(lrs)\n    ud_length = len(uds)\n    lr_dp1 = [0] * (lr_length + 1)\n    lr_dp2 = [0] * (lr_length + 1)\n    for i in lrs:\n        for j in range(lr_length, 0, -1):\n            lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j\n            lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j\n        lr_dp1[0] += i\n        lr_dp2[0] += i\n    ud_dp1 = [0] * (ud_length + 1)\n    ud_dp2 = [0] * (ud_length + 1)\n    for i in uds:\n        for j in range(ud_length, 0, -1):\n            ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j\n            ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (--1) ** j\n        ud_dp1[0] += i\n        ud_dp2[0] += i\n    lr_acc = [abs(lr_dp1[0])]\n    for i in range(1, lr_length + 1):\n        lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))\n    ud_acc = [abs(ud_dp1[0])]\n    for i in range(1, ud_length + 1):\n        ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))\n    ans = 0\n    for i in range(min(K + 1, lr_length + 1)):\n        ans = max(ans, lr_acc[i] + ud_acc[min(K - i, ud_length)])\n    return ans"
    }
  ]
}