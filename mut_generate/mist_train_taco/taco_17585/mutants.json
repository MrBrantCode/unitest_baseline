{
  "task_id": "taco_17585",
  "entry_point": "can_chef_win_in_one_move",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(N - K + 1):",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K - 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(N - K + 1):",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range((N - K) * 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 and anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 and anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if board[i][j] == 'X':",
      "mutated_line": "if board[i][j] != 'X':",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] != 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(N - K + 1):",
      "mutated_line": "for j in range(N - K - 1):",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K - 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(N - K + 1):",
      "mutated_line": "for j in range((N - K) * 1):",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range((N - K) * 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) > K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) > K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) < K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) < K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) == K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) == K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum > K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum > K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum < K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum < K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum == K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum == K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(N - K + 1):",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N + K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(N - K + 1):",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N * K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - K + 1):",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 2):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - K + 1):",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 0):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - K + 1):",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 0):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - K + 1):",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + -1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum > K - 1 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum > K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum < K - 1 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum < K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum == K - 1 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum == K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum > K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum > K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum < K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum < K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum == K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum == K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return False\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if board[i][j] == 'X':",
      "mutated_line": "if board[i][j] == '':",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == '':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "board[i][j] = 1",
      "mutated_line": "board[i][j] = 2",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 2\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "board[i][j] = 1",
      "mutated_line": "board[i][j] = 0",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 0\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "board[i][j] = 1",
      "mutated_line": "board[i][j] = 0",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 0\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "board[i][j] = 1",
      "mutated_line": "board[i][j] = -1",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = -1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif board[i][j] == '.':",
      "mutated_line": "elif board[i][j] != '.':",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] != '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(N - K + 1):",
      "mutated_line": "for j in range(N + K + 1):",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N + K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(N - K + 1):",
      "mutated_line": "for j in range(N * K + 1):",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N * K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(N - K + 1):",
      "mutated_line": "for j in range(N - K + 2):",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 2):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(N - K + 1):",
      "mutated_line": "for j in range(N - K + 0):",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 0):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(N - K + 1):",
      "mutated_line": "for j in range(N - K + 0):",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 0):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(N - K + 1):",
      "mutated_line": "for j in range(N - K + -1):",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + -1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) >= K + 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K + 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) >= K * 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K * 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return False\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum >= K + 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K + 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum >= K * 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K * 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return False\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K + 1 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K + 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K * 1 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K * 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K + 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K + 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K * 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K * 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif board[i][j] == '.':",
      "mutated_line": "elif board[i][j] == '':",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "board[i][j] = 0",
      "mutated_line": "board[i][j] = 1",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 1\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "board[i][j] = 0",
      "mutated_line": "board[i][j] = -1",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = -1\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "board[i][j] = 0",
      "mutated_line": "board[i][j] = 1",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 1\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "board[i][j] = -1",
      "mutated_line": "board[i][j] = +1",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = +1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) >= K - 2:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 2:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) >= K - 0:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 0:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) >= K - 0:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 0:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j + K]) >= K - -1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - -1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum >= K - 2:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 2:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum >= K - 0:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 0:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum >= K - 0:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 0:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if col_sum >= K - 1:",
      "mutated_line": "if col_sum >= K - -1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - -1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "main_diag_sum = sum(board[i + x][i + x] for x in range(K))",
      "mutated_line": "main_diag_sum = sum((board[i + x][i - x] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i - x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "main_diag_sum = sum(board[i + x][i + x] for x in range(K))",
      "mutated_line": "main_diag_sum = sum((board[i + x][i * x] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i * x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x + 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x + 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][(N - i - x) * 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][(N - i - x) * 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 2 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 2 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 0 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 0 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 0 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 0 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - -1 or anti_diag_sum >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - -1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 2:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 2:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 0:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 0:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 0:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 0:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:",
      "mutated_line": "if main_diag_sum >= K - 1 or anti_diag_sum >= K - -1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - -1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "board[i][j] = -1",
      "mutated_line": "board[i][j] = -2",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -2\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "board[i][j] = -1",
      "mutated_line": "board[i][j] = -0",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -0\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "board[i][j] = -1",
      "mutated_line": "board[i][j] = -0",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -0\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "board[i][j] = -1",
      "mutated_line": "board[i][j] = --1",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = --1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "main_diag_sum = sum(board[i + x][i + x] for x in range(K))",
      "mutated_line": "main_diag_sum = sum((board[i - x][i + x] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i - x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "main_diag_sum = sum(board[i + x][i + x] for x in range(K))",
      "mutated_line": "main_diag_sum = sum((board[i * x][i + x] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i * x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i - x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i - x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i * x][N - i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i * x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i + x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i + x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][(N - i) * x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][(N - i) * x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 2] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 2] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 0] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 0] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - 0] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 0] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N - i - x - -1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - -1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j - K]) >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j - K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if sum(board[i][j:j + K]) >= K - 1:",
      "mutated_line": "if sum(board[i][j:j * K]) >= K - 1:",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j * K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "col_sum = sum(board[x][i] for x in range(j, j + K))",
      "mutated_line": "col_sum = sum((board[x][i] for x in range(j, j - K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j - K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "col_sum = sum(board[x][i] for x in range(j, j + K))",
      "mutated_line": "col_sum = sum((board[x][i] for x in range(j, j * K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j * K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N - i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N + i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N + i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "anti_diag_sum = sum(board[i + x][N - i - x - 1] for x in range(K))",
      "mutated_line": "anti_diag_sum = sum((board[i + x][N * i - x - 1] for x in range(K)))",
      "code": "def can_chef_win_in_one_move(board, N, K):\n    \"\"\"\n    Determines if Chef can win in one move in a Tic-Tac-Toe game on an NxN board with a winning length of K.\n\n    Parameters:\n    board (list of list of str): The NxN board configuration where each cell is 'X', 'O', or '.'.\n    N (int): The size of the board (NxN).\n    K (int): The length of continuous 'X's or 'O's required to win.\n\n    Returns:\n    bool: True if Chef can win in one move, False otherwise.\n    \"\"\"\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'X':\n                board[i][j] = 1\n            elif board[i][j] == '.':\n                board[i][j] = 0\n            else:\n                board[i][j] = -1\n    for i in range(N):\n        for j in range(N - K + 1):\n            if sum(board[i][j:j + K]) >= K - 1:\n                return True\n            col_sum = sum((board[x][i] for x in range(j, j + K)))\n            if col_sum >= K - 1:\n                return True\n    for i in range(N - K + 1):\n        main_diag_sum = sum((board[i + x][i + x] for x in range(K)))\n        anti_diag_sum = sum((board[i + x][N * i - x - 1] for x in range(K)))\n        if main_diag_sum >= K - 1 or anti_diag_sum >= K - 1:\n            return True\n    return False"
    }
  ]
}