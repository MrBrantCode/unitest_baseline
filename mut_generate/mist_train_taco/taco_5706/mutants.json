{
  "task_id": "taco_5706",
  "entry_point": "max_apple_groups",
  "mutant_count": 154,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def max_apple_groups(n):\n    if n != 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "counter = 0",
      "mutated_line": "counter = 1",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 1\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "counter = 0",
      "mutated_line": "counter = -1",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = -1\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "counter = 0",
      "mutated_line": "counter = 1",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 1\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def max_apple_groups(n):\n    if n == 2:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def max_apple_groups(n):\n    if n == 0:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def max_apple_groups(n):\n    if n == 0:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def max_apple_groups(n):\n    if n == -1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: True for i in range(2, n + 1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: True for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % 2 != 0:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 != 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (0, [])",
      "mutated_line": "return (1, [])",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (1, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (0, [])",
      "mutated_line": "return (-1, [])",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (-1, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (0, [])",
      "mutated_line": "return (1, [])",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (1, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "primes = primes[::-1]",
      "mutated_line": "primes = primes[::+1]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::+1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(2, n // prime + 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(2, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(0, n // prime + 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(0, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(0, n // prime + 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(0, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(-1, n // prime + 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(-1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(1, n // prime - 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime - 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(1, n // prime * 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime * 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) * 2 == 0:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) * 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) + 2 == 0:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) + 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % 2 == 1:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 1:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % 2 == -1:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == -1:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % 2 == 1:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 1:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "counter += 1",
      "mutated_line": "counter -= 1",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter -= 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime * 2] = True",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = True\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "counter += 1",
      "mutated_line": "counter -= 1",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter -= 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(3, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(3, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(1, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(1, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(0, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(0, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(1, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(1, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(-2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(-2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) - 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) - 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) * 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) * 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "primes = primes[::-1]",
      "mutated_line": "primes = primes[::-2]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-2]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "primes = primes[::-1]",
      "mutated_line": "primes = primes[::-0]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-0]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "primes = primes[::-1]",
      "mutated_line": "primes = primes[::-0]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-0]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "primes = primes[::-1]",
      "mutated_line": "primes = primes[::--1]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::--1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(3, n + 1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(3, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(1, n + 1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(1, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(0, n + 1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(0, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(1, n + 1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(1, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(-2, n + 1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(-2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(2, n - 1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n - 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(2, n * 1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n * 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(1, n / prime + 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n / prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(1, n * prime + 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n * prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(1, n // prime + 2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 2):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(1, n // prime + 0):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 0):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(1, n // prime + 0):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 0):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(1, n // prime + 1):",
      "mutated_line": "for x in range(1, n // prime + -1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + -1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "used[prime * x] = True",
      "mutated_line": "used[prime * x] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = False\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % 3 == 0:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 3 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % 1 == 0:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 1 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % 0 == 0:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 0 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % 1 == 0:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 1 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(multiples) % 2 == 0:",
      "mutated_line": "if len(multiples) % -2 == 0:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % -2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(1, len(multiples), 2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(1, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(-1, len(multiples), 2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(-1, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(1, len(multiples), 2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(1, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), 3):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 3):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 1):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), 0):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 0):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 1):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), -2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), -2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counter += 1",
      "mutated_line": "counter += 2",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 2\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counter += 1",
      "mutated_line": "counter += 0",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 0\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counter += 1",
      "mutated_line": "counter += 0",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 0\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counter += 1",
      "mutated_line": "counter += -1",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += -1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "multiples.pop(1)",
      "mutated_line": "multiples.pop(2)",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(2)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "multiples.pop(1)",
      "mutated_line": "multiples.pop(0)",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(0)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "multiples.pop(1)",
      "mutated_line": "multiples.pop(0)",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(0)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "multiples.pop(1)",
      "mutated_line": "multiples.pop(-1)",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(-1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime / 2] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime / 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime + 2] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime + 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime ** 2] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime ** 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(1, len(multiples), 2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(1, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(-1, len(multiples), 2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(-1, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(1, len(multiples), 2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(1, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), 3):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 3):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 1):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), 0):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 0):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), 1):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 1):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(0, len(multiples), 2):",
      "mutated_line": "for j in range(0, len(multiples), -2):",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), -2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "counter += 1",
      "mutated_line": "counter += 2",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 2\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "counter += 1",
      "mutated_line": "counter += 0",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 0\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "counter += 1",
      "mutated_line": "counter += 0",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 0\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "counter += 1",
      "mutated_line": "counter += -1",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += -1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 2) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 2) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 0) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 0) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 0) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 0) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + -1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + -1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y == 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y == 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(2, n + 2)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 2)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(2, n + 0)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 0)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(2, n + 0)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 0)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "used = {i: False for i in range(2, n + 1)}",
      "mutated_line": "used = {i: False for i in range(2, n + -1)}",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + -1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if not used[prime * x]:",
      "mutated_line": "if not used[prime / x]:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime / x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if not used[prime * x]:",
      "mutated_line": "if not used[prime + x]:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime + x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if not used[prime * x]:",
      "mutated_line": "if not used[prime ** x]:",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime ** x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "multiples.append(prime * x)",
      "mutated_line": "multiples.append(prime / x)",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime / x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "multiples.append(prime * x)",
      "mutated_line": "multiples.append(prime + x)",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime + x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "multiples.append(prime * x)",
      "mutated_line": "multiples.append(prime ** x)",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime ** x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "used[prime * x] = True",
      "mutated_line": "used[prime / x] = True",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime / x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "used[prime * x] = True",
      "mutated_line": "used[prime + x] = True",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime + x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "used[prime * x] = True",
      "mutated_line": "used[prime ** x] = True",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime ** x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime * 3] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 3] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime * 1] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 1] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime * 0] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 0] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime * 1] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 1] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[prime * 2] = False",
      "mutated_line": "used[prime * -2] = False",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * -2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n * 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n * 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n // 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n // 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x * y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x * y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x + y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x + y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 1 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 1 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != -1 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != -1 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 1 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 1 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 3) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 3) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 1) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 1) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 0) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 0) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 1) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 1) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / -2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / -2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(3, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(3, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(1, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(1, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(0, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(0, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(1, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(1, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(-2, int(x ** 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(-2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) - 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) - 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) * 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) * 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j - 1]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j - 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j * 1]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j * 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j - 1]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j - 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j * 1]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j * 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 2)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 2)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 0)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 0)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 0)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 0)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + -1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + -1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j + 2]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 2]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j + 0]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 0]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j + 0]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 0]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j + -1]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + -1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j + 2]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 2]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j + 0]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 0]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j + 0]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 0]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "outputs.append((multiples[j], multiples[j + 1]))",
      "mutated_line": "outputs.append((multiples[j], multiples[j + -1]))",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + -1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x * 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x * 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x + 0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x + 0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 1.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 1.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** -0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** -0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 1) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 1) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** 0.5) + 1)))]",
      "mutated_line": "primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** -0.5) + 1)))]",
      "code": "def max_apple_groups(n):\n    if n == 1:\n        return (0, [])\n    primes = [x for x in range(2, int(n / 2) + 1) if all((x % y != 0 for y in range(2, int(x ** -0.5) + 1)))]\n    primes = primes[::-1]\n    used = {i: False for i in range(2, n + 1)}\n    outputs = []\n    counter = 0\n    for prime in primes:\n        multiples = []\n        for x in range(1, n // prime + 1):\n            if not used[prime * x]:\n                multiples.append(prime * x)\n                used[prime * x] = True\n        if len(multiples) % 2 == 0:\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n        else:\n            multiples.pop(1)\n            used[prime * 2] = False\n            for j in range(0, len(multiples), 2):\n                outputs.append((multiples[j], multiples[j + 1]))\n                counter += 1\n    return (counter, outputs)"
    }
  ]
}