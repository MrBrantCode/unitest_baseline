{
  "task_id": "taco_7740",
  "entry_point": "can_transform_string",
  "mutant_count": 260,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] - [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] - [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = ([0] * sn + [int(c) for c in f]) * ([0] * (sn - n))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = ([0] * sn + [int(c) for c in f]) * ([0] * (sn - n))\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] / (2 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] / (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] + 2 * sn",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] + 2 * sn\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] ** (2 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] ** (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f = True",
      "mutated_line": "f = False",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = False\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "l -= 1",
      "mutated_line": "l += 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l += 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "LCR",
      "lineno": 58,
      "original_line": "return f and (not match(0, sn, 1))",
      "mutated_line": "return f or not match(0, sn, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f or not match(0, sn, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sn = 1 << n.bit_length()",
      "mutated_line": "sn = 2 << n.bit_length()",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 2 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sn = 1 << n.bit_length()",
      "mutated_line": "sn = 0 << n.bit_length()",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 0 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sn = 1 << n.bit_length()",
      "mutated_line": "sn = 0 << n.bit_length()",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 0 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sn = 1 << n.bit_length()",
      "mutated_line": "sn = -1 << n.bit_length()",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = -1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn - [int(c) for c in f] + [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn - [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn * [int(c) for c in f] + [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn * [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] + [0] / (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] / (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] + ([0] + (sn - n))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + ([0] + (sn - n))\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] + [0] ** (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] ** (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] * (2 / sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 / sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] * (2 + sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 + sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] * 2 ** sn",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * 2 ** sn\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn + 1, 0, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn + 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn * 1, 0, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn * 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 1, 1, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 1, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 1, -1, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, -1, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 1, 1, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 1, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 1, 0, +1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, +1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] - node[i << 1 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] - node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] * node[i << 1 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] * node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l <= lx or r >= rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx or r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl - 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl - 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl * 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl * 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] == -1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] == -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if l < mx:",
      "mutated_line": "if l <= mx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l <= mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if l < mx:",
      "mutated_line": "if l >= mx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l >= mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if l < mx:",
      "mutated_line": "if l != mx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l != mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if r > mx:",
      "mutated_line": "if r >= mx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r >= mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if r > mx:",
      "mutated_line": "if r <= mx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r <= mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if r > mx:",
      "mutated_line": "if r != mx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r != mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "node[now] = node[nl] + node[nr]",
      "mutated_line": "node[now] = node[nl] - node[nr]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] - node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "node[now] = node[nl] + node[nr]",
      "mutated_line": "node[now] = node[nl] * node[nr]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] * node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l <= lx or r >= rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx or r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl - 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl - 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl * 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl * 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] == -1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] == -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return m1 + m2",
      "mutated_line": "return m1 - m2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 - m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return m1 + m2",
      "mutated_line": "return m1 * m2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 * m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if lx >= n:",
      "mutated_line": "if lx > n:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx > n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if lx >= n:",
      "mutated_line": "if lx < n:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx < n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if lx >= n:",
      "mutated_line": "if lx == n:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx == n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if now >= sn:",
      "mutated_line": "if now > sn:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now > sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if now >= sn:",
      "mutated_line": "if now < sn:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now < sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if now >= sn:",
      "mutated_line": "if now == sn:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now == sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] == -1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] == -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "LCR",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) and match(mx, rx, now << 1 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) and match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "l -= 1",
      "mutated_line": "l -= 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 2\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "l -= 1",
      "mutated_line": "l -= 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 0\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "l -= 1",
      "mutated_line": "l -= 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 0\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "l -= 1",
      "mutated_line": "l -= -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= -1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 1) / 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) / 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 1) + 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) + 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 1) ** 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) ** 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if count == r - l:",
      "mutated_line": "if count != r - l:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count != r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] / sn + [int(c) for c in f] + [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] / sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] + sn + [int(c) for c in f] + [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] + sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] ** sn + [int(c) for c in f] + [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] ** sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn + n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn + n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn * n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn * n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [+1] * (2 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [+1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] * (3 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (3 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] * (1 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (1 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] * (0 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (0 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] * (1 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (1 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-1] * (-2 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (-2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 2, 0, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 2, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 0, 0, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 0, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 0, 0, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 0, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - -1, 0, -1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - -1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 1, 0, -2):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -2):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 1, 0, -0):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -0):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 1, 0, -0):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -0):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(sn - 1, 0, -1):",
      "mutated_line": "for i in range(sn - 1, 0, --1):",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, --1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l < lx and r >= rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l < lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l > lx and r >= rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l > lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l == lx and r >= rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l == lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l <= lx and r > rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r > rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l <= lx and r < rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r < rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l <= lx and r == rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r == rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx - rx >> 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx - rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx * rx >> 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx * rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx + rx >> 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 2\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx + rx >> 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 0\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx + rx >> 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 0\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx + rx >> -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> -1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nl = now << 1",
      "mutated_line": "nl = now << 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 2\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nl = now << 1",
      "mutated_line": "nl = now << 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 0\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nl = now << 1",
      "mutated_line": "nl = now << 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 0\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nl = now << 1",
      "mutated_line": "nl = now << -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << -1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl + 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 2\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl + 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 0\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl + 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 0\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl + -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + -1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != +1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != +1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "label[now] = -1",
      "mutated_line": "label[now] = +1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = +1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l < lx and r >= rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l < lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l > lx and r >= rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l > lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l == lx and r >= rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l == lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l <= lx and r > rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r > rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l <= lx and r < rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r < rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if l <= lx and r >= rx:",
      "mutated_line": "if l <= lx and r == rx:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r == rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx - rx >> 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx - rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx * rx >> 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx * rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx + rx >> 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 2\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx + rx >> 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 0\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx + rx >> 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 0\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mx = lx + rx >> 1",
      "mutated_line": "mx = lx + rx >> -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> -1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "nl = now << 1",
      "mutated_line": "nl = now << 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 2\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "nl = now << 1",
      "mutated_line": "nl = now << 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 0\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "nl = now << 1",
      "mutated_line": "nl = now << 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 0\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "nl = now << 1",
      "mutated_line": "nl = now << -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << -1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl + 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 2\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl + 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 0\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl + 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 0\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nr = nl + 1",
      "mutated_line": "nr = nl + -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + -1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != +1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != +1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "m1 = get_range(lx, mx, nl) if l < mx else 0",
      "mutated_line": "m1 = get_range(lx, mx, nl) if l <= mx else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l <= mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "m1 = get_range(lx, mx, nl) if l < mx else 0",
      "mutated_line": "m1 = get_range(lx, mx, nl) if l >= mx else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l >= mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "m1 = get_range(lx, mx, nl) if l < mx else 0",
      "mutated_line": "m1 = get_range(lx, mx, nl) if l != mx else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l != mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "m1 = get_range(lx, mx, nl) if l < mx else 0",
      "mutated_line": "m1 = get_range(lx, mx, nl) if l < mx else 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 1\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "m1 = get_range(lx, mx, nl) if l < mx else 0",
      "mutated_line": "m1 = get_range(lx, mx, nl) if l < mx else -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else -1\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "m1 = get_range(lx, mx, nl) if l < mx else 0",
      "mutated_line": "m1 = get_range(lx, mx, nl) if l < mx else 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 1\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "m2 = get_range(mx, rx, nr) if r > mx else 0",
      "mutated_line": "m2 = get_range(mx, rx, nr) if r >= mx else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r >= mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "m2 = get_range(mx, rx, nr) if r > mx else 0",
      "mutated_line": "m2 = get_range(mx, rx, nr) if r <= mx else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r <= mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "m2 = get_range(mx, rx, nr) if r > mx else 0",
      "mutated_line": "m2 = get_range(mx, rx, nr) if r != mx else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r != mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "m2 = get_range(mx, rx, nr) if r > mx else 0",
      "mutated_line": "m2 = get_range(mx, rx, nr) if r > mx else 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 1\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "m2 = get_range(mx, rx, nr) if r > mx else 0",
      "mutated_line": "m2 = get_range(mx, rx, nr) if r > mx else -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else -1\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "m2 = get_range(mx, rx, nr) if r > mx else 0",
      "mutated_line": "m2 = get_range(mx, rx, nr) if r > mx else 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 1\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return True\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "return node[now] != int(s[lx])",
      "mutated_line": "return node[now] == int(s[lx])",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] == int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != +1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != +1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "mx = rx + lx >> 1",
      "mutated_line": "mx = rx - lx >> 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx - lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "mx = rx + lx >> 1",
      "mutated_line": "mx = rx * lx >> 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx * lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "mx = rx + lx >> 1",
      "mutated_line": "mx = rx + lx >> 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 2\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "mx = rx + lx >> 1",
      "mutated_line": "mx = rx + lx >> 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 0\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "mx = rx + lx >> 1",
      "mutated_line": "mx = rx + lx >> 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 0\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "mx = rx + lx >> 1",
      "mutated_line": "mx = rx + lx >> -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> -1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "for (l, r) in inspections[::-1]:",
      "mutated_line": "for (l, r) in inspections[::+1]:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::+1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 1) * 3",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 3\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 1) * 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 1\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 1) * 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 0\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 1) * 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 1\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 1) * -2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * -2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if count == r - l:",
      "mutated_line": "if count == r + l:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r + l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if count == r - l:",
      "mutated_line": "if count == r * l:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r * l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "f = False",
      "mutated_line": "f = True",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = True\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(1, sn, 1 if count > r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(1, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(-1, sn, 1 if count > r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(-1, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(1, sn, 1 if count > r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(1, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r - l else 0, 2)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 2)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r - l else 0, 0)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 0)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r - l else 0, 0)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 0)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r - l else 0, -1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, -1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] + [1] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [1] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] + [-1] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [-1] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [0] * sn + [int(c) for c in f] + [1] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [1] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-2] * (2 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-2] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-0] * (2 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-0] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [-0] * (2 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-0] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "label = [-1] * (2 * sn)",
      "mutated_line": "label = [--1] * (2 * sn)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [--1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 1 & 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 & 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 1 ^ 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 ^ 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "node[now] = (rx - lx) if v else 0",
      "mutated_line": "node[now] = rx + lx if v else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx + lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "node[now] = (rx - lx) if v else 0",
      "mutated_line": "node[now] = rx * lx if v else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx * lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[now] = (rx - lx) if v else 0",
      "mutated_line": "node[now] = rx - lx if v else 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 1\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[now] = (rx - lx) if v else 0",
      "mutated_line": "node[now] = rx - lx if v else -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else -1\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[now] = (rx - lx) if v else 0",
      "mutated_line": "node[now] = rx - lx if v else 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 1\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -2:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -2:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -0:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -0:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -0:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -0:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != --1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != --1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "node[nl] = node[nr] = node[now] >> 1",
      "mutated_line": "node[nl] = node[nr] = node[now] >> 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 2\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "node[nl] = node[nr] = node[now] >> 1",
      "mutated_line": "node[nl] = node[nr] = node[now] >> 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 0\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "node[nl] = node[nr] = node[now] >> 1",
      "mutated_line": "node[nl] = node[nr] = node[now] >> 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 0\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "node[nl] = node[nr] = node[now] >> 1",
      "mutated_line": "node[nl] = node[nr] = node[now] >> -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> -1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "label[now] = -1",
      "mutated_line": "label[now] = -2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -2\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "label[now] = -1",
      "mutated_line": "label[now] = -0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -0\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "label[now] = -1",
      "mutated_line": "label[now] = -0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -0\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "label[now] = -1",
      "mutated_line": "label[now] = --1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = --1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -2:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -2:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -0:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -0:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -0:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -0:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != --1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != --1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return min(rx, r) - max(lx, l) if label[now] else 0",
      "mutated_line": "return min(rx, r) + max(lx, l) if label[now] else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) + max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return min(rx, r) - max(lx, l) if label[now] else 0",
      "mutated_line": "return min(rx, r) * max(lx, l) if label[now] else 0",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) * max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return min(rx, r) - max(lx, l) if label[now] else 0",
      "mutated_line": "return min(rx, r) - max(lx, l) if label[now] else 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 1\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return min(rx, r) - max(lx, l) if label[now] else 0",
      "mutated_line": "return min(rx, r) - max(lx, l) if label[now] else -1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else -1\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return min(rx, r) - max(lx, l) if label[now] else 0",
      "mutated_line": "return min(rx, r) - max(lx, l) if label[now] else 1",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 1\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -2:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -2:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -0:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -0:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != -0:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -0:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if label[now] != -1:",
      "mutated_line": "if label[now] != --1:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != --1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 & 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 & 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 ^ 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 ^ 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for (l, r) in inspections[::-1]:",
      "mutated_line": "for (l, r) in inspections[::-2]:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-2]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for (l, r) in inspections[::-1]:",
      "mutated_line": "for (l, r) in inspections[::-0]:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-0]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for (l, r) in inspections[::-1]:",
      "mutated_line": "for (l, r) in inspections[::-0]:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-0]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for (l, r) in inspections[::-1]:",
      "mutated_line": "for (l, r) in inspections[::--1]:",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::--1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(1, sn, 1) * 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(1, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(-1, sn, 1) * 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(-1, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(1, sn, 1) * 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(1, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 2) * 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 2) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 0) * 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 0) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, 0) * 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 0) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "count = get_range(0, sn, 1) * 2",
      "mutated_line": "count = get_range(0, sn, -1) * 2",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, -1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count >= r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count >= r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count <= r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count <= r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count != r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count != r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 2 if count > r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 2 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 0 if count > r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 0 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 0 if count > r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 0 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, -1 if count > r - l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, -1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r - l else 1, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 1, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r - l else -1, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else -1, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r - l else 1, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 1, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return f and (not match(0, sn, 1))",
      "mutated_line": "return f and (not match(1, sn, 1))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(1, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return f and (not match(0, sn, 1))",
      "mutated_line": "return f and (not match(-1, sn, 1))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(-1, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return f and (not match(0, sn, 1))",
      "mutated_line": "return f and (not match(1, sn, 1))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(1, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return f and (not match(0, sn, 1))",
      "mutated_line": "return f and (not match(0, sn, 2))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 2))"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return f and (not match(0, sn, 1))",
      "mutated_line": "return f and (not match(0, sn, 0))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 0))"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return f and (not match(0, sn, 1))",
      "mutated_line": "return f and (not match(0, sn, 0))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 0))"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return f and (not match(0, sn, 1))",
      "mutated_line": "return f and (not match(0, sn, -1))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, -1))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [1] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [1] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [-1] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [-1] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "mutated_line": "node = [1] * sn + [int(c) for c in f] + [0] * (sn - n)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [1] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 2] + node[i << 1 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 2] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 0] + node[i << 1 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 0] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 0] + node[i << 1 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 0] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << -1] + node[i << 1 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << -1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 1 | 2]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 2]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 1 | 0]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 0]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 1 | 0]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 0]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 1 | -1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | -1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "return any((v != label[now] for v in s[lx:rx]))",
      "mutated_line": "return any((v == label[now] for v in s[lx:rx]))",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v == label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 2) or match(mx, rx, now << 1 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 2) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 0) or match(mx, rx, now << 1 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 0) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 0) or match(mx, rx, now << 1 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 0) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << -1) or match(mx, rx, now << 1 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << -1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 2)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 2)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 0)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 0)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 0)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 0)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | -1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | -1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r + l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r + l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "set_range(0, sn, 1 if count > r - l else 0, 1)",
      "mutated_line": "set_range(0, sn, 1 if count > r * l else 0, 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r * l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 2 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 2 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 0 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 0 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << 0 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 0 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "node[i] = node[i << 1] + node[i << 1 | 1]",
      "mutated_line": "node[i] = node[i << 1] + node[i << -1 | 1]",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << -1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 2 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 2 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 0 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 0 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 0 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << 0 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return match(lx, mx, now << 1) or match(mx, rx, now << 1 | 1)",
      "mutated_line": "return match(lx, mx, now << 1) or match(mx, rx, now << -1 | 1)",
      "code": "def can_transform_string(n, q, s, f, inspections):\n    sn = 1 << n.bit_length()\n    node = [0] * sn + [int(c) for c in f] + [0] * (sn - n)\n    label = [-1] * (2 * sn)\n    for i in range(sn - 1, 0, -1):\n        node[i] = node[i << 1] + node[i << 1 | 1]\n\n    def set_range(lx, rx, v, now):\n        if l <= lx and r >= rx:\n            label[now] = v\n            node[now] = rx - lx if v else 0\n            return\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            node[nl] = node[nr] = node[now] >> 1\n            label[nl] = label[nr] = label[now]\n            label[now] = -1\n        if l < mx:\n            set_range(lx, mx, v, nl)\n        if r > mx:\n            set_range(mx, rx, v, nr)\n        node[now] = node[nl] + node[nr]\n\n    def get_range(lx, rx, now):\n        if l <= lx and r >= rx:\n            return node[now]\n        mx = lx + rx >> 1\n        nl = now << 1\n        nr = nl + 1\n        if label[now] != -1:\n            return min(rx, r) - max(lx, l) if label[now] else 0\n        m1 = get_range(lx, mx, nl) if l < mx else 0\n        m2 = get_range(mx, rx, nr) if r > mx else 0\n        return m1 + m2\n\n    def match(lx, rx, now):\n        if lx >= n:\n            return False\n        if now >= sn:\n            return node[now] != int(s[lx])\n        if label[now] != -1:\n            return any((v != label[now] for v in s[lx:rx]))\n        mx = rx + lx >> 1\n        return match(lx, mx, now << 1) or match(mx, rx, now << -1 | 1)\n    f = True\n    for (l, r) in inspections[::-1]:\n        l -= 1\n        count = get_range(0, sn, 1) * 2\n        if count == r - l:\n            f = False\n            break\n        set_range(0, sn, 1 if count > r - l else 0, 1)\n    return f and (not match(0, sn, 1))"
    }
  ]
}