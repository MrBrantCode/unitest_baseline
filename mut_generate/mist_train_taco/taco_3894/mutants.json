{
  "task_id": "taco_3894",
  "entry_point": "count_ways_to_write_integers",
  "mutant_count": 170,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 2 * 31",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 * 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 2 + 31",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 + 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] / (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] / (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] + (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] + (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] ** (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] ** (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] / (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] / (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] + (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] + (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] ** (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] ** (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S[1] = 0",
      "mutated_line": "S[1] = 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 1\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S[1] = 0",
      "mutated_line": "S[1] = -1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = -1\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S[1] = 0",
      "mutated_line": "S[1] = 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 1\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C[1] = 0",
      "mutated_line": "C[1] = 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 1\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C[1] = 0",
      "mutated_line": "C[1] = -1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = -1\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C[1] = 0",
      "mutated_line": "C[1] = 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 1\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] / (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] / (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] + (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] + (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] ** (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] ** (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] / (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] / (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] + (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] + (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] ** (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] ** (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "state = 1",
      "mutated_line": "state = 2",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 2\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "state = 1",
      "mutated_line": "state = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 0\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "state = 1",
      "mutated_line": "state = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 0\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "state = 1",
      "mutated_line": "state = -1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = -1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if state == 0:",
      "mutated_line": "if state != 0:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state != 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 3 ** 31",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 3 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 1 ** 31",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 1 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 0 ** 31",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 0 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 1 ** 31",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 1 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = -2 ** 31",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = -2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 2 ** 32",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 32\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 2 ** 30",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 30\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 2 ** 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 0\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 2 ** 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 1\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 2 ** 31",
      "mutated_line": "INF = 2 ** -31",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** -31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] * (n - 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n - 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] * (n * 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n * 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n - 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n - 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n * 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n * 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S[1] = 0",
      "mutated_line": "S[2] = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[2] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S[1] = 0",
      "mutated_line": "S[0] = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[0] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S[1] = 0",
      "mutated_line": "S[0] = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[0] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S[1] = 0",
      "mutated_line": "S[-1] = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[-1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C[1] = 0",
      "mutated_line": "C[2] = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[2] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C[1] = 0",
      "mutated_line": "C[0] = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[0] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C[1] = 0",
      "mutated_line": "C[0] = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[0] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C[1] = 0",
      "mutated_line": "C[-1] = 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[-1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] * (n - 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n - 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] * (n * 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n * 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] * (n - 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n - 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] * (n * 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n * 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "Q = [1]",
      "mutated_line": "Q = [2]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [2]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "Q = [1]",
      "mutated_line": "Q = [0]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [0]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "Q = [1]",
      "mutated_line": "Q = [0]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [0]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "Q = [1]",
      "mutated_line": "Q = [-1]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [-1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if state == 0:",
      "mutated_line": "if state == 1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 1:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if state == 0:",
      "mutated_line": "if state == -1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == -1:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if state == 0:",
      "mutated_line": "if state == 1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 1:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 1\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return -1\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 1\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state != 1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state != 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] * (n + 2)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 2)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] * (n + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 0)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] * (n + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 0)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "S = [INF] * (n + 1)",
      "mutated_line": "S = [INF] * (n + -1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + -1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [+1] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [+1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n + 2)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 2)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 0)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 0)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n + -1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + -1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [2] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [2] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [0] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [0] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [0] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [0] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [-1] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [-1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] * (n + 2)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 2)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] * (n + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 0)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] * (n + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 0)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "L = [1] * (n + 1)",
      "mutated_line": "L = [1] * (n + -1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + -1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] * (n + 2)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 2)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] * (n + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 0)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] * (n + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 0)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "R = [INF] * (n + 1)",
      "mutated_line": "R = [INF] * (n + -1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + -1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if C[q] == -1:",
      "mutated_line": "if C[q] != -1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] != -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state == 2:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 2:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state == 0:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 0:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state == 0:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 0:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state == -1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == -1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "D = [[] for _ in range(n + 1)]",
      "mutated_line": "D = [[] for _ in range(n - 1)]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n - 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "D = [[] for _ in range(n + 1)]",
      "mutated_line": "D = [[] for _ in range(n * 1)]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n * 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-2] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-2] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-0] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-0] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-0] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-0] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [--1] * (n + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [--1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if C[q] == -1:",
      "mutated_line": "if C[q] == +1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == +1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "S[q] = s - S[p]",
      "mutated_line": "S[q] = s + S[p]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s + S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "S[q] = s - S[p]",
      "mutated_line": "S[q] = s * S[p]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s * S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif C[q] == C[p]:",
      "mutated_line": "elif C[q] != C[p]:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] != C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(1, min(R) - max(L) + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(1, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(-1, min(R) - max(L) + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(-1, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(1, min(R) - max(L) + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(1, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(0, min(R) - max(L) - 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(0, (min(R) - max(L)) * 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, (min(R) - max(L)) * 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D = [[] for _ in range(n + 1)]",
      "mutated_line": "D = [[] for _ in range(n + 2)]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 2)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D = [[] for _ in range(n + 1)]",
      "mutated_line": "D = [[] for _ in range(n + 0)]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 0)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D = [[] for _ in range(n + 1)]",
      "mutated_line": "D = [[] for _ in range(n + 0)]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 0)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D = [[] for _ in range(n + 1)]",
      "mutated_line": "D = [[] for _ in range(n + -1)]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + -1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if C[q] == -1:",
      "mutated_line": "if C[q] == -2:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -2:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if C[q] == -1:",
      "mutated_line": "if C[q] == -0:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -0:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if C[q] == -1:",
      "mutated_line": "if C[q] == -0:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -0:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if C[q] == -1:",
      "mutated_line": "if C[q] == --1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == --1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if C[p] == 0:",
      "mutated_line": "if C[p] != 0:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] != 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if (a - b) * 2:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) * 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if a - b + 2:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if a - b + 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = (a - b) / 2",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) / 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = (a - b) * 2",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) * 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if t == L[q] == R[q]:",
      "mutated_line": "if t != L[q] == R[q]:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t != L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif S[q] != s - S[p]:",
      "mutated_line": "elif S[q] == s - S[p]:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] == s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(0, min(R) + max(L) + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) + max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(0, min(R) * max(L) + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) * max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(0, min(R) - max(L) + 2)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 2)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(0, min(R) - max(L) + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(0, min(R) - max(L) + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 0)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return max(0, min(R) - max(L) + 1)",
      "mutated_line": "return max(0, min(R) - max(L) + -1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + -1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "R[q] = min(R[q], S[q] - 1)",
      "mutated_line": "R[q] = min(R[q], S[q] + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] + 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "R[q] = min(R[q], S[q] - 1)",
      "mutated_line": "R[q] = min(R[q], S[q] * 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] * 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(2, -S[q] + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(2, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(0, -S[q] + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(0, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(0, -S[q] + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(0, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(-1, -S[q] + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(-1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(1, -S[q] - 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] - 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(1, -S[q] * 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] * 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if C[p] == 0:",
      "mutated_line": "if C[p] == 1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 1:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if C[p] == 0:",
      "mutated_line": "if C[p] == -1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == -1:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if C[p] == 0:",
      "mutated_line": "if C[p] == 1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 1:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "a = s - S[p]",
      "mutated_line": "a = s + S[p]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s + S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "a = s - S[p]",
      "mutated_line": "a = s * S[p]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s * S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "b = s - S[p]",
      "mutated_line": "b = s + S[p]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s + S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "b = s - S[p]",
      "mutated_line": "b = s * S[p]",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s * S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if (a + b) % 2:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a + b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if a * b % 2:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if a * b % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if (a - b) % 3:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 3:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if (a - b) % 1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 1:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if (a - b) % 0:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 0:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if (a - b) % 1:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 1:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (a - b) % 2:",
      "mutated_line": "if (a - b) % -2:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % -2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "state = 0",
      "mutated_line": "state = 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 1\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "state = 0",
      "mutated_line": "state = -1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = -1\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "state = 0",
      "mutated_line": "state = 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 1\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = (a + b) // 2",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a + b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = a * b // 2",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = a * b // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = (a - b) // 3",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 3\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = (a - b) // 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 1\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = (a - b) // 0",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 0\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = (a - b) // 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 1\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = (a - b) // 2",
      "mutated_line": "t = (a - b) // -2",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // -2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "elif S[q] != s - S[p]:",
      "mutated_line": "elif S[q] != s + S[p]:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s + S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "elif S[q] != s - S[p]:",
      "mutated_line": "elif S[q] != s * S[p]:",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s * S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "state = 0",
      "mutated_line": "state = 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 1\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "state = 0",
      "mutated_line": "state = -1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = -1\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "state = 0",
      "mutated_line": "state = 1",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 1\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "R[q] = min(R[q], S[q] - 1)",
      "mutated_line": "R[q] = min(R[q], S[q] - 2)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 2)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "R[q] = min(R[q], S[q] - 1)",
      "mutated_line": "R[q] = min(R[q], S[q] - 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 0)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "R[q] = min(R[q], S[q] - 1)",
      "mutated_line": "R[q] = min(R[q], S[q] - 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 0)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "R[q] = min(R[q], S[q] - 1)",
      "mutated_line": "R[q] = min(R[q], S[q] - -1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - -1)\n                else:\n                    L[q] = max(1, -S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(1, +S[q] + 1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, +S[q] + 1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(1, -S[q] + 2)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 2)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(1, -S[q] + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 0)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(1, -S[q] + 0)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + 0)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "L[q] = max(1, -S[q] + 1)",
      "mutated_line": "L[q] = max(1, -S[q] + -1)",
      "code": "def count_ways_to_write_integers(n, m, edges):\n    from collections import deque\n    INF = 2 ** 31\n    D = [[] for _ in range(n + 1)]\n    for (u, v, s) in edges:\n        D[u].append((v, s))\n        D[v].append((u, s))\n    S = [INF] * (n + 1)\n    C = [-1] * (n + 1)\n    S[1] = 0\n    C[1] = 0\n    L = [1] * (n + 1)\n    R = [INF] * (n + 1)\n    Q = [1]\n    state = 1\n    while Q:\n        p = Q.pop()\n        for (q, s) in D[p]:\n            if C[q] == -1:\n                C[q] = int(not C[p])\n                S[q] = s - S[p]\n                if C[q]:\n                    R[q] = min(R[q], S[q] - 1)\n                else:\n                    L[q] = max(1, -S[q] + -1)\n                Q.append(q)\n            elif C[q] == C[p]:\n                if C[p] == 0:\n                    a = s - S[p]\n                    b = S[q]\n                else:\n                    a = S[q]\n                    b = s - S[p]\n                if (a - b) % 2:\n                    state = 0\n                    Q = []\n                    break\n                t = (a - b) // 2\n                if t == L[q] == R[q]:\n                    continue\n                R[q] = t\n                L[q] = t\n                Q.append(q)\n            elif S[q] != s - S[p]:\n                state = 0\n                Q = []\n                break\n    if state == 0:\n        return 0\n    elif state == 1:\n        return max(0, min(R) - max(L) + 1)"
    }
  ]
}