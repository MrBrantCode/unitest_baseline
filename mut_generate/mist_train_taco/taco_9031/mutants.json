{
  "task_id": "taco_9031",
  "entry_point": "determine_winner",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 + 1 >= db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 >= db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 + 1 <= db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 <= db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 + 1 != db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 != db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inf = n + 1",
      "mutated_line": "inf = n - 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n - 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inf = n + 1",
      "mutated_line": "inf = n * 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n * 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] / (n + 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] / (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] + (n + 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] + (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] ** (n + 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] ** (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dpa[a] = 0",
      "mutated_line": "dpa[a] = 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 1\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dpa[a] = 0",
      "mutated_line": "dpa[a] = -1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = -1\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dpa[a] = 0",
      "mutated_line": "dpa[a] = 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 1\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dpa[b] <= da:",
      "mutated_line": "if dpa[b] < da:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] < da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dpa[b] <= da:",
      "mutated_line": "if dpa[b] > da:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] > da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dpa[b] <= da:",
      "mutated_line": "if dpa[b] == da:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] == da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] / (n + 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] / (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] + (n + 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] + (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] ** (n + 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] ** (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[far] = 0",
      "mutated_line": "dp[far] = 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 1\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[far] = 0",
      "mutated_line": "dp[far] = -1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = -1\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[far] = 0",
      "mutated_line": "dp[far] = 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 1\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia < da * 2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia < da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia > da * 2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia > da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia == da * 2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia == da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 'Bob'",
      "mutated_line": "return ''",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 - 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 - 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 * 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 * 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 'Alice'",
      "mutated_line": "return ''",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return ''\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inf = n + 1",
      "mutated_line": "inf = n + 2",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 2\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inf = n + 1",
      "mutated_line": "inf = n + 0",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 0\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inf = n + 1",
      "mutated_line": "inf = n + 0",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 0\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inf = n + 1",
      "mutated_line": "inf = n + -1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + -1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] * (n - 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n - 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] * (n * 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n * 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 'Alice'",
      "mutated_line": "return ''",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return ''\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(2, n + 1):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(2, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(0, n + 1):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(0, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(0, n + 1):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(0, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(-1, n + 1):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(-1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n - 1):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n - 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n * 1):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n * 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dpa[far] < dpa[v]:",
      "mutated_line": "if dpa[far] <= dpa[v]:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] <= dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dpa[far] < dpa[v]:",
      "mutated_line": "if dpa[far] >= dpa[v]:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] >= dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dpa[far] < dpa[v]:",
      "mutated_line": "if dpa[far] != dpa[v]:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] != dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] * (n - 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n - 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] * (n * 1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n * 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia <= da / 2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da / 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia <= da + 2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da + 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia <= da ** 2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da ** 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return 'Alice'",
      "mutated_line": "return ''",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return ''\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da / 2 + 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da / 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da + 2 + 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da + 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da ** 2 + 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da ** 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 + 2 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 2 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 + 0 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 0 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 + 0 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 0 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 2 + -1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + -1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] * (n + 2)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 2)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] * (n + 0)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 0)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] * (n + 0)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 0)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dpa = [inf] * (n + 1)",
      "mutated_line": "dpa = [inf] * (n + -1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + -1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] >= dpa[x] + 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] >= dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] <= dpa[x] + 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] <= dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] != dpa[x] + 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] != dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 2):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 2):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 0):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 0):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 0):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 0):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + -1):",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + -1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] * (n + 2)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 2)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] * (n + 0)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 0)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] * (n + 0)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 0)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp = [inf] * (n + 1)",
      "mutated_line": "dp = [inf] * (n + -1)",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + -1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] >= dp[x] + 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] >= dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] <= dp[x] + 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] <= dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] != dp[x] + 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] != dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia <= da * 3:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 3:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia <= da * 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 1:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia <= da * 0:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 0:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia <= da * 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 1:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dia <= da * 2:",
      "mutated_line": "if dia <= da * -2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * -2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 3 + 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 3 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 1 + 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 1 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 0 + 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 0 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * 1 + 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 1 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if da * 2 + 1 > db:",
      "mutated_line": "if da * -2 + 1 > db:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * -2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] > dpa[x] - 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] - 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] > dpa[x] * 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] * 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dpa[y] = dpa[x] + 1",
      "mutated_line": "dpa[y] = dpa[x] - 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] - 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dpa[y] = dpa[x] + 1",
      "mutated_line": "dpa[y] = dpa[x] * 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] * 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] > dp[x] - 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] - 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] > dp[x] * 1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] * 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[y] = dp[x] + 1",
      "mutated_line": "dp[y] = dp[x] - 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] - 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[y] = dp[x] + 1",
      "mutated_line": "dp[y] = dp[x] * 1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] * 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dia = max(dp[1:])",
      "mutated_line": "dia = max(dp[2:])",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[2:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dia = max(dp[1:])",
      "mutated_line": "dia = max(dp[0:])",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[0:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dia = max(dp[1:])",
      "mutated_line": "dia = max(dp[0:])",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[0:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dia = max(dp[1:])",
      "mutated_line": "dia = max(dp[-1:])",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[-1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] > dpa[x] + 2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 2:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] > dpa[x] + 0:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 0:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] > dpa[x] + 0:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 0:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dpa[y] > dpa[x] + 1:",
      "mutated_line": "if dpa[y] > dpa[x] + -1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + -1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dpa[y] = dpa[x] + 1",
      "mutated_line": "dpa[y] = dpa[x] + 2",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 2\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dpa[y] = dpa[x] + 1",
      "mutated_line": "dpa[y] = dpa[x] + 0",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 0\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dpa[y] = dpa[x] + 1",
      "mutated_line": "dpa[y] = dpa[x] + 0",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 0\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dpa[y] = dpa[x] + 1",
      "mutated_line": "dpa[y] = dpa[x] + -1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + -1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] > dp[x] + 2:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 2:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] > dp[x] + 0:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 0:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] > dp[x] + 0:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 0:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[y] > dp[x] + 1:",
      "mutated_line": "if dp[y] > dp[x] + -1:",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + -1:\n                dp[y] = dp[x] + 1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[y] = dp[x] + 1",
      "mutated_line": "dp[y] = dp[x] + 2",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 2\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[y] = dp[x] + 1",
      "mutated_line": "dp[y] = dp[x] + 0",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 0\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[y] = dp[x] + 1",
      "mutated_line": "dp[y] = dp[x] + 0",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + 0\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[y] = dp[x] + 1",
      "mutated_line": "dp[y] = dp[x] + -1",
      "code": "from collections import deque as dq\n\ndef determine_winner(n, a, b, da, db, edges):\n    e = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        e[u].append(v)\n        e[v].append(u)\n    if da * 2 + 1 > db:\n        return 'Alice'\n    Q = dq([a])\n    inf = n + 1\n    dpa = [inf] * (n + 1)\n    dpa[a] = 0\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dpa[y] > dpa[x] + 1:\n                dpa[y] = dpa[x] + 1\n                Q.append(y)\n    if dpa[b] <= da:\n        return 'Alice'\n    far = a\n    for v in range(1, n + 1):\n        if dpa[far] < dpa[v]:\n            far = v\n    dp = [inf] * (n + 1)\n    dp[far] = 0\n    Q.append(far)\n    while len(Q):\n        x = Q.popleft()\n        for y in e[x]:\n            if dp[y] > dp[x] + 1:\n                dp[y] = dp[x] + -1\n                Q.append(y)\n    dia = max(dp[1:])\n    if dia <= da * 2:\n        return 'Alice'\n    return 'Bob'"
    }
  ]
}