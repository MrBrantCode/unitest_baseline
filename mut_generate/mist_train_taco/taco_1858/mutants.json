{
  "task_id": "taco_1858",
  "entry_point": "min_moves_to_zero",
  "mutant_count": 99,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N == 0:",
      "mutated_line": "if N != 0:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N != 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] / (N + 1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] / (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] + (N + 1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] + (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] ** (N + 1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] ** (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N == 0:",
      "mutated_line": "if N == 1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 1:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N == 0:",
      "mutated_line": "if N == -1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == -1:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N == 0:",
      "mutated_line": "if N == 1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 1:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 1\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return -1\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 1\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] * (N - 1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N - 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] * (N * 1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N * 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if current_N == 1:",
      "mutated_line": "if current_N != 1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N != 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while div > 1:",
      "mutated_line": "while div >= 1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div >= 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while div > 1:",
      "mutated_line": "while div <= 1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div <= 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while div > 1:",
      "mutated_line": "while div != 1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div != 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "div -= 1",
      "mutated_line": "div += 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div += 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "Q = [(N, 0)]",
      "mutated_line": "Q = [(N, 1)]",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 1)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "Q = [(N, 0)]",
      "mutated_line": "Q = [(N, -1)]",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, -1)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "Q = [(N, 0)]",
      "mutated_line": "Q = [(N, 1)]",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 1)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [1] * (N + 1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [1] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [-1] * (N + 1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [-1] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [1] * (N + 1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [1] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] * (N + 2)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 2)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] * (N + 0)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 0)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] * (N + 0)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 0)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "setQ = [0] * (N + 1)",
      "mutated_line": "setQ = [0] * (N + -1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + -1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(current_N, steps) = Q.pop(0)",
      "mutated_line": "(current_N, steps) = Q.pop(1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(1)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(current_N, steps) = Q.pop(0)",
      "mutated_line": "(current_N, steps) = Q.pop(-1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(-1)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(current_N, steps) = Q.pop(0)",
      "mutated_line": "(current_N, steps) = Q.pop(1)",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(1)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if current_N == 1:",
      "mutated_line": "if current_N == 2:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 2:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if current_N == 1:",
      "mutated_line": "if current_N == 0:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 0:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if current_N == 1:",
      "mutated_line": "if current_N == 0:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 0:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if current_N == 1:",
      "mutated_line": "if current_N == -1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == -1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return steps + 1",
      "mutated_line": "return steps - 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps - 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return steps + 1",
      "mutated_line": "return steps * 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps * 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while div > 1:",
      "mutated_line": "while div > 2:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 2:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while div > 1:",
      "mutated_line": "while div > 0:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 0:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while div > 1:",
      "mutated_line": "while div > 0:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 0:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while div > 1:",
      "mutated_line": "while div > -1:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > -1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N % div == 0 or not setQ[current_N // div]:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 or not setQ[current_N // div]:\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "div -= 1",
      "mutated_line": "div -= 2",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 2\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "div -= 1",
      "mutated_line": "div -= 0",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 0\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "div -= 1",
      "mutated_line": "div -= 0",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 0\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "div -= 1",
      "mutated_line": "div -= -1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= -1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N - 1] = 2",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N - 1] = 0",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N - 1] = 0",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N - 1] = -1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return steps + 1",
      "mutated_line": "return steps + 2",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 2\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return steps + 1",
      "mutated_line": "return steps + 0",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 0\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return steps + 1",
      "mutated_line": "return steps + 0",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 0\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return steps + 1",
      "mutated_line": "return steps + -1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + -1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N % div != 0 and (not setQ[current_N // div]):",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div != 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "setQ[current_N // div] = 1",
      "mutated_line": "setQ[current_N // div] = 2",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 2\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "setQ[current_N // div] = 1",
      "mutated_line": "setQ[current_N // div] = 0",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 0\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "setQ[current_N // div] = 1",
      "mutated_line": "setQ[current_N // div] = 0",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 0\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "setQ[current_N // div] = 1",
      "mutated_line": "setQ[current_N // div] = -1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = -1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not setQ[current_N - 1]:",
      "mutated_line": "if not setQ[current_N + 1]:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N + 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not setQ[current_N - 1]:",
      "mutated_line": "if not setQ[current_N * 1]:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N * 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N + 1] = 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N + 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N * 1] = 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N * 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N * div == 0 and (not setQ[current_N // div]):",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N * div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N + div == 0 and (not setQ[current_N // div]):",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N + div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N % div == 1 and (not setQ[current_N // div]):",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 1 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N % div == -1 and (not setQ[current_N // div]):",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == -1 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N % div == 1 and (not setQ[current_N // div]):",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 1 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "setQ[current_N // div] = 1",
      "mutated_line": "setQ[current_N / div] = 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N / div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "setQ[current_N // div] = 1",
      "mutated_line": "setQ[current_N * div] = 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N * div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not setQ[current_N - 1]:",
      "mutated_line": "if not setQ[current_N - 2]:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 2]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not setQ[current_N - 1]:",
      "mutated_line": "if not setQ[current_N - 0]:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 0]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not setQ[current_N - 1]:",
      "mutated_line": "if not setQ[current_N - 0]:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 0]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not setQ[current_N - 1]:",
      "mutated_line": "if not setQ[current_N - -1]:",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - -1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N + 1, steps + 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N + 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N * 1, steps + 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N * 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 1, steps - 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps - 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 1, steps * 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps * 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N - 2] = 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 2] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N - 0] = 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 0] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N - 0] = 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 0] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "setQ[current_N - 1] = 1",
      "mutated_line": "setQ[current_N - -1] = 1",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - -1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N % div == 0 and (not setQ[current_N / div]):",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N / div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if current_N % div == 0 and (not setQ[current_N // div]):",
      "mutated_line": "if current_N % div == 0 and (not setQ[current_N * div]):",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N * div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "Q.append((current_N // div, steps + 1))",
      "mutated_line": "Q.append((current_N / div, steps + 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N / div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "Q.append((current_N // div, steps + 1))",
      "mutated_line": "Q.append((current_N * div, steps + 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N * div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "Q.append((current_N // div, steps + 1))",
      "mutated_line": "Q.append((current_N // div, steps - 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps - 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "Q.append((current_N // div, steps + 1))",
      "mutated_line": "Q.append((current_N // div, steps * 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps * 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 2, steps + 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 2, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 0, steps + 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 0, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 0, steps + 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 0, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - -1, steps + 1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - -1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 1, steps + 2))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 2))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 1, steps + 0))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 0))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 1, steps + 0))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 0))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "Q.append((current_N - 1, steps + 1))",
      "mutated_line": "Q.append((current_N - 1, steps + -1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + -1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "Q.append((current_N // div, steps + 1))",
      "mutated_line": "Q.append((current_N // div, steps + 2))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 2))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "Q.append((current_N // div, steps + 1))",
      "mutated_line": "Q.append((current_N // div, steps + 0))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 0))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "Q.append((current_N // div, steps + 1))",
      "mutated_line": "Q.append((current_N // div, steps + 0))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + 0))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "Q.append((current_N // div, steps + 1))",
      "mutated_line": "Q.append((current_N // div, steps + -1))",
      "code": "import math\n\ndef min_moves_to_zero(N):\n    if N == 0:\n        return 0\n    Q = [(N, 0)]\n    setQ = [0] * (N + 1)\n    while Q:\n        (current_N, steps) = Q.pop(0)\n        if current_N == 1:\n            return steps + 1\n        div = int(math.sqrt(current_N))\n        while div > 1:\n            if current_N % div == 0 and (not setQ[current_N // div]):\n                Q.append((current_N // div, steps + -1))\n                setQ[current_N // div] = 1\n            div -= 1\n        if not setQ[current_N - 1]:\n            Q.append((current_N - 1, steps + 1))\n            setQ[current_N - 1] = 1"
    }
  ]
}