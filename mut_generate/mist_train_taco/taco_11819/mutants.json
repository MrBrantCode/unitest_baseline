{
  "task_id": "taco_11819",
  "entry_point": "max_subarray_xor",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n ^ curr_node.val",
      "mutated_line": "return n | curr_node.val",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n | curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(32, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(32, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(30, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(30, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(0, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(0, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(1, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(1, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(-31, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(-31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, +1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, +1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, +1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, +1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i | 1",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i | 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if bitVal not in curr_node.bits:",
      "mutated_line": "if bitVal in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(32, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(32, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(30, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(30, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(0, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(0, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(1, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(1, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(-31, -1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(-31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, +1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, +1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, +1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, +1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i | 1",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i | 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if 1 - bitVal in curr_node.bits:",
      "mutated_line": "if 1 - bitVal not in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal not in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "max_xor = arr[0]",
      "mutated_line": "max_xor = arr[1]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[1]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "max_xor = arr[0]",
      "mutated_line": "max_xor = arr[-1]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[-1]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "max_xor = arr[0]",
      "mutated_line": "max_xor = arr[1]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[1]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_xor = arr[0]",
      "mutated_line": "prefix_xor = arr[1]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[1]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_xor = arr[0]",
      "mutated_line": "prefix_xor = arr[-1]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[-1]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_xor = arr[0]",
      "mutated_line": "prefix_xor = arr[1]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[1]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "prefix_xor = prefix_xor ^ n",
      "mutated_line": "prefix_xor = prefix_xor | n",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor | n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -2, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -2, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -0, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -0, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -0, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -0, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, --1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, --1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -2):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -2):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -0):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -0):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -0):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -0):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, --1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, --1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i & 2",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 2\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i & 0",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 0\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i & 0",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 0\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i & -1",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & -1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -2, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -2, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -0, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -0, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -0, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -0, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, --1, -1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, --1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -2):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -2):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -0):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -0):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -0):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -0):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, --1):",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, --1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i & 2",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 2\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i & 0",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 0\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i & 0",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 0\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bitVal = n >> i & 1",
      "mutated_line": "bitVal = n >> i & -1",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & -1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if 1 - bitVal in curr_node.bits:",
      "mutated_line": "if 1 + bitVal in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 + bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if 1 - bitVal in curr_node.bits:",
      "mutated_line": "if 1 * bitVal in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 * bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "elif bitVal in curr_node.bits:",
      "mutated_line": "elif bitVal not in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal not in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for n in arr[1:]:",
      "mutated_line": "for n in arr[2:]:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[2:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for n in arr[1:]:",
      "mutated_line": "for n in arr[0:]:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[0:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for n in arr[1:]:",
      "mutated_line": "for n in arr[0:]:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[0:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for n in arr[1:]:",
      "mutated_line": "for n in arr[-1:]:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[-1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if 1 - bitVal in curr_node.bits:",
      "mutated_line": "if 2 - bitVal in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 2 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if 1 - bitVal in curr_node.bits:",
      "mutated_line": "if 0 - bitVal in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 0 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if 1 - bitVal in curr_node.bits:",
      "mutated_line": "if 0 - bitVal in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 0 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if 1 - bitVal in curr_node.bits:",
      "mutated_line": "if -1 - bitVal in curr_node.bits:",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if -1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "curr_node = curr_node.bits[1 - bitVal]",
      "mutated_line": "curr_node = curr_node.bits[1 + bitVal]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 + bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "curr_node = curr_node.bits[1 - bitVal]",
      "mutated_line": "curr_node = curr_node.bits[1 * bitVal]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 * bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 1\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return -1\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 1\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "curr_node = curr_node.bits[1 - bitVal]",
      "mutated_line": "curr_node = curr_node.bits[2 - bitVal]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[2 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "curr_node = curr_node.bits[1 - bitVal]",
      "mutated_line": "curr_node = curr_node.bits[0 - bitVal]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[0 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "curr_node = curr_node.bits[1 - bitVal]",
      "mutated_line": "curr_node = curr_node.bits[0 - bitVal]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[0 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "curr_node = curr_node.bits[1 - bitVal]",
      "mutated_line": "curr_node = curr_node.bits[-1 - bitVal]",
      "code": "def max_subarray_xor(arr, N):\n\n    class TrieNode:\n\n        def __init__(self):\n            self.bits = {}\n            self.val = None\n\n    class Trie:\n\n        def __init__(self) -> None:\n            self.root = TrieNode()\n\n        def insert(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if bitVal not in curr_node.bits:\n                    curr_node.bits[bitVal] = TrieNode()\n                curr_node = curr_node.bits[bitVal]\n            curr_node.val = n\n\n        def _find_Max_XOR(self, n):\n            curr_node = self.root\n            for i in range(31, -1, -1):\n                bitVal = n >> i & 1\n                if 1 - bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[-1 - bitVal]\n                elif bitVal in curr_node.bits:\n                    curr_node = curr_node.bits[bitVal]\n                else:\n                    return 0\n            return n ^ curr_node.val\n\n        def maxXorSubarray(self, arr):\n            max_xor = arr[0]\n            prefix_xor = arr[0]\n            self.insert(prefix_xor)\n            for n in arr[1:]:\n                prefix_xor = prefix_xor ^ n\n                max_xor = max(max_xor, prefix_xor, self._find_Max_XOR(prefix_xor))\n                self.insert(prefix_xor)\n            return max_xor\n    t = Trie()\n    return t.maxXorSubarray(arr)"
    }
  ]
}