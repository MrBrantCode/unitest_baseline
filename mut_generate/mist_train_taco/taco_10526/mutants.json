{
  "task_id": "taco_10526",
  "entry_point": "find_min_time_path",
  "mutant_count": 198,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "inf = '*' * (n * m)",
      "mutated_line": "inf = '*' / (n * m)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' / (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "inf = '*' * (n * m)",
      "mutated_line": "inf = '*' + n * m",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' + n * m\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "inf = '*' * (n * m)",
      "mutated_line": "inf = '*' ** (n * m)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' ** (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] - ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] - ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = (['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data]) * ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = (['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data]) * ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "inf = '*' * (n * m)",
      "mutated_line": "inf = '' * (n * m)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "inf = '*' * (n * m)",
      "mutated_line": "inf = '*' * (n / m)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n / m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "inf = '*' * (n * m)",
      "mutated_line": "inf = '*' * (n + m)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n + m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "inf = '*' * (n * m)",
      "mutated_line": "inf = '*' * n ** m",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * n ** m\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] - ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] - ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] * ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] * ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (1, 0, 0, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (1, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (-1, 0, 0, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (-1, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (1, 0, 0, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (1, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, 1, 0, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 1, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, -1, 0, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, -1, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, 1, 0, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 1, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, 0, 1, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 1, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, 0, -1, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, -1, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, 0, 1, 0)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 1, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, 0, 0, 1)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 1)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, 0, 0, -1)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, -1)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(si, sj, ti, tj) = (0, 0, 0, 0)",
      "mutated_line": "(si, sj, ti, tj) = (0, 0, 0, 1)",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 1)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(0, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(0, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(-1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n * 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[ti][tj] = ''",
      "mutated_line": "dp[ti][tj] = 'MUTATED'",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = 'MUTATED'\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) > len(dp[si][sj]) and (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) and (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "return ans if ans != inf else \"-1\"",
      "mutated_line": "return ans if ans == inf else '-1'",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans == inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ans if ans != inf else \"-1\"",
      "mutated_line": "return ans if ans != inf else ''",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else ''"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' / (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' / (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' + (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' + (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' ** (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' ** (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 2):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 0):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 0):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + -1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(2, m + 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(2, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(-1, m + 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(-1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m - 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m - 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m * 1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m * 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if chars[i][j] == '{':",
      "mutated_line": "if chars[i][j] != '{':",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] != '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if chars[i][j] == '|':",
      "mutated_line": "if chars[i][j] != '|':",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] != '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] / (m + 2) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] / (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] + (m + 2) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] + (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] ** (m + 2) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] ** (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dp[i][j] < s:",
      "mutated_line": "if dp[i][j] <= s:",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] <= s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dp[i][j] < s:",
      "mutated_line": "if dp[i][j] >= s:",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] >= s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dp[i][j] < s:",
      "mutated_line": "if dp[i][j] != s:",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] != s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) >= len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) >= len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) <= len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) <= len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) != len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) != len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) or ans > dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) or ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' / (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' / (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' + (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' + (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' ** (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' ** (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) - '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) - '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + [('}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row))) * '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + [('}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row))) * '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m - 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m - 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m * 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m * 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[2 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[2 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[0 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[0 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[0 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[0 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[-1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[-1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) + 97 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) + 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) * 97 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) * 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n - 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n - 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n * 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n * 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 2):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 2):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 0):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 0):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + -1):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + -1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if chars[i][j] == '{':",
      "mutated_line": "if chars[i][j] == '':",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cbit[i][j] = 0",
      "mutated_line": "cbit[i][j] = 1",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 1\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cbit[i][j] = 0",
      "mutated_line": "cbit[i][j] = -1",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = -1\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cbit[i][j] = 0",
      "mutated_line": "cbit[i][j] = 1",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 1\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if chars[i][j] == '|':",
      "mutated_line": "if chars[i][j] == '':",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([2 << i for i in range(26)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([2 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([0 << i for i in range(26)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([0 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([0 << i for i in range(26)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([0 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([-1 << i for i in range(26)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([-1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m - 2) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m - 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m * 2) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m * 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if cbit[di][dj] & enabled != cbit[di][dj]:",
      "mutated_line": "if cbit[di][dj] & enabled == cbit[di][dj]:",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled == cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l and (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l and (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) > len(dp[si][sj]) or (len(ans) != len(dp[si][sj]) and ans > dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) != len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans >= dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans >= dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans <= dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans <= dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):",
      "mutated_line": "if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans != dp[si][sj]):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans != dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m - 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m - 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m * 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m * 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' - ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' - ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' * ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' * ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 3)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 3)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 1)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 1)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 0)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 0)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 1)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 1)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + -2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + -2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 98 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 98 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 96 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 96 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 0 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 0 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 1 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 1 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - -97 for c in chars[i]] for i in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - -97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 3)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 3)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 1)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 1)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 0)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 0)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 1)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 1)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]",
      "mutated_line": "cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + -2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + -2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([1 << i for i in range(27)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(27)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([1 << i for i in range(25)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(25)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([1 << i for i in range(0)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(0)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([1 << i for i in range(1)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(1)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for comb in combinations([1 << i for i in range(26)], r=k):",
      "mutated_line": "for comb in combinations([1 << i for i in range(-26)], r=k):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(-26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 3) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 3) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 1) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 1) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 0) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 0) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 1) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 1) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + -2) for _ in range(n + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + -2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 2) for _ in range(n - 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n - 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 2) for _ in range(n * 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n * 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dq = deque([(ti, tj, '')])",
      "mutated_line": "dq = deque([(ti, tj, 'MUTATED')])",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, 'MUTATED')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i - 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i - 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i * 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i * 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i + 1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i + 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i * 1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i * 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j - 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j - 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j * 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j * 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j + 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j + 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j * 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j * 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if cbit[di][dj] & enabled != cbit[di][dj]:",
      "mutated_line": "if cbit[di][dj] | enabled != cbit[di][dj]:",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] | enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pre = chars[di][dj] if cbit[di][dj] else ''",
      "mutated_line": "pre = chars[di][dj] if cbit[di][dj] else 'MUTATED'",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else 'MUTATED'\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = 1 if cbit[di][dj] else 0",
      "mutated_line": "l = 2 if cbit[di][dj] else 0",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 2 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = 1 if cbit[di][dj] else 0",
      "mutated_line": "l = 0 if cbit[di][dj] else 0",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 0 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = 1 if cbit[di][dj] else 0",
      "mutated_line": "l = 0 if cbit[di][dj] else 0",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 0 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = 1 if cbit[di][dj] else 0",
      "mutated_line": "l = -1 if cbit[di][dj] else 0",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = -1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = 1 if cbit[di][dj] else 0",
      "mutated_line": "l = 1 if cbit[di][dj] else 1",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 1\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = 1 if cbit[di][dj] else 0",
      "mutated_line": "l = 1 if cbit[di][dj] else -1",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else -1\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = 1 if cbit[di][dj] else 0",
      "mutated_line": "l = 1 if cbit[di][dj] else 1",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 1\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) >= len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) >= len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) <= len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) <= len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) != len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) != len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l or dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l or dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp[di][dj] = pre + s",
      "mutated_line": "dp[di][dj] = pre - s",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre - s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp[di][dj] = pre + s",
      "mutated_line": "dp[di][dj] = pre * s",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre * s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 3)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 3)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 1)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 1)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 0)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 0)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 1)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 1)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + -2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + -2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 2) for _ in range(n + 3)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 3)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 2) for _ in range(n + 1)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 1)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 2) for _ in range(n + 0)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 0)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 2) for _ in range(n + 1)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 1)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[inf] * (m + 2) for _ in range(n + 2)]",
      "mutated_line": "dp = [[inf] * (m + 2) for _ in range(n + -2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + -2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 2, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 2, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + -1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + -1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 2, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 2, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - -1, j), (i, j + 1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - -1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 2), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 2), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + -1), (i, j - 1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + -1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 2)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 2)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):",
      "mutated_line": "for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - -1)):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - -1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) - l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) - l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) * l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) * l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) != len(s) + l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) != len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] >= pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] >= pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] <= pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] <= pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] != pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] != pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) - l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) - l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) * l and dp[di][dj] > pre + s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) * l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre - s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre - s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):",
      "mutated_line": "if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre * s):",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre * s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + 'MUTATED'.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + 'MUTATED'.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dq.append((di, dj, pre + s))",
      "mutated_line": "dq.append((di, dj, pre - s))",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre - s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dq.append((di, dj, pre + s))",
      "mutated_line": "dq.append((di, dj, pre * s))",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre * s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c != 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c != 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == '' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == '' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c != 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c != 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == 'T' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "mutated_line": "chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == '' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]",
      "code": "import sys\nfrom array import array\nfrom itertools import combinations\nfrom collections import deque\n\ndef find_min_time_path(n, m, k, map_data):\n    inf = '*' * (n * m)\n    chars = ['}' * (m + 2)] + ['}' + ''.join(('{' if c == 'S' else '|' if c == '' else c for c in row)) + '}' for row in map_data] + ['}' * (m + 2)]\n    cbit = [[1 << ord(c) - 97 for c in chars[i]] for i in range(n + 2)]\n    (si, sj, ti, tj) = (0, 0, 0, 0)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if chars[i][j] == '{':\n                (si, sj) = (i, j)\n                cbit[i][j] = 0\n            if chars[i][j] == '|':\n                (ti, tj) = (i, j)\n    ans = inf\n    for comb in combinations([1 << i for i in range(26)], r=k):\n        enabled = sum(comb)\n        dp = [[inf] * (m + 2) for _ in range(n + 2)]\n        dp[ti][tj] = ''\n        dq = deque([(ti, tj, '')])\n        while dq:\n            (i, j, s) = dq.popleft()\n            if dp[i][j] < s:\n                continue\n            for (di, dj) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if cbit[di][dj] & enabled != cbit[di][dj]:\n                    continue\n                pre = chars[di][dj] if cbit[di][dj] else ''\n                l = 1 if cbit[di][dj] else 0\n                if len(dp[di][dj]) > len(s) + l or (len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):\n                    dp[di][dj] = pre + s\n                    if l:\n                        dq.append((di, dj, pre + s))\n        if len(ans) > len(dp[si][sj]) or (len(ans) == len(dp[si][sj]) and ans > dp[si][sj]):\n            ans = dp[si][sj]\n    return ans if ans != inf else '-1'"
    }
  ]
}