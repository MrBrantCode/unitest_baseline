{
  "task_id": "taco_4932",
  "entry_point": "init_square_cache",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "height_sub = R - H + 1",
      "mutated_line": "height_sub = R - H - 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H - 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "height_sub = R - H + 1",
      "mutated_line": "height_sub = (R - H) * 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = (R - H) * 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "width_sub = C - W + 1",
      "mutated_line": "width_sub = C - W - 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W - 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "width_sub = C - W + 1",
      "mutated_line": "width_sub = (C - W) * 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = (C - W) * 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_top_left_row = 1",
      "mutated_line": "best_top_left_row = 2",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 2\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_top_left_row = 1",
      "mutated_line": "best_top_left_row = 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 0\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_top_left_row = 1",
      "mutated_line": "best_top_left_row = 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 0\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_top_left_row = 1",
      "mutated_line": "best_top_left_row = -1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = -1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "best_top_left_col = 1",
      "mutated_line": "best_top_left_col = 2",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 2\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "best_top_left_col = 1",
      "mutated_line": "best_top_left_col = 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 0\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "best_top_left_col = 1",
      "mutated_line": "best_top_left_col = 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 0\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "best_top_left_col = 1",
      "mutated_line": "best_top_left_col = -1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = -1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i * 2 for i in range(41)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i * 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i + 2 for i in range(41)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i + 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "height_sub = R - H + 1",
      "mutated_line": "height_sub = R + H + 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R + H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "height_sub = R - H + 1",
      "mutated_line": "height_sub = R * H + 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R * H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "height_sub = R - H + 1",
      "mutated_line": "height_sub = R - H + 2",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 2\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "height_sub = R - H + 1",
      "mutated_line": "height_sub = R - H + 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 0\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "height_sub = R - H + 1",
      "mutated_line": "height_sub = R - H + 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 0\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "height_sub = R - H + 1",
      "mutated_line": "height_sub = R - H + -1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + -1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "width_sub = C - W + 1",
      "mutated_line": "width_sub = C + W + 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C + W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "width_sub = C - W + 1",
      "mutated_line": "width_sub = C * W + 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C * W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "width_sub = C - W + 1",
      "mutated_line": "width_sub = C - W + 2",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 2\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "width_sub = C - W + 1",
      "mutated_line": "width_sub = C - W + 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 0\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "width_sub = C - W + 1",
      "mutated_line": "width_sub = C - W + 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 0\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "width_sub = C - W + 1",
      "mutated_line": "width_sub = C - W + -1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + -1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "min_sum = float('inf')",
      "mutated_line": "min_sum = float('')",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if current_sum < min_sum:",
      "mutated_line": "if current_sum <= min_sum:",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum <= min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if current_sum < min_sum:",
      "mutated_line": "if current_sum >= min_sum:",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum >= min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if current_sum < min_sum:",
      "mutated_line": "if current_sum != min_sum:",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum != min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 3 for i in range(41)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 3 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 1 for i in range(41)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 1 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 0 for i in range(41)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 0 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 1 for i in range(41)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 1 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** -2 for i in range(41)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** -2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "best_top_left_row = i + 1",
      "mutated_line": "best_top_left_row = i - 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i - 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "best_top_left_row = i + 1",
      "mutated_line": "best_top_left_row = i * 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i * 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "best_top_left_col = j + 1",
      "mutated_line": "best_top_left_col = j - 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j - 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "best_top_left_col = j + 1",
      "mutated_line": "best_top_left_col = j * 1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j * 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 2 for i in range(42)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(42)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 2 for i in range(40)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(40)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 2 for i in range(0)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(0)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 2 for i in range(1)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(1)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [i ** 2 for i in range(41)]",
      "mutated_line": "return [i ** 2 for i in range(-41)]",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(-41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "best_top_left_row = i + 1",
      "mutated_line": "best_top_left_row = i + 2",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 2\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "best_top_left_row = i + 1",
      "mutated_line": "best_top_left_row = i + 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 0\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "best_top_left_row = i + 1",
      "mutated_line": "best_top_left_row = i + 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 0\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "best_top_left_row = i + 1",
      "mutated_line": "best_top_left_row = i + -1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + -1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best_top_left_col = j + 1",
      "mutated_line": "best_top_left_col = j + 2",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 2\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best_top_left_col = j + 1",
      "mutated_line": "best_top_left_col = j + 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 0\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best_top_left_col = j + 1",
      "mutated_line": "best_top_left_col = j + 0",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 0\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best_top_left_col = j + 1",
      "mutated_line": "best_top_left_col = j + -1",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + -1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "square_cache[abs(x - y)]",
      "mutated_line": "current_sum = sum((sum((square_cache[abs(x + y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x + y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "square_cache[abs(x - y)]",
      "mutated_line": "current_sum = sum((sum((square_cache[abs(x * y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x * y)] for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k])",
      "mutated_line": "current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i - k][j:j + W], perfect_store[k]))) for k in range(H)))",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i - k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k])",
      "mutated_line": "current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i * k][j:j + W], perfect_store[k]))) for k in range(H)))",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i * k][j:j + W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k])",
      "mutated_line": "current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j - W], perfect_store[k]))) for k in range(H)))",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j - W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for (x, y) in zip(purchased_land[i + k][j:j + W], perfect_store[k])",
      "mutated_line": "current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j * W], perfect_store[k]))) for k in range(H)))",
      "code": "import itertools\n\ndef init_square_cache():\n    return [i ** 2 for i in range(41)]\n\ndef find_best_subgrid(purchased_land, perfect_store, R, C, H, W):\n    square_cache = init_square_cache()\n    height_sub = R - H + 1\n    width_sub = C - W + 1\n    min_sum = float('inf')\n    best_top_left_row = 1\n    best_top_left_col = 1\n    for (i, j) in itertools.product(range(height_sub), range(width_sub)):\n        current_sum = sum((sum((square_cache[abs(x - y)] for (x, y) in zip(purchased_land[i + k][j:j * W], perfect_store[k]))) for k in range(H)))\n        if current_sum < min_sum:\n            min_sum = current_sum\n            best_top_left_row = i + 1\n            best_top_left_col = j + 1\n    return (min_sum, best_top_left_row, best_top_left_col)"
    }
  ]
}