{
  "task_id": "taco_3304",
  "entry_point": "determine_winner",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 'Draw'",
      "mutated_line": "return ''",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "\"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "\"\"\"Check if the current move results in a win.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return False\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "grid = [[None] * size for _ in range(size)]",
      "mutated_line": "grid = [[None] / size for _ in range(size)]",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] / size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "grid = [[None] * size for _ in range(size)]",
      "mutated_line": "grid = [[None] + size for _ in range(size)]",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] + size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "grid = [[None] * size for _ in range(size)]",
      "mutated_line": "grid = [[None] ** size for _ in range(size)]",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] ** size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "D = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}",
      "mutated_line": "D = {c: i for (i, c) in enumerate(ascii_uppercase - ascii_lowercase)}",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase - ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "D = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}",
      "mutated_line": "D = {c: i for (i, c) in enumerate(ascii_uppercase * ascii_lowercase)}",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase * ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(1, connect):",
      "mutated_line": "for x in range(2, connect):",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(2, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(1, connect):",
      "mutated_line": "for x in range(0, connect):",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(0, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(1, connect):",
      "mutated_line": "for x in range(0, connect):",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(0, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(1, connect):",
      "mutated_line": "for x in range(-1, connect):",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(-1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] / 7, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] / 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] + 7, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] + 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] ** 7, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] ** 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [0] / 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] / 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [0] + 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] + 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [0] ** 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] ** 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "count[x] += memo[x]",
      "mutated_line": "count[x] -= memo[x]",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] -= memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 8, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 8, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 6, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 6, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 0, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 0, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 1, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 1, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * -7, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * -7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [0] * 8)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 8)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [0] * 6)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 6)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [0] * 0)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 0)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [0] * 1)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 1)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [0] * -7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * -7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] or 0 <= k < size or 0 <= l < size or (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] or 0 <= k < size or 0 <= l < size or (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 > connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 > connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 < connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 < connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 == connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 == connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "i, p = D[move[0]], move[-1]",
      "mutated_line": "(i, p) = (D[move[0]], move[+1])",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[+1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([False] * 7, [0] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([False] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [1] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [1] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [-1] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [-1] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(memo, count) = ([True] * 7, [0] * 7)",
      "mutated_line": "(memo, count) = ([True] * 7, [1] * 7)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [1] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 < k < size and (0 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 < k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 > k < size and (0 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 > k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 == k < size and (0 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 == k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 <= k < size and (0 < l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 < l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 <= k < size and (0 > l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 > l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 <= k < size and (0 == l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 == l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] != p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] != p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) - 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) - 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) * 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) * 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i, p = D[move[0]], move[-1]",
      "mutated_line": "(i, p) = (D[move[1]], move[-1])",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[1]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i, p = D[move[0]], move[-1]",
      "mutated_line": "(i, p) = (D[move[-1]], move[-1])",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[-1]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i, p = D[move[0]], move[-1]",
      "mutated_line": "(i, p) = (D[move[1]], move[-1])",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[1]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i, p = D[move[0]], move[-1]",
      "mutated_line": "(i, p) = (D[move[0]], move[-2])",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-2])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i, p = D[move[0]], move[-1]",
      "mutated_line": "(i, p) = (D[move[0]], move[-0])",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-0])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i, p = D[move[0]], move[-1]",
      "mutated_line": "(i, p) = (D[move[0]], move[-0])",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-0])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i, p = D[move[0]], move[-1]",
      "mutated_line": "(i, p) = (D[move[0]], move[--1])",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[--1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "j = next((j for j, x in enumerate(grid[i]) if x is None))",
      "mutated_line": "j = next((j for (j, x) in enumerate(grid[i]) if x is not None))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is not None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j + x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j + x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j * x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j * x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i + x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i + x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i * x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i * x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i - x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i - x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i * x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i * x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i + x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i + x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i * x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i * x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j + x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j + x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j * x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j * x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i - x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i - x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i * x, j + x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i * x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j - x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j - x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j * x), (i + x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j * x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i - x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i - x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i * x, j - x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i * x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j + x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j + x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j * x), (i - x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j * x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i + x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i + x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i * x, j + x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i * x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j - x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j - x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))",
      "mutated_line": "yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j * x))",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j * x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 1 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 1 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and -1 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and -1 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 1 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 1 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 <= k < size and (1 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (1 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 <= k < size and (-1 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (-1 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)",
      "mutated_line": "memo[x] = memo[x] and 0 <= k < size and (1 <= l < size) and (grid[k][l] == p)",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (1 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 2 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 2 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 0 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 0 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 0 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 0 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + -1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + -1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] - count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] - count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] * count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] * count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] - count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] - count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] * count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] * count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] - count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] - count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] * count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] * count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[1], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[1], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[-1], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[-1], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[1], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[1], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[2] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[2] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[0] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[0] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[0] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[0] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[-1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[-1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[3], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[3], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[1], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[1], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[0], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[0], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[1], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[1], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[-2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[-2], count[3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[4] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[4] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[2] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[2] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[0] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[0] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[1] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[1] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[-3] + count[4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[-3] + count[4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[5], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[5], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[3], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[3], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[0], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[0], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[1], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[1], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[-4], count[5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[-4], count[5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[6] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[6] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[4] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[4] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[0] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[0] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[1] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[1] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[-5] + count[6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[-5] + count[6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[7]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[7]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[5]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[5]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[0]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[0]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[1]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[1]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[6]) + 1 >= connect",
      "mutated_line": "return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[-6]) + 1 >= connect",
      "code": "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c: i for (i, c) in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef determine_winner(moves, connect, size):\n\n    def gen(i, j):\n        \"\"\"Generator to yield possible directions for checking consecutive pieces.\"\"\"\n        for x in range(1, connect):\n            yield ((i, j - x), (i - x, j), (i + x, j), (i - x, j - x), (i + x, j + x), (i + x, j - x), (i - x, j + x))\n\n    def check(i, j, p):\n        \"\"\"Check if the current move results in a win.\"\"\"\n        (memo, count) = ([True] * 7, [0] * 7)\n        for L in gen(i, j):\n            for (x, (k, l)) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < size and (0 <= l < size) and (grid[k][l] == p)\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1] + count[2], count[3] + count[4], count[5] + count[-6]) + 1 >= connect\n        return True\n    grid = [[None] * size for _ in range(size)]\n    for move in moves:\n        (i, p) = (D[move[0]], move[-1])\n        j = next((j for (j, x) in enumerate(grid[i]) if x is None))\n        if check(i, j, p):\n            return p\n        grid[i][j] = p\n    return 'Draw'"
    }
  ]
}