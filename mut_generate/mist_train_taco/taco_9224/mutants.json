{
  "task_id": "taco_9224",
  "entry_point": "max_pairs_from_cards",
  "mutant_count": 119,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "ans += calc_only_one(mod_arr[0])",
      "mutated_line": "ans -= calc_only_one(mod_arr[0])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans -= calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 1\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = -1\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 1\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if M == 1:",
      "mutated_line": "if M != 1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M != 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % 2 != 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 != 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "ans += calc_only_one(mod_arr[M // 2])",
      "mutated_line": "ans -= calc_only_one(mod_arr[M // 2])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans -= calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "ans += calc_two(mod_arr[i], mod_arr[M - i])",
      "mutated_line": "ans -= calc_two(mod_arr[i], mod_arr[M - i])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans -= calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x in d:",
      "mutated_line": "if x not in d:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x not in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "d[x] += 1",
      "mutated_line": "d[x] -= 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] -= 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 2:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 2:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 0:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 0:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if M == 1:",
      "mutated_line": "if M == -1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == -1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return N // 2",
      "mutated_line": "return N / 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N / 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return N // 2",
      "mutated_line": "return N * 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N * 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return sum_v // 2",
      "mutated_line": "return sum_v / 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v / 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return sum_v // 2",
      "mutated_line": "return sum_v * 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v * 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M * 2 == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M * 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M + 2 == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M + 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % 2 == 1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 1:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % 2 == -1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == -1:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % 2 == 1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 1:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 1\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = -1\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 1\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if len(d_S) == 0:",
      "mutated_line": "if len(d_S) != 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) != 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if sum(d_S.values()) < sum(d_T.values()):",
      "mutated_line": "if sum(d_S.values()) <= sum(d_T.values()):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) <= sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if sum(d_S.values()) < sum(d_T.values()):",
      "mutated_line": "if sum(d_S.values()) >= sum(d_T.values()):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) >= sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if sum(d_S.values()) < sum(d_T.values()):",
      "mutated_line": "if sum(d_S.values()) != sum(d_T.values()):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) != sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "remain_for_pair = cnt_S - cnt_T",
      "mutated_line": "remain_for_pair = cnt_S + cnt_T",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S + cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "remain_for_pair = cnt_S - cnt_T",
      "mutated_line": "remain_for_pair = cnt_S * cnt_T",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S * cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res = cnt_T + pair_cnt",
      "mutated_line": "res = cnt_T - pair_cnt",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T - pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res = cnt_T + pair_cnt",
      "mutated_line": "res = cnt_T * pair_cnt",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T * pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(2, math.ceil(M / 2)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(2, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(0, math.ceil(M / 2)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(0, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(0, math.ceil(M / 2)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(0, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(-1, math.ceil(M / 2)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(-1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d = mod_arr[x % M]",
      "mutated_line": "d = mod_arr[x * M]",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x * M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d = mod_arr[x % M]",
      "mutated_line": "d = mod_arr[x + M]",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x + M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d[x] += 1",
      "mutated_line": "d[x] += 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 2\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d[x] += 1",
      "mutated_line": "d[x] += 0",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 0\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d[x] += 1",
      "mutated_line": "d[x] += 0",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 0\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d[x] += 1",
      "mutated_line": "d[x] += -1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += -1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d[x] = 1",
      "mutated_line": "d[x] = 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 2\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d[x] = 1",
      "mutated_line": "d[x] = 0",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 0\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d[x] = 1",
      "mutated_line": "d[x] = 0",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 0\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d[x] = 1",
      "mutated_line": "d[x] = -1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = -1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return N // 2",
      "mutated_line": "return N // 3",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 3\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return N // 2",
      "mutated_line": "return N // 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 1\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return N // 2",
      "mutated_line": "return N // 0",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 0\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return N // 2",
      "mutated_line": "return N // 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 1\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return N // 2",
      "mutated_line": "return N // -2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // -2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return sum_v // 2",
      "mutated_line": "return sum_v // 3",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 3\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return sum_v // 2",
      "mutated_line": "return sum_v // 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 1\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return sum_v // 2",
      "mutated_line": "return sum_v // 0",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 0\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return sum_v // 2",
      "mutated_line": "return sum_v // 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 1\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return sum_v // 2",
      "mutated_line": "return sum_v // -2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // -2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans += calc_only_one(mod_arr[0])",
      "mutated_line": "ans += calc_only_one(mod_arr[1])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[1])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans += calc_only_one(mod_arr[0])",
      "mutated_line": "ans += calc_only_one(mod_arr[-1])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[-1])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans += calc_only_one(mod_arr[0])",
      "mutated_line": "ans += calc_only_one(mod_arr[1])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[1])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % 3 == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 3 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % 1 == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 1 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % 0 == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 0 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % 1 == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 1 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if M % 2 == 0:",
      "mutated_line": "if M % -2 == 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % -2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(d_S) == 0:",
      "mutated_line": "if len(d_S) == 1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 1:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(d_S) == 0:",
      "mutated_line": "if len(d_S) == -1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == -1:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if len(d_S) == 0:",
      "mutated_line": "if len(d_S) == 1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 1:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "res += v // 2",
      "mutated_line": "res -= v // 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res -= v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif len(d_T) == 0:",
      "mutated_line": "elif len(d_T) != 0:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) != 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "pair_cnt = min(remain_for_pair // 2, max_pair_cnt)",
      "mutated_line": "pair_cnt = min(remain_for_pair / 2, max_pair_cnt)",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair / 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "pair_cnt = min(remain_for_pair // 2, max_pair_cnt)",
      "mutated_line": "pair_cnt = min(remain_for_pair * 2, max_pair_cnt)",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair * 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(1, math.ceil(M * 2)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M * 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(1, math.ceil(M // 2)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M // 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += calc_only_one(mod_arr[M // 2])",
      "mutated_line": "ans += calc_only_one(mod_arr[M / 2])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M / 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += calc_only_one(mod_arr[M // 2])",
      "mutated_line": "ans += calc_only_one(mod_arr[M * 2])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M * 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += v // 2",
      "mutated_line": "res += v / 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v / 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += v // 2",
      "mutated_line": "res += v * 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v * 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(d_T) == 0:",
      "mutated_line": "elif len(d_T) == 1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 1:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(d_T) == 0:",
      "mutated_line": "elif len(d_T) == -1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == -1:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(d_T) == 0:",
      "mutated_line": "elif len(d_T) == 1:",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 1:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "res += v // 2",
      "mutated_line": "res -= v // 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res -= v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_pair_cnt = sum([v // 2 for v in d_S.values()])",
      "mutated_line": "max_pair_cnt = sum([v / 2 for v in d_S.values()])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v / 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_pair_cnt = sum([v // 2 for v in d_S.values()])",
      "mutated_line": "max_pair_cnt = sum([v * 2 for v in d_S.values()])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v * 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pair_cnt = min(remain_for_pair // 2, max_pair_cnt)",
      "mutated_line": "pair_cnt = min(remain_for_pair // 3, max_pair_cnt)",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 3, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pair_cnt = min(remain_for_pair // 2, max_pair_cnt)",
      "mutated_line": "pair_cnt = min(remain_for_pair // 1, max_pair_cnt)",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 1, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pair_cnt = min(remain_for_pair // 2, max_pair_cnt)",
      "mutated_line": "pair_cnt = min(remain_for_pair // 0, max_pair_cnt)",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 0, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pair_cnt = min(remain_for_pair // 2, max_pair_cnt)",
      "mutated_line": "pair_cnt = min(remain_for_pair // 1, max_pair_cnt)",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 1, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pair_cnt = min(remain_for_pair // 2, max_pair_cnt)",
      "mutated_line": "pair_cnt = min(remain_for_pair // -2, max_pair_cnt)",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // -2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(1, math.ceil(M / 3)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 3)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(1, math.ceil(M / 1)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 1)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(1, math.ceil(M / 0)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 0)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(1, math.ceil(M / 1)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 1)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(1, math.ceil(M / 2)):",
      "mutated_line": "for i in range(1, math.ceil(M / -2)):",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / -2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += calc_two(mod_arr[i], mod_arr[M - i])",
      "mutated_line": "ans += calc_two(mod_arr[i], mod_arr[M + i])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M + i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += calc_two(mod_arr[i], mod_arr[M - i])",
      "mutated_line": "ans += calc_two(mod_arr[i], mod_arr[M * i])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M * i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += calc_only_one(mod_arr[M // 2])",
      "mutated_line": "ans += calc_only_one(mod_arr[M // 3])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 3])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += calc_only_one(mod_arr[M // 2])",
      "mutated_line": "ans += calc_only_one(mod_arr[M // 1])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 1])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += calc_only_one(mod_arr[M // 2])",
      "mutated_line": "ans += calc_only_one(mod_arr[M // 0])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 0])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += calc_only_one(mod_arr[M // 2])",
      "mutated_line": "ans += calc_only_one(mod_arr[M // 1])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 1])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += calc_only_one(mod_arr[M // 2])",
      "mutated_line": "ans += calc_only_one(mod_arr[M // -2])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // -2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // 3",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 3\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 1\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // 0",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 0\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 1\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // -2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // -2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "res += v // 2",
      "mutated_line": "res += v / 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v / 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "res += v // 2",
      "mutated_line": "res += v * 2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v * 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_pair_cnt = sum([v // 2 for v in d_S.values()])",
      "mutated_line": "max_pair_cnt = sum([v // 3 for v in d_S.values()])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 3 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_pair_cnt = sum([v // 2 for v in d_S.values()])",
      "mutated_line": "max_pair_cnt = sum([v // 1 for v in d_S.values()])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 1 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_pair_cnt = sum([v // 2 for v in d_S.values()])",
      "mutated_line": "max_pair_cnt = sum([v // 0 for v in d_S.values()])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 0 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_pair_cnt = sum([v // 2 for v in d_S.values()])",
      "mutated_line": "max_pair_cnt = sum([v // 1 for v in d_S.values()])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 1 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_pair_cnt = sum([v // 2 for v in d_S.values()])",
      "mutated_line": "max_pair_cnt = sum([v // -2 for v in d_S.values()])",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // -2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // 3",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 3\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 1\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // 0",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 0\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // 1",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // 1\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res += v // 2",
      "mutated_line": "res += v // -2",
      "code": "import math\n\ndef max_pairs_from_cards(N, M, X):\n    mod_arr = [{} for _ in range(M)]\n    for x in X:\n        d = mod_arr[x % M]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    if M == 1:\n        return N // 2\n\n    def calc_only_one(d):\n        sum_v = sum(d.values())\n        return sum_v // 2\n    ans += calc_only_one(mod_arr[0])\n    if M % 2 == 0:\n        ans += calc_only_one(mod_arr[M // 2])\n\n    def calc_two(d_S, d_T):\n        res = 0\n        if len(d_S) == 0:\n            for v in d_T.values():\n                res += v // 2\n            return res\n        elif len(d_T) == 0:\n            for v in d_S.values():\n                res += v // -2\n            return res\n        if sum(d_S.values()) < sum(d_T.values()):\n            (d_S, d_T) = (d_T, d_S)\n        cnt_S = sum(d_S.values())\n        cnt_T = sum(d_T.values())\n        remain_for_pair = cnt_S - cnt_T\n        max_pair_cnt = sum([v // 2 for v in d_S.values()])\n        pair_cnt = min(remain_for_pair // 2, max_pair_cnt)\n        res = cnt_T + pair_cnt\n        return res\n    for i in range(1, math.ceil(M / 2)):\n        ans += calc_two(mod_arr[i], mod_arr[M - i])\n    return ans"
    }
  ]
}