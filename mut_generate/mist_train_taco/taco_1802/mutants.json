{
  "task_id": "taco_1802",
  "entry_point": "calculate_minimum_games",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "a[i] -= i",
      "mutated_line": "a[i] += i",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] += i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 1\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = -1\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 1\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return res + (y - x)",
      "mutated_line": "return res - (y - x)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res - (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return res + (y - x)",
      "mutated_line": "return res * (y - x)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res * (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if x >= el:",
      "mutated_line": "if x > el:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x > el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if x >= el:",
      "mutated_line": "if x < el:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x < el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if x >= el:",
      "mutated_line": "if x == el:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x == el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if y - x <= idx:",
      "mutated_line": "if y - x < idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x < idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if y - x <= idx:",
      "mutated_line": "if y - x > idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x > idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if y - x <= idx:",
      "mutated_line": "if y - x == idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x == idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 2 * idx + n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx + n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 2 * idx * n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx * n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dx <= 0:",
      "mutated_line": "if dx < 0:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx < 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dx <= 0:",
      "mutated_line": "if dx > 0:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx > 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dx <= 0:",
      "mutated_line": "if dx == 0:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx == 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if el >= y - idx:",
      "mutated_line": "if el > y - idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el > y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if el >= y - idx:",
      "mutated_line": "if el < y - idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el < y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if el >= y - idx:",
      "mutated_line": "if el == y - idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el == y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "res += iters * n",
      "mutated_line": "res -= iters * n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res -= iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "x += iters * dx",
      "mutated_line": "x -= iters * dx",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x -= iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "res += iters * n",
      "mutated_line": "res -= iters * n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res -= iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "x += iters * dx",
      "mutated_line": "x -= iters * dx",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x -= iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return res + (y - x)",
      "mutated_line": "return res + (y + x)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y + x)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return res + (y - x)",
      "mutated_line": "return res + y * x",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + y * x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if y - x <= idx:",
      "mutated_line": "if y + x <= idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y + x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if y - x <= idx:",
      "mutated_line": "if y * x <= idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y * x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return res + (y - x)",
      "mutated_line": "return res - (y - x)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res - (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return res + (y - x)",
      "mutated_line": "return res * (y - x)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res * (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 2 / idx - n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 / idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 2 + idx - n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 + idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 2 ** idx - n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 ** idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dx <= 0:",
      "mutated_line": "if dx <= 1:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 1:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dx <= 0:",
      "mutated_line": "if dx <= -1:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= -1:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dx <= 0:",
      "mutated_line": "if dx <= 1:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 1:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if y - x > idx:",
      "mutated_line": "if y - x >= idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x >= idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if y - x > idx:",
      "mutated_line": "if y - x <= idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x <= idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if y - x > idx:",
      "mutated_line": "if y - x != idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x != idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return y - x",
      "mutated_line": "return y + x",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y + x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return y - x",
      "mutated_line": "return y * x",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y * x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if el >= y - idx:",
      "mutated_line": "if el >= y + idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y + idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if el >= y - idx:",
      "mutated_line": "if el >= y * idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y * idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res += iters * n",
      "mutated_line": "res += iters / n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters / n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res += iters * n",
      "mutated_line": "res += iters + n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters + n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res += iters * n",
      "mutated_line": "res += iters ** n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters ** n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "x += iters * dx",
      "mutated_line": "x += iters / dx",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters / dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "x += iters * dx",
      "mutated_line": "x += iters + dx",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters + dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "x += iters * dx",
      "mutated_line": "x += iters ** dx",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters ** dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res += iters * n",
      "mutated_line": "res += iters / n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters / n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res += iters * n",
      "mutated_line": "res += iters + n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters + n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res += iters * n",
      "mutated_line": "res += iters ** n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters ** n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "x += iters * dx",
      "mutated_line": "x += iters / dx",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters / dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "x += iters * dx",
      "mutated_line": "x += iters + dx",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters + dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "x += iters * dx",
      "mutated_line": "x += iters ** dx",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters ** dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return res + (y - x)",
      "mutated_line": "return res + (y + x)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y + x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return res + (y - x)",
      "mutated_line": "return res + y * x",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + y * x\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 3 * idx - n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 3 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 1 * idx - n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 1 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 0 * idx - n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 0 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = 1 * idx - n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 1 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = 2 * idx - n",
      "mutated_line": "dx = -2 * idx - n",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = -2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if y - x > idx:",
      "mutated_line": "if y + x > idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y + x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if y - x > idx:",
      "mutated_line": "if y * x > idx:",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y * x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return +1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "iters = math.ceil((y - x - idx) / dx)",
      "mutated_line": "iters = math.ceil((y - x - idx) * dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) * dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "iters = math.ceil((y - x - idx) / dx)",
      "mutated_line": "iters = math.ceil((y - x - idx) // dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) // dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "iters = math.ceil((el - x) / dx)",
      "mutated_line": "iters = math.ceil((el - x) * dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) * dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "iters = math.ceil((el - x) / dx)",
      "mutated_line": "iters = math.ceil((el - x) // dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) // dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -2\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -0\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -0\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return --1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "iters = math.ceil((y - x - idx) / dx)",
      "mutated_line": "iters = math.ceil((y - x + idx) / dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x + idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "iters = math.ceil((y - x - idx) / dx)",
      "mutated_line": "iters = math.ceil((y - x) * idx / dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x) * idx / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "iters = math.ceil((el - x) / dx)",
      "mutated_line": "iters = math.ceil((el + x) / dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el + x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "iters = math.ceil((el - x) / dx)",
      "mutated_line": "iters = math.ceil(el * x / dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y - x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil(el * x / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "iters = math.ceil((y - x - idx) / dx)",
      "mutated_line": "iters = math.ceil((y + x - idx) / dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y + x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "iters = math.ceil((y - x - idx) / dx)",
      "mutated_line": "iters = math.ceil((y * x - idx) / dx)",
      "code": "import math\n\ndef calculate_minimum_games(n, x, y, a):\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    res = 0\n    for (idx, el) in enumerate(a):\n        if x >= el:\n            continue\n        if y - x <= idx:\n            return res + (y - x)\n        dx = 2 * idx - n\n        if dx <= 0:\n            if y - x > idx:\n                return -1\n            return y - x\n        if el >= y - idx:\n            iters = math.ceil((y * x - idx) / dx)\n            res += iters * n\n            x += iters * dx\n            break\n        else:\n            iters = math.ceil((el - x) / dx)\n            res += iters * n\n            x += iters * dx\n    return res + (y - x)"
    }
  ]
}