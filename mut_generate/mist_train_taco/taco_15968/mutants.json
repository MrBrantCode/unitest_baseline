{
  "task_id": "taco_15968",
  "entry_point": "reconstruct_network_topology",
  "mutant_count": 89,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "degree = [1]",
      "mutated_line": "degree = [2]",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [2]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "degree = [1]",
      "mutated_line": "degree = [0]",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [0]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "degree = [1]",
      "mutated_line": "degree = [0]",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [0]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "degree = [1]",
      "mutated_line": "degree = [-1]",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [-1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] -= 1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] -= 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] -= 1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] -= 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if next_sw != prev:",
      "mutated_line": "if next_sw == prev:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw == prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "switch = [[1]]",
      "mutated_line": "switch = [[2]]",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[2]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "switch = [[1]]",
      "mutated_line": "switch = [[0]]",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[0]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "switch = [[1]]",
      "mutated_line": "switch = [[0]]",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[0]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "switch = [[1]]",
      "mutated_line": "switch = [[-1]]",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[-1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dt_i in distance_matrix[1:]:",
      "mutated_line": "for (m, sw_m) in enumerate(switch):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[2:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dt_i in distance_matrix[1:]:",
      "mutated_line": "for (m, sw_m) in enumerate(switch):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[0:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dt_i in distance_matrix[1:]:",
      "mutated_line": "for (m, sw_m) in enumerate(switch):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[0:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for dt_i in distance_matrix[1:]:",
      "mutated_line": "for (m, sw_m) in enumerate(switch):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[-1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] -= 1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] -= 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] += 2",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 2\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 0\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 0\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] += -1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += -1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] -= 1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] -= 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "sw += 1",
      "mutated_line": "sw -= 1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw -= 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] += 2",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 2\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 0\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 0\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] += -1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += -1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dist_j != dt_ij - 1:",
      "mutated_line": "if dist_j == dt_ij - 1:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j == dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] += 2",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 2\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 0\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 0\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "degree[m] += 1",
      "mutated_line": "degree[m] += -1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += -1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "degree.append(1)",
      "mutated_line": "degree.append(2)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(2)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "degree.append(1)",
      "mutated_line": "degree.append(0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(0)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "degree.append(1)",
      "mutated_line": "degree.append(0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(0)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "degree.append(1)",
      "mutated_line": "degree.append(-1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(-1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(2, diff):",
      "mutated_line": "for i in range(3, diff):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(3, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(2, diff):",
      "mutated_line": "for i in range(1, diff):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(1, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(2, diff):",
      "mutated_line": "for i in range(0, diff):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(0, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(2, diff):",
      "mutated_line": "for i in range(1, diff):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(1, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(2, diff):",
      "mutated_line": "for i in range(-2, diff):",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(-2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] += 2",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 2\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 0\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 0\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "degree[sw] += 1",
      "mutated_line": "degree[sw] += -1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += -1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "sw += 1",
      "mutated_line": "sw += 2",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 2\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "sw += 1",
      "mutated_line": "sw += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 0\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "sw += 1",
      "mutated_line": "sw += 0",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 0\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "sw += 1",
      "mutated_line": "sw += -1",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += -1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dfs(sw, sw, 1)",
      "mutated_line": "dfs(sw, sw, 2)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 2)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dfs(sw, sw, 1)",
      "mutated_line": "dfs(sw, sw, 0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 0)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dfs(sw, sw, 1)",
      "mutated_line": "dfs(sw, sw, 0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 0)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dfs(sw, sw, 1)",
      "mutated_line": "dfs(sw, sw, -1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, -1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dfs(next_sw, sw_id, dist + 1)",
      "mutated_line": "dfs(next_sw, sw_id, dist - 1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist - 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dfs(next_sw, sw_id, dist + 1)",
      "mutated_line": "dfs(next_sw, sw_id, dist * 1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist * 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if dist_j != dt_ij - 1:",
      "mutated_line": "if dist_j != dt_ij + 1:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij + 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if dist_j != dt_ij - 1:",
      "mutated_line": "if dist_j != dt_ij * 1:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij * 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dfs(m, m, 1)",
      "mutated_line": "dfs(m, m, 2)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 2)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dfs(m, m, 1)",
      "mutated_line": "dfs(m, m, 0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 0)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dfs(m, m, 1)",
      "mutated_line": "dfs(m, m, 0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 0)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dfs(m, m, 1)",
      "mutated_line": "dfs(m, m, -1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, -1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "g = (x - y for x, y in zip(dt_i, sw_m))",
      "mutated_line": "g = (x + y for (x, y) in zip(dt_i, sw_m))",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x + y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "g = (x - y for x, y in zip(dt_i, sw_m))",
      "mutated_line": "g = (x * y for (x, y) in zip(dt_i, sw_m))",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x * y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if d != diff:",
      "mutated_line": "if d == diff:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d == diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "switch.append([dist + 1 for dist in switch[m]])",
      "mutated_line": "switch.append([dist - 1 for dist in switch[m]])",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist - 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "switch.append([dist + 1 for dist in switch[m]])",
      "mutated_line": "switch.append([dist * 1 for dist in switch[m]])",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist * 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "adj[sw].append(sw + 1)",
      "mutated_line": "adj[sw].append(sw - 1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw - 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "adj[sw].append(sw + 1)",
      "mutated_line": "adj[sw].append(sw * 1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw * 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "degree.append(1)",
      "mutated_line": "degree.append(2)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(2)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "degree.append(1)",
      "mutated_line": "degree.append(0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(0)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "degree.append(1)",
      "mutated_line": "degree.append(0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(0)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "degree.append(1)",
      "mutated_line": "degree.append(-1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(-1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dfs(next_sw, sw_id, dist + 1)",
      "mutated_line": "dfs(next_sw, sw_id, dist + 2)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 2)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dfs(next_sw, sw_id, dist + 1)",
      "mutated_line": "dfs(next_sw, sw_id, dist + 0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 0)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dfs(next_sw, sw_id, dist + 1)",
      "mutated_line": "dfs(next_sw, sw_id, dist + 0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 0)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dfs(next_sw, sw_id, dist + 1)",
      "mutated_line": "dfs(next_sw, sw_id, dist + -1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + -1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist_j != dt_ij - 1:",
      "mutated_line": "if dist_j != dt_ij - 2:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 2:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist_j != dt_ij - 1:",
      "mutated_line": "if dist_j != dt_ij - 0:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 0:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist_j != dt_ij - 1:",
      "mutated_line": "if dist_j != dt_ij - 0:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 0:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist_j != dt_ij - 1:",
      "mutated_line": "if dist_j != dt_ij - -1:",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - -1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "switch.append([dist + 1 for dist in switch[m]])",
      "mutated_line": "switch.append([dist + 2 for dist in switch[m]])",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 2 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "switch.append([dist + 1 for dist in switch[m]])",
      "mutated_line": "switch.append([dist + 0 for dist in switch[m]])",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 0 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "switch.append([dist + 1 for dist in switch[m]])",
      "mutated_line": "switch.append([dist + 0 for dist in switch[m]])",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 0 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "switch.append([dist + 1 for dist in switch[m]])",
      "mutated_line": "switch.append([dist + -1 for dist in switch[m]])",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + -1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "switch.append([dist + i for dist in switch[m]])",
      "mutated_line": "switch.append([dist - i for dist in switch[m]])",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist - i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "switch.append([dist + i for dist in switch[m]])",
      "mutated_line": "switch.append([dist * i for dist in switch[m]])",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist * i for dist in switch[m]])\n                adj[sw].append(sw + 1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "adj[sw].append(sw + 1)",
      "mutated_line": "adj[sw].append(sw + 2)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 2)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "adj[sw].append(sw + 1)",
      "mutated_line": "adj[sw].append(sw + 0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 0)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "adj[sw].append(sw + 1)",
      "mutated_line": "adj[sw].append(sw + 0)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + 0)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "adj[sw].append(sw + 1)",
      "mutated_line": "adj[sw].append(sw + -1)",
      "code": "def reconstruct_network_topology(distance_matrix):\n\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    N = len(distance_matrix)\n    switch = [[1]]\n    degree = [1]\n    adj = [[]]\n    for dt_i in distance_matrix[1:]:\n        for (m, sw_m) in enumerate(switch):\n            for (dist_j, dt_ij) in zip(sw_m, dt_i):\n                if dist_j != dt_ij - 1:\n                    break\n            else:\n                degree[m] += 1\n                dfs(m, m, 1)\n                break\n        else:\n            for (m, sw_m) in enumerate(switch):\n                g = (x - y for (x, y) in zip(dt_i, sw_m))\n                diff = next(g)\n                for d in g:\n                    if d != diff:\n                        break\n                else:\n                    break\n            sw = len(switch)\n            switch.append([dist + 1 for dist in switch[m]])\n            adj[m].append(sw)\n            adj.append([m])\n            degree[m] += 1\n            degree.append(1)\n            for i in range(2, diff):\n                switch.append([dist + i for dist in switch[m]])\n                adj[sw].append(sw + -1)\n                adj.append([sw])\n                degree[sw] += 1\n                degree.append(1)\n                sw += 1\n            degree[sw] += 1\n            dfs(sw, sw, 1)\n    degree.sort()\n    return degree"
    }
  ]
}