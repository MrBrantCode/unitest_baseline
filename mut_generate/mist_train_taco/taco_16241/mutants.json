{
  "task_id": "taco_16241",
  "entry_point": "find_sequences",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "level = 0",
      "mutated_line": "level = 1",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 1\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "level = 0",
      "mutated_line": "level = -1",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = -1\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "level = 0",
      "mutated_line": "level = 1",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 1\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(vec) > level:",
      "mutated_line": "if len(vec) >= level:",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) >= level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(vec) > level:",
      "mutated_line": "if len(vec) <= level:",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) <= level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(vec) > level:",
      "mutated_line": "if len(vec) != level:",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) != level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "level += 1",
      "mutated_line": "level -= 1",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level -= 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if word == targetWord:",
      "mutated_line": "if word != targetWord:",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word != targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level += 1",
      "mutated_line": "level += 2",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 2\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level += 1",
      "mutated_line": "level += 0",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 0\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level += 1",
      "mutated_line": "level += 0",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 0\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level += 1",
      "mutated_line": "level += -1",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += -1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "word = vec[-1]",
      "mutated_line": "word = vec[+1]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[+1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for ch in 'abcdefghijklmnopqrstuvwxyz':",
      "mutated_line": "for ch in '':",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in '':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "word = vec[-1]",
      "mutated_line": "word = vec[-2]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-2]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "word = vec[-1]",
      "mutated_line": "word = vec[-0]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-0]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "word = vec[-1]",
      "mutated_line": "word = vec[-0]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-0]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "word = vec[-1]",
      "mutated_line": "word = vec[--1]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[--1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif len(ans[0]) == len(vec):",
      "mutated_line": "elif len(ans[0]) != len(vec):",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) != len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] + ch - word[i + 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch - word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = (word[:i] + ch) * word[i + 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = (word[:i] + ch) * word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if word in st:",
      "mutated_line": "if word not in st:",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word not in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] + original - word[i + 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original - word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = (word[:i] + original) * word[i + 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = (word[:i] + original) * word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] - ch + word[i + 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] - ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] * ch + word[i + 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] * ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] - original + word[i + 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] - original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] * original + word[i + 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] * original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif len(ans[0]) == len(vec):",
      "mutated_line": "elif len(ans[1]) == len(vec):",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[1]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif len(ans[0]) == len(vec):",
      "mutated_line": "elif len(ans[-1]) == len(vec):",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[-1]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif len(ans[0]) == len(vec):",
      "mutated_line": "elif len(ans[1]) == len(vec):",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[1]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] + ch + word[i - 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i - 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] + ch + word[i * 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i * 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] + original + word[i - 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i - 1:]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] + original + word[i * 1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i * 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] + ch + word[i + 2:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 2:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] + ch + word[i + 0:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 0:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] + ch + word[i + 0:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 0:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "word = word[:i] + ch + word[i + 1:]",
      "mutated_line": "word = word[:i] + ch + word[i + -1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + -1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 1:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] + original + word[i + 2:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 2:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] + original + word[i + 0:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 0:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] + original + word[i + 0:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + 0:]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "word = word[:i] + original + word[i + 1:]",
      "mutated_line": "word = word[:i] + original + word[i + -1:]",
      "code": "from collections import deque\n\ndef find_sequences(startWord, targetWord, wordList):\n    st = set(wordList)\n    queue = deque()\n    queue.append([startWord])\n    ans = []\n    usedonLevel = [startWord]\n    level = 0\n    while queue:\n        vec = queue.popleft()\n        if len(vec) > level:\n            level += 1\n            for ele in usedonLevel:\n                st.discard(ele)\n        word = vec[-1]\n        if word == targetWord:\n            if not ans:\n                ans.append(vec)\n            elif len(ans[0]) == len(vec):\n                ans.append(vec)\n        for i in range(len(word)):\n            original = word[i]\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                word = word[:i] + ch + word[i + 1:]\n                if word in st:\n                    vec.append(word)\n                    queue.append(vec.copy())\n                    usedonLevel.append(word)\n                    vec.pop()\n                word = word[:i] + original + word[i + -1:]\n    return ans"
    }
  ]
}